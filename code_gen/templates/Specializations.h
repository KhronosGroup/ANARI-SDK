// This file was generated by $generator from $template

#pragma once
#include "$prefixObjects.h"
#include "$prefixObject.h"

#include "$prefixFrameObject.h"
#include "$prefixArrayObjects.h"


#include <cstdio>

$begin_namespaces

/******************************************************************************
   The following code serves illustration purposes and should be replaced
   Further specializations are provided in $prefixFrameObject.h and
   $prefixArrayObjects.h since frame and array objects have extended
   interfaces.
   Most likely you want to specialize other objects in their own
   headers/implementiation files and just include them here.
******************************************************************************/


/******************************************************************************
   Implement custom behavior by specializing the Object template.
   Either fully specify an object inheriting from ObjectBase.
******************************************************************************/

template<>
class Object<World> : public ObjectBase {
protected:
   World staging;
   World current;
public:
   Object(ANARIDevice d, ANARIObject handle) : ObjectBase(d, handle), staging(d, handle), current(d, handle) {

   }
   bool set(const char *paramname, ANARIDataType type, const void *mem) override {
      return staging.set(paramname, type, mem);
   }
   void unset(const char *paramname) override {
      staging.unset(paramname);
   }
   void commit() override {
      current = staging;
      std::printf("Hi, I'm a world object.\n");
   }
   int getProperty(
      const char *propname, ANARIDataType type,
      void *mem, uint64_t size, ANARIWaitMask mask) override {
      (void)propname;
      (void)type;
      (void)mem;
      (void)size;
      (void)mask;
      return 0;
   }

   ANARIDataType type() const override { return World::type; }
   const char* subtype() const override { return World::subtype; }
   ParameterPack& parameters() override { return current; }
};


/******************************************************************************
   Or inherit from DefaultObject<T> to get common behavior and override only
   what you need. Don't forget to call the DefaultObject:: versions of the
   functions you override where required (commit, set, unset)
******************************************************************************/


template<>
class Object<RendererDefault> : public DefaultObject<RendererDefault> {
public:
   using base = DefaultObject<RendererDefault>;

   Object(ANARIDevice device, ANARIObject handle)
   : base(device, handle)
   {

   }

   void commit() override {
      base::commit();
      std::printf("Hi, I'm a %s renderer.\n", subtype());

      // read a parameter
      const char *name = nullptr;
      if(current.name.get(ANARI_STRING, &name)) {
         std::printf("My name is %s.\n", name);
      }
   }

   ANARIObject firstOwner = nullptr;
   bool uniqueOwnership = true;

   // the Object interface can be overriden to track additional data
   // such as who increased the refcount.
   void retainInternal(ANARIObject obj) override {
      base::retainInternal(obj);
      if(firstOwner == nullptr) {
         firstOwner = obj;
      } else if(obj != firstOwner) {
         uniqueOwnership = false;
      }
   }
};


$end_namespaces
