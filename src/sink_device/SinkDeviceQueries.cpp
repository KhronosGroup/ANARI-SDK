// Copyright 2024 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_queries.py
// Don't make changes to this directly

#include <stdint.h>
#include <math.h>
#include <anari/anari.h>
namespace sink_device {
static int subtype_hash(const char *str) {
   static const uint32_t table[] = {0x7a6f0012u,0x6a65002bu,0x0u,0x0u,0x0u,0x65640040u,0x6e6d0044u,0x0u,0x0u,0x0u,0x70610051u,0x0u,0x736d008bu,0x736500aau,0x767500dcu,0x6a6900e0u,0x757000e4u,0x73720107u,0x6f6e001du,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720020u,0x0u,0x0u,0x0u,0x6d6c0024u,0x6665001eu,0x100001fu,0x80000000u,0x77760021u,0x66650022u,0x1000023u,0x80000001u,0x6a690025u,0x6f6e0026u,0x65640027u,0x66650028u,0x73720029u,0x100002au,0x80000002u,0x67660030u,0x0u,0x0u,0x0u,0x73720036u,0x62610031u,0x76750032u,0x6d6c0033u,0x75740034u,0x1000035u,0x80000003u,0x66650037u,0x64630038u,0x75740039u,0x6a69003au,0x706f003bu,0x6f6e003cu,0x6261003du,0x6d6c003eu,0x100003fu,0x80000004u,0x73720041u,0x6a690042u,0x1000043u,0x80000005u,0x62610045u,0x68670046u,0x66650047u,0x34310048u,0x4544004bu,0x4544004du,0x4544004fu,0x100004cu,0x80000006u,0x100004eu,0x80000007u,0x1000050u,0x80000008u,0x75740060u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x75740064u,0x75740061u,0x66650062u,0x1000063u,0x80000009u,0x6a690065u,0x706f0066u,0x6f6e0067u,0x55530068u,0x6463006au,0x73720082u,0x6261006bu,0x6d6c006cu,0x6665006du,0x5352006eu,0x706f006fu,0x75740070u,0x62610071u,0x75740072u,0x6a690073u,0x706f0074u,0x6f6e0075u,0x55540076u,0x73720077u,0x62610078u,0x6f6e0079u,0x7473007au,0x6d6c007bu,0x6261007cu,0x7574007du,0x6a69007eu,0x706f007fu,0x6f6e0080u,0x1000081u,0x8000000au,0x62610083u,0x6f6e0084u,0x74730085u,0x67660086u,0x706f0087u,0x73720088u,0x6e6d0089u,0x100008au,0x8000000bu,0x6f6e0091u,0x0u,0x0u,0x0u,0x0u,0x7574009fu,0x6a690092u,0x65640093u,0x6a690094u,0x73720095u,0x66650096u,0x64630097u,0x75740098u,0x6a690099u,0x706f009au,0x6f6e009bu,0x6261009cu,0x6d6c009du,0x100009eu,0x8000000cu,0x696800a0u,0x706f00a1u,0x686700a2u,0x737200a3u,0x626100a4u,0x717000a5u,0x696800a6u,0x6a6900a7u,0x646300a8u,0x10000a9u,0x8000000du,0x737200b8u,0x0u,0x0u,0x7a7900c2u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a6900d0u,0x0u,0x0u,0x6a6900d4u,0x747300b9u,0x717000bau,0x666500bbu,0x646300bcu,0x757400bdu,0x6a6900beu,0x777600bfu,0x666500c0u,0x10000c1u,0x8000000eu,0x747300c3u,0x6a6900c4u,0x646300c5u,0x626100c6u,0x6d6c00c7u,0x6d6c00c8u,0x7a7900c9u,0x434200cau,0x626100cbu,0x747300ccu,0x666500cdu,0x656400ceu,0x10000cfu,0x8000000fu,0x6f6e00d1u,0x757400d2u,0x10000d3u,0x80000010u,0x6e6d00d5u,0x6a6900d6u,0x757400d7u,0x6a6900d8u,0x777600d9u,0x666500dau,0x10000dbu,0x80000011u,0x626100ddu,0x656400deu,0x10000dfu,0x80000012u,0x6f6e00e1u,0x686700e2u,0x10000e3u,0x80000013u,0x706800e9u,0x0u,0x0u,0x0u,0x737200f7u,0x666500f1u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x757400f5u,0x737200f2u,0x666500f3u,0x10000f4u,0x80000014u,0x10000f6u,0x80000015u,0x767500f8u,0x646300f9u,0x757400fau,0x767500fbu,0x737200fcu,0x666500fdu,0x656400feu,0x535200ffu,0x66650100u,0x68670101u,0x76750102u,0x6d6c0103u,0x62610104u,0x73720105u,0x1000106u,0x80000016u,0x6a610108u,0x6f6e0111u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261012eu,0x74730112u,0x67660113u,0x70650114u,0x7372011fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372012bu,0x47460120u,0x76750121u,0x6f6e0122u,0x64630123u,0x75740124u,0x6a690125u,0x706f0126u,0x6f6e0127u,0x32310128u,0x45440129u,0x100012au,0x80000017u,0x6e6d012cu,0x100012du,0x80000018u,0x6f6e012fu,0x68670130u,0x6d6c0131u,0x66650132u,0x1000133u,0x80000019u};
   uint32_t cur = 0x75630000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static int param_hash(const char *str) {
   static const uint32_t table[] = {0x75630017u,0x626100c4u,0x703000e5u,0x6a6101e6u,0x6e6401fau,0x73610211u,0x736502ceu,0x666502e7u,0x736402edu,0x0u,0x0u,0x6a61049eu,0x706104b0u,0x706104f7u,0x76630511u,0x736f055bu,0x0u,0x706105b2u,0x76630629u,0x73680765u,0x716e0791u,0x706107a0u,0x736f08d1u,0x64630029u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x71700034u,0x6362004cu,0x6867006eu,0x0u,0x6665007cu,0x0u,0x73720089u,0x7170008du,0x75740092u,0x7675002au,0x6e6d002bu,0x7675002cu,0x6d6c002du,0x6261002eu,0x7574002fu,0x6a690030u,0x706f0031u,0x6f6e0032u,0x1000033u,0x80000000u,0x69680035u,0x62610036u,0x4e430037u,0x76750042u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0048u,0x75740043u,0x706f0044u,0x67660045u,0x67660046u,0x1000047u,0x80000001u,0x65640049u,0x6665004au,0x100004bu,0x80000002u,0x6a69004du,0x6665004eu,0x6f6e004fu,0x75740050u,0x53430051u,0x706f0061u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610066u,0x6d6c0062u,0x706f0063u,0x73720064u,0x1000065u,0x80000003u,0x65640067u,0x6a690068u,0x62610069u,0x6f6e006au,0x6463006bu,0x6665006cu,0x100006du,0x80000004u,0x7675006fu,0x6d6c0070u,0x62610071u,0x73720072u,0x45440073u,0x6a690074u,0x62610075u,0x6e6d0076u,0x66650077u,0x75740078u,0x66650079u,0x7372007au,0x100007bu,0x80000005u,0x7372007du,0x7574007eu,0x7675007fu,0x73720080u,0x66650081u,0x53520082u,0x62610083u,0x65640084u,0x6a690085u,0x76750086u,0x74730087u,0x1000088u,0x80000006u,0x6261008au,0x7a79008bu,0x100008cu,0x80000007u,0x6665008eu,0x6463008fu,0x75740090u,0x1000091u,0x80000008u,0x73650093u,0x6f6e00a1u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a6900b7u,0x767500a2u,0x626100a3u,0x757400a4u,0x6a6900a5u,0x706f00a6u,0x6f6e00a7u,0x454300a8u,0x706f00aau,0x6a6900afu,0x6d6c00abu,0x706f00acu,0x737200adu,0x10000aeu,0x80000009u,0x747300b0u,0x757400b1u,0x626100b2u,0x6f6e00b3u,0x646300b4u,0x666500b5u,0x10000b6u,0x8000000au,0x636200b8u,0x767500b9u,0x757400bau,0x666500bbu,0x343000bcu,0x10000c0u,0x10000c1u,0x10000c2u,0x10000c3u,0x8000000bu,0x8000000cu,0x8000000du,0x8000000eu,0x746300c5u,0x6c6b00d6u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666500deu,0x686700d7u,0x737200d8u,0x706f00d9u,0x767500dau,0x6f6e00dbu,0x656400dcu,0x10000ddu,0x8000000fu,0x444300dfu,0x706f00e0u,0x6d6c00e1u,0x706f00e2u,0x737200e3u,0x10000e4u,0x80000010u,0x1000125u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x716d0126u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610130u,0x0u,0x0u,0x0u,0x66650179u,0x0u,0x0u,0x6d6c01e2u,0x80000011u,0x6665012au,0x0u,0x0u,0x7473012eu,0x7372012bu,0x6261012cu,0x100012du,0x80000012u,0x100012fu,0x80000013u,0x6f6e0131u,0x6f6e0132u,0x66650133u,0x6d6c0134u,0x2f2e0135u,0x71610136u,0x6d6c0146u,0x0u,0x706f014cu,0x66650151u,0x0u,0x0u,0x0u,0x0u,0x6f6e0156u,0x0u,0x0u,0x0u,0x0u,0x706f0160u,0x63620166u,0x7372016eu,0x63620147u,0x66650148u,0x65640149u,0x706f014au,0x100014bu,0x80000014u,0x6d6c014du,0x706f014eu,0x7372014fu,0x1000150u,0x80000015u,0x71700152u,0x75740153u,0x69680154u,0x1000155u,0x80000016u,0x74730157u,0x75740158u,0x62610159u,0x6f6e015au,0x6463015bu,0x6665015cu,0x4a49015du,0x6564015eu,0x100015fu,0x80000017u,0x73720161u,0x6e6d0162u,0x62610163u,0x6d6c0164u,0x1000165u,0x80000018u,0x6b6a0167u,0x66650168u,0x64630169u,0x7574016au,0x4a49016bu,0x6564016cu,0x100016du,0x80000019u,0x6a69016fu,0x6e6d0170u,0x6a690171u,0x75740172u,0x6a690173u,0x77760174u,0x66650175u,0x4a490176u,0x65640177u,0x1000178u,0x8000001au,0x6261017au,0x7372017bu,0x6463017cu,0x706f017du,0x6261017eu,0x7574017fu,0x53000180u,0x8000001bu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f01d3u,0x0u,0x0u,0x0u,0x706f01d9u,0x737201d4u,0x6e6d01d5u,0x626101d6u,0x6d6c01d7u,0x10001d8u,0x8000001cu,0x767501dau,0x686701dbu,0x696801dcu,0x6f6e01ddu,0x666501deu,0x747301dfu,0x747301e0u,0x10001e1u,0x8000001du,0x706f01e3u,0x737201e4u,0x10001e5u,0x8000001eu,0x757401efu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x737201f2u,0x626101f0u,0x10001f1u,0x8000001fu,0x666501f3u,0x646301f4u,0x757401f5u,0x6a6901f6u,0x706f01f7u,0x6f6e01f8u,0x10001f9u,0x80000020u,0x68670204u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a69020au,0x66650205u,0x33310206u,0x1000208u,0x1000209u,0x80000021u,0x80000022u,0x7473020bu,0x7473020cu,0x6a69020du,0x7776020eu,0x6665020fu,0x1000210u,0x80000023u,0x736c0223u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c0235u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7763023au,0x0u,0x0u,0x6261025bu,0x6d6c022au,0x0u,0x0u,0x0u,0x0u,0x0u,0x1000234u,0x706f022bu,0x6766022cu,0x6766022du,0x4241022eu,0x6f6e022fu,0x68670230u,0x6d6c0231u,0x66650232u,0x1000233u,0x80000024u,0x80000025u,0x75740236u,0x66650237u,0x73720238u,0x1000239u,0x80000026u,0x7675024eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7a790259u,0x7473024fu,0x45440250u,0x6a690251u,0x74730252u,0x75740253u,0x62610254u,0x6f6e0255u,0x64630256u,0x66650257u,0x1000258u,0x80000027u,0x100025au,0x80000028u,0x6e6d025cu,0x6665025du,0x4443025eu,0x706f025fu,0x6e6d0260u,0x71700261u,0x6d6c0262u,0x66650263u,0x75740264u,0x6a690265u,0x706f0266u,0x6f6e0267u,0x44430268u,0x62610269u,0x6d6c026au,0x6d6c026bu,0x6362026cu,0x6261026du,0x6463026eu,0x6c6b026fu,0x56000270u,0x80000029u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x747302c6u,0x666502c7u,0x737202c8u,0x454402c9u,0x626102cau,0x757402cbu,0x626102ccu,0x10002cdu,0x8000002au,0x706f02dcu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f02e3u,0x6e6d02ddu,0x666502deu,0x757402dfu,0x737202e0u,0x7a7902e1u,0x10002e2u,0x8000002bu,0x767502e4u,0x717002e5u,0x10002e6u,0x8000002cu,0x6a6902e8u,0x686702e9u,0x696802eau,0x757402ebu,0x10002ecu,0x8000002du,0x10002fcu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626102fdu,0x75410359u,0x73720421u,0x0u,0x0u,0x73690423u,0x8000002eu,0x686702feu,0x666502ffu,0x53000300u,0x8000002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x66650353u,0x68670354u,0x6a690355u,0x706f0356u,0x6f6e0357u,0x1000358u,0x80000030u,0x7574038du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x67660396u,0x0u,0x0u,0x0u,0x0u,0x7372039cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666503a5u,0x0u,0x0u,0x0u,0x0u,0x757403aeu,0x666503b4u,0x7574038eu,0x7372038fu,0x6a690390u,0x63620391u,0x76750392u,0x75740393u,0x66650394u,0x1000395u,0x80000031u,0x67660397u,0x74730398u,0x66650399u,0x7574039au,0x100039bu,0x80000032u,0x6261039du,0x6f6e039eu,0x7473039fu,0x676603a0u,0x706f03a1u,0x737203a2u,0x6e6d03a3u,0x10003a4u,0x80000033u,0x737203a6u,0x535203a7u,0x626103a8u,0x656403a9u,0x6a6903aau,0x767503abu,0x747303acu,0x10003adu,0x80000034u,0x626103afu,0x6f6e03b0u,0x646303b1u,0x666503b2u,0x10003b3u,0x80000035u,0x736e03b5u,0x747303bau,0x0u,0x0u,0x0u,0x7170040fu,0x6a6903bbu,0x757403bcu,0x7a7903bdu,0x450003beu,0x80000036u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a690403u,0x74730404u,0x75740405u,0x73720406u,0x6a690407u,0x63620408u,0x76750409u,0x7574040au,0x6a69040bu,0x706f040cu,0x6f6e040du,0x100040eu,0x80000037u,0x76750410u,0x71700411u,0x6a690412u,0x6d6c0413u,0x6d6c0414u,0x62610415u,0x73720416u,0x7a790417u,0x45440418u,0x6a690419u,0x7473041au,0x7574041bu,0x6261041cu,0x6f6e041du,0x6463041eu,0x6665041fu,0x1000420u,0x80000038u,0x1000422u,0x80000039u,0x6564042du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610496u,0x6665042eu,0x7473042fu,0x64630430u,0x66650431u,0x6f6e0432u,0x64630433u,0x66650434u,0x55000435u,0x8000003au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f048au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6968048du,0x7372048bu,0x100048cu,0x8000003bu,0x6a69048eu,0x6463048fu,0x6c6b0490u,0x6f6e0491u,0x66650492u,0x74730493u,0x74730494u,0x1000495u,0x8000003cu,0x65640497u,0x6a690498u,0x62610499u,0x6f6e049au,0x6463049bu,0x6665049cu,0x100049du,0x8000003du,0x7a7904a7u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x686704acu,0x706f04a8u,0x767504a9u,0x757404aau,0x10004abu,0x8000003eu,0x696804adu,0x757404aeu,0x10004afu,0x8000003fu,0x757404bfu,0x0u,0x0u,0x0u,0x757404c6u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x757404cdu,0x666504c0u,0x737204c1u,0x6a6904c2u,0x626104c3u,0x6d6c04c4u,0x10004c5u,0x80000040u,0x626104c7u,0x6d6c04c8u,0x6d6c04c9u,0x6a6904cau,0x646304cbu,0x10004ccu,0x80000041u,0x6a6904ceu,0x706f04cfu,0x6f6e04d0u,0x2f2e04d1u,0x757204d2u,0x706f04d5u,0x646304ddu,0x737204e2u,0x757404d6u,0x626104d7u,0x757404d8u,0x6a6904d9u,0x706f04dau,0x6f6e04dbu,0x10004dcu,0x80000042u,0x626104deu,0x6d6c04dfu,0x666504e0u,0x10004e1u,0x80000043u,0x626104e3u,0x6f6e04e4u,0x747304e5u,0x6d6604e6u,0x706f04edu,0x0u,0x0u,0x0u,0x0u,0x0u,0x626104f1u,0x737204eeu,0x6e6d04efu,0x10004f0u,0x80000044u,0x757404f2u,0x6a6904f3u,0x706f04f4u,0x6f6e04f5u,0x10004f6u,0x80000045u,0x6e6d0506u,0x0u,0x0u,0x0u,0x62610509u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372050cu,0x66650507u,0x1000508u,0x80000046u,0x7372050au,0x100050bu,0x80000047u,0x6e6d050du,0x6261050eu,0x6d6c050fu,0x1000510u,0x80000048u,0x64630524u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6661052cu,0x0u,0x6a690540u,0x0u,0x0u,0x75740545u,0x6d6c0525u,0x76750526u,0x74730527u,0x6a690528u,0x706f0529u,0x6f6e052au,0x100052bu,0x80000049u,0x64630531u,0x0u,0x0u,0x0u,0x6f6e0536u,0x6a690532u,0x75740533u,0x7a790534u,0x1000535u,0x8000004au,0x6a690537u,0x6f6e0538u,0x68670539u,0x4241053au,0x6f6e053bu,0x6867053cu,0x6d6c053du,0x6665053eu,0x100053fu,0x8000004bu,0x68670541u,0x6a690542u,0x6f6e0543u,0x1000544u,0x8000004cu,0x554f0546u,0x6766054cu,0x0u,0x0u,0x0u,0x0u,0x73720552u,0x6766054du,0x7473054eu,0x6665054fu,0x75740550u,0x1000551u,0x8000004du,0x62610553u,0x6f6e0554u,0x74730555u,0x67660556u,0x706f0557u,0x73720558u,0x6e6d0559u,0x100055au,0x8000004eu,0x7873055fu,0x0u,0x0u,0x6a69056du,0x6a690564u,0x0u,0x0u,0x0u,0x6665056au,0x75740565u,0x6a690566u,0x706f0567u,0x6f6e0568u,0x1000569u,0x8000004fu,0x7372056bu,0x100056cu,0x80000050u,0x6e6d056eu,0x6a69056fu,0x75740570u,0x6a690571u,0x77760572u,0x66650573u,0x2f2e0574u,0x73610575u,0x75740587u,0x0u,0x706f0597u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f64059cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626105acu,0x75740588u,0x73720589u,0x6a69058au,0x6362058bu,0x7675058cu,0x7574058du,0x6665058eu,0x3430058fu,0x1000593u,0x1000594u,0x1000595u,0x1000596u,0x80000051u,0x80000052u,0x80000053u,0x80000054u,0x6d6c0598u,0x706f0599u,0x7372059au,0x100059bu,0x80000055u,0x10005a7u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x656405a8u,0x80000056u,0x666505a9u,0x797805aau,0x10005abu,0x80000057u,0x656405adu,0x6a6905aeu,0x767505afu,0x747305b0u,0x10005b1u,0x80000058u,0x656405c1u,0x0u,0x0u,0x0u,0x6f6705deu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x766c05f0u,0x6a6905c2u,0x766105c3u,0x6f6e05d8u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x747305dcu,0x646305d9u,0x666505dau,0x10005dbu,0x80000059u,0x10005ddu,0x8000005au,0x6a6905e6u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x656405eau,0x706f05e7u,0x6f6e05e8u,0x10005e9u,0x8000005bu,0x666505ebu,0x737205ecu,0x666505edu,0x737205eeu,0x10005efu,0x8000005cu,0x6d6c05fau,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x68670622u,0x6a6905fbu,0x6f6e05fcu,0x686705fdu,0x545305feu,0x696805ffu,0x76750600u,0x75740601u,0x75740602u,0x66650603u,0x73720604u,0x45440605u,0x76690606u,0x73720613u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372061bu,0x66650614u,0x64630615u,0x75740616u,0x6a690617u,0x706f0618u,0x6f6e0619u,0x100061au,0x8000005du,0x6261061cu,0x7574061du,0x6a69061eu,0x706f061fu,0x6f6e0620u,0x1000621u,0x8000005eu,0x69680623u,0x6f6e0624u,0x66650625u,0x74730626u,0x74730627u,0x1000628u,0x8000005fu,0x6261063cu,0x0u,0x0u,0x0u,0x0u,0x76650640u,0x7b640676u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x66610691u,0x0u,0x0u,0x0u,0x666106e9u,0x7372075fu,0x6d6c063du,0x6665063eu,0x100063fu,0x80000060u,0x66650651u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x75740671u,0x6f6e0652u,0x53430653u,0x706f0663u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0668u,0x6d6c0664u,0x706f0665u,0x73720666u,0x1000667u,0x80000061u,0x76750669u,0x6867066au,0x6968066bu,0x6f6e066cu,0x6665066du,0x7473066eu,0x7473066fu,0x1000670u,0x80000062u,0x75740672u,0x66650673u,0x73720674u,0x1000675u,0x80000063u,0x6665068du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6665068fu,0x100068eu,0x80000064u,0x1000690u,0x80000065u,0x64630696u,0x0u,0x0u,0x0u,0x6463069bu,0x6a690697u,0x6f6e0698u,0x68670699u,0x100069au,0x80000066u,0x7675069cu,0x6d6c069du,0x6261069eu,0x7372069fu,0x440006a0u,0x80000067u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f06e4u,0x6d6c06e5u,0x706f06e6u,0x737206e7u,0x10006e8u,0x80000068u,0x757406eeu,0x0u,0x0u,0x0u,0x73720757u,0x767506efu,0x747306f0u,0x444306f1u,0x626106f2u,0x6d6c06f3u,0x6d6c06f4u,0x636206f5u,0x626106f6u,0x646306f7u,0x6c6b06f8u,0x560006f9u,0x80000069u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7473074fu,0x66650750u,0x73720751u,0x45440752u,0x62610753u,0x75740754u,0x62610755u,0x1000756u,0x8000006au,0x66650758u,0x706f0759u,0x4e4d075au,0x706f075bu,0x6564075cu,0x6665075du,0x100075eu,0x8000006bu,0x67660760u,0x62610761u,0x64630762u,0x66650763u,0x1000764u,0x8000006cu,0x6a690770u,0x6e6d0778u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261077bu,0x64630771u,0x6c6b0772u,0x6f6e0773u,0x66650774u,0x74730775u,0x74730776u,0x1000777u,0x8000006du,0x66650779u,0x100077au,0x8000006eu,0x6f6e077cu,0x7473077du,0x6e66077eu,0x706f0786u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a69078au,0x73720787u,0x6e6d0788u,0x1000789u,0x8000006fu,0x7473078bu,0x7473078cu,0x6a69078du,0x706f078eu,0x6f6e078fu,0x1000790u,0x80000070u,0x6a690794u,0x0u,0x100079fu,0x75740795u,0x45440796u,0x6a690797u,0x74730798u,0x75740799u,0x6261079au,0x6f6e079bu,0x6463079cu,0x6665079du,0x100079eu,0x80000071u,0x80000072u,0x6d6c07afu,0x0u,0x0u,0x0u,0x7372080au,0x0u,0x0u,0x0u,0x74730863u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c0869u,0x767507b0u,0x666507b1u,0x530007b2u,0x80000073u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610805u,0x6f6e0806u,0x68670807u,0x66650808u,0x1000809u,0x80000074u,0x7574080bu,0x6665080cu,0x7978080du,0x2f2e080eu,0x7561080fu,0x75740823u,0x0u,0x70610833u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0848u,0x0u,0x706f084eu,0x0u,0x62610856u,0x0u,0x6261085cu,0x75740824u,0x73720825u,0x6a690826u,0x63620827u,0x76750828u,0x75740829u,0x6665082au,0x3430082bu,0x100082fu,0x1000830u,0x1000831u,0x1000832u,0x80000075u,0x80000076u,0x80000077u,0x80000078u,0x71700842u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c0844u,0x1000843u,0x80000079u,0x706f0845u,0x73720846u,0x1000847u,0x8000007au,0x73720849u,0x6e6d084au,0x6261084bu,0x6d6c084cu,0x100084du,0x8000007bu,0x7473084fu,0x6a690850u,0x75740851u,0x6a690852u,0x706f0853u,0x6f6e0854u,0x1000855u,0x8000007cu,0x65640857u,0x6a690858u,0x76750859u,0x7473085au,0x100085bu,0x8000007du,0x6f6e085du,0x6867085eu,0x6665085fu,0x6f6e0860u,0x75740861u,0x1000862u,0x8000007eu,0x6a690864u,0x63620865u,0x6d6c0866u,0x66650867u,0x1000868u,0x8000007fu,0x7675086au,0x6e6d086bu,0x6665086cu,0x5400086du,0x80000080u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626108c1u,0x6e6d08c2u,0x717008c3u,0x6d6c08c4u,0x666508c5u,0x535208c6u,0x626108c7u,0x757408c8u,0x666508c9u,0x474608cau,0x626108cbu,0x646308ccu,0x757408cdu,0x706f08ceu,0x737208cfu,0x10008d0u,0x80000081u,0x737208d5u,0x0u,0x0u,0x626108d9u,0x6d6c08d6u,0x656408d7u,0x10008d8u,0x80000082u,0x717008dau,0x4e4d08dbu,0x706f08dcu,0x656408ddu,0x666508deu,0x343108dfu,0x10008e2u,0x10008e3u,0x10008e4u,0x80000083u,0x80000084u,0x80000085u};
   uint32_t cur = 0x78610000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static int info_hash(const char *str) {
   static const uint32_t table[] = {0x69680014u,0x6665001bu,0x796c0038u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a610057u,0x0u,0x0u,0x6261006cu,0x0u,0x66650075u,0x706f007du,0x0u,0x7473008cu,0x6261008fu,0x62610015u,0x6f6e0016u,0x6f6e0017u,0x66650018u,0x6d6c0019u,0x100001au,0x8000000au,0x7466001cu,0x6261002au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6463002fu,0x7675002bu,0x6d6c002cu,0x7574002du,0x100002eu,0x80000001u,0x73720030u,0x6a690031u,0x71700032u,0x75740033u,0x6a690034u,0x706f0035u,0x6f6e0036u,0x1000037u,0x80000004u,0x66650045u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7574004fu,0x6e6d0046u,0x66650047u,0x6f6e0048u,0x75740049u,0x5554004au,0x7a79004bu,0x7170004cu,0x6665004du,0x100004eu,0x80000005u,0x66650050u,0x6f6e0051u,0x74730052u,0x6a690053u,0x706f0054u,0x6f6e0055u,0x1000056u,0x80000008u,0x79780060u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f6e0066u,0x6a690061u,0x6e6d0062u,0x76750063u,0x6e6d0064u,0x1000065u,0x80000003u,0x6a690067u,0x6e6d0068u,0x76750069u,0x6e6d006au,0x100006bu,0x80000002u,0x7372006du,0x6261006eu,0x6e6d006fu,0x66650070u,0x75740071u,0x66650072u,0x73720073u,0x1000074u,0x80000009u,0x72710076u,0x76750077u,0x6a690078u,0x73720079u,0x6665007au,0x6564007bu,0x100007cu,0x80000000u,0x7675007eu,0x7372007fu,0x64630080u,0x66650081u,0x46450082u,0x79780083u,0x75740084u,0x66650085u,0x6f6e0086u,0x74730087u,0x6a690088u,0x706f0089u,0x6f6e008au,0x100008bu,0x80000007u,0x6665008du,0x100008eu,0x8000000bu,0x6d6c0090u,0x76750091u,0x66650092u,0x1000093u,0x80000006u};
   uint32_t cur = 0x77630000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static const int32_t anari_true = 1;
static const int32_t anari_false = 0;
const char ** query_extensions() {
   static const char *extensions[] = {
      "ANARI_KHR_LIGHT_DIRECTIONAL",
      "ANARI_KHR_LIGHT_POINT",
      "ANARI_KHR_LIGHT_RING",
      "ANARI_KHR_LIGHT_QUAD",
      "ANARI_KHR_LIGHT_HDRI",
      "ANARI_KHR_CAMERA_SHUTTER",
      "ANARI_KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION",
      "ANARI_KHR_INSTANCE_MOTION_TRANSFORM",
      "ANARI_KHR_INSTANCE_TRANSFORM",
      "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
      "ANARI_KHR_AREA_LIGHTS",
      "ANARI_KHR_ARRAY1D_REGION",
      "ANARI_KHR_CAMERA_DEPTH_OF_FIELD",
      "ANARI_KHR_CAMERA_MOTION_TRANSFORMATION",
      "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
      "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
      "ANARI_KHR_CAMERA_PERSPECTIVE",
      "ANARI_KHR_CAMERA_STEREO",
      "ANARI_KHR_DEVICE_SYNCHRONIZATION",
      "ANARI_KHR_FRAME_ACCUMULATION",
      "ANARI_KHR_FRAME_CHANNEL_ALBEDO",
      "ANARI_KHR_FRAME_CHANNEL_INSTANCE_ID",
      "ANARI_KHR_FRAME_CHANNEL_NORMAL",
      "ANARI_KHR_FRAME_CHANNEL_OBJECT_ID",
      "ANARI_KHR_FRAME_CHANNEL_PRIMITIVE_ID",
      "ANARI_KHR_FRAME_COMPLETION_CALLBACK",
      "ANARI_KHR_GEOMETRY_CONE",
      "ANARI_KHR_GEOMETRY_CURVE",
      "ANARI_KHR_GEOMETRY_CYLINDER",
      "ANARI_KHR_GEOMETRY_QUAD",
      "ANARI_KHR_GEOMETRY_QUAD_MOTION_DEFORMATION",
      "ANARI_KHR_GEOMETRY_SPHERE",
      "ANARI_KHR_GEOMETRY_TRIANGLE",
      "ANARI_KHR_GEOMETRY_TRIANGLE_MOTION_DEFORMATION",
      "ANARI_KHR_LIGHT_SPOT",
      "ANARI_KHR_MATERIAL_MATTE",
      "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
      "ANARI_KHR_RENDERER_AMBIENT_LIGHT",
      "ANARI_KHR_RENDERER_BACKGROUND_COLOR",
      "ANARI_KHR_RENDERER_BACKGROUND_IMAGE",
      "ANARI_KHR_SAMPLER_IMAGE1D",
      "ANARI_KHR_SAMPLER_IMAGE2D",
      "ANARI_KHR_SAMPLER_IMAGE3D",
      "ANARI_KHR_SAMPLER_PRIMITIVE",
      "ANARI_KHR_SAMPLER_TRANSFORM",
      "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
      "ANARI_EXP_VOLUME_SAMPLE_RATE",
      0
   };
   return extensions;
}
const char ** query_object_types(ANARIDataType type) {
   switch(type) {
      case ANARI_LIGHT:
      {
         static const char *ANARI_LIGHT_subtypes[] = {"directional", "point", "ring", "quad", "hdri", "spot", 0};
         return ANARI_LIGHT_subtypes;
      }
      case ANARI_CAMERA:
      {
         static const char *ANARI_CAMERA_subtypes[] = {"default", "omnidirectional", "orthographic", "perspective", 0};
         return ANARI_CAMERA_subtypes;
      }
      case ANARI_RENDERER:
      {
         static const char *ANARI_RENDERER_subtypes[] = {"default", 0};
         return ANARI_RENDERER_subtypes;
      }
      case ANARI_INSTANCE:
      {
         static const char *ANARI_INSTANCE_subtypes[] = {"motionScaleRotationTranslation", "motionTransform", "transform", 0};
         return ANARI_INSTANCE_subtypes;
      }
      case ANARI_VOLUME:
      {
         static const char *ANARI_VOLUME_subtypes[] = {"transferFunction1D", 0};
         return ANARI_VOLUME_subtypes;
      }
      case ANARI_GEOMETRY:
      {
         static const char *ANARI_GEOMETRY_subtypes[] = {"cone", "curve", "cylinder", "quad", "sphere", "triangle", 0};
         return ANARI_GEOMETRY_subtypes;
      }
      case ANARI_MATERIAL:
      {
         static const char *ANARI_MATERIAL_subtypes[] = {"matte", "physicallyBased", 0};
         return ANARI_MATERIAL_subtypes;
      }
      case ANARI_SAMPLER:
      {
         static const char *ANARI_SAMPLER_subtypes[] = {"image1D", "image2D", "image3D", "primitive", "transform", 0};
         return ANARI_SAMPLER_subtypes;
      }
      case ANARI_SPATIAL_FIELD:
      {
         static const char *ANARI_SPATIAL_FIELD_subtypes[] = {"structuredRegular", 0};
         return ANARI_SPATIAL_FIELD_subtypes;
      }
      default:
      {
         static const char *none_subtypes[] = {0};
         return none_subtypes;
      }
   }
}
static const void * ANARI_LIGHT_directional_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_DIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 2: // minimum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 3: // maximum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "color of the light";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_DIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_irradiance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "amount of light in W/m^2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_DIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "emission direction of the light";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_DIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_angularDiameter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "apparent size of the light in radians";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_radiance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_visible_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "visibility of the light geometry";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_LIGHT_directional_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_LIGHT_directional_color_info(paramType, infoName, infoType);
      case 61:
         return ANARI_LIGHT_directional_irradiance_info(paramType, infoName, infoType);
      case 32:
         return ANARI_LIGHT_directional_direction_info(paramType, infoName, infoType);
      case 5:
         return ANARI_LIGHT_directional_angularDiameter_info(paramType, infoName, infoType);
      case 89:
         return ANARI_LIGHT_directional_radiance_info(paramType, infoName, infoType);
      case 127:
         return ANARI_LIGHT_directional_visible_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_point_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 2: // minimum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 3: // maximum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "color of the light";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "point";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "position of the light source";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_intensity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light emitted in a direction in W/sr";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_power_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light energy emitted in W";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "radius of the sphere light";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_radiance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_visible_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "visibility of the light geometry";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_LIGHT_point_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_LIGHT_point_color_info(paramType, infoName, infoType);
      case 79:
         return ANARI_LIGHT_point_position_info(paramType, infoName, infoType);
      case 54:
         return ANARI_LIGHT_point_intensity_info(paramType, infoName, infoType);
      case 80:
         return ANARI_LIGHT_point_power_info(paramType, infoName, infoType);
      case 90:
         return ANARI_LIGHT_point_radius_info(paramType, infoName, infoType);
      case 89:
         return ANARI_LIGHT_point_radiance_info(paramType, infoName, infoType);
      case 127:
         return ANARI_LIGHT_point_visible_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 2: // minimum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 3: // maximum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "color of the light";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "point";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "position of the light source";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "the axis the ring is pointing at";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_openingAngle_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {3.141593f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "opening angle in radians";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_falloffAngle_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.100000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "falloff angle in radians";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_intensity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light emitted in a direction in W/sr";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_power_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light energy emitted in W";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "outer radius of the ring";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_innerRadius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "inner radius of the ring";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_radiance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_intensityDistribution_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "luminous intensity distribution for photometric lights";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_c0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "direction of the C0-(half)plane";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_visible_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "visibility of the light geometry";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_LIGHT_ring_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_LIGHT_ring_color_info(paramType, infoName, infoType);
      case 79:
         return ANARI_LIGHT_ring_position_info(paramType, infoName, infoType);
      case 32:
         return ANARI_LIGHT_ring_direction_info(paramType, infoName, infoType);
      case 75:
         return ANARI_LIGHT_ring_openingAngle_info(paramType, infoName, infoType);
      case 36:
         return ANARI_LIGHT_ring_falloffAngle_info(paramType, infoName, infoType);
      case 54:
         return ANARI_LIGHT_ring_intensity_info(paramType, infoName, infoType);
      case 80:
         return ANARI_LIGHT_ring_power_info(paramType, infoName, infoType);
      case 90:
         return ANARI_LIGHT_ring_radius_info(paramType, infoName, infoType);
      case 52:
         return ANARI_LIGHT_ring_innerRadius_info(paramType, infoName, infoType);
      case 89:
         return ANARI_LIGHT_ring_radiance_info(paramType, infoName, infoType);
      case 55:
         return ANARI_LIGHT_ring_intensityDistribution_info(paramType, infoName, infoType);
      case 17:
         return ANARI_LIGHT_ring_c0_info(paramType, infoName, infoType);
      case 127:
         return ANARI_LIGHT_ring_visible_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 2: // minimum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 3: // maximum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "color of the light";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "point";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "position of the light source";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_edge1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "vector";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vector of the first edge";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_edge2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "vector";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vector of the second edge";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_intensity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light emitted in a direction in W/sr";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_power_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light energy emitted in W";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_radiance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_side_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "front";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "light emitting sides of the quad";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"front", "back", "both", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_intensityDistribution_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "luminous intensity distribution for photometric lights";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_visible_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "visibility of the light geometry";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_LIGHT_quad_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_LIGHT_quad_color_info(paramType, infoName, infoType);
      case 79:
         return ANARI_LIGHT_quad_position_info(paramType, infoName, infoType);
      case 33:
         return ANARI_LIGHT_quad_edge1_info(paramType, infoName, infoType);
      case 34:
         return ANARI_LIGHT_quad_edge2_info(paramType, infoName, infoType);
      case 54:
         return ANARI_LIGHT_quad_intensity_info(paramType, infoName, infoType);
      case 80:
         return ANARI_LIGHT_quad_power_info(paramType, infoName, infoType);
      case 89:
         return ANARI_LIGHT_quad_radiance_info(paramType, infoName, infoType);
      case 100:
         return ANARI_LIGHT_quad_side_info(paramType, infoName, infoType);
      case 55:
         return ANARI_LIGHT_quad_intensityDistribution_info(paramType, infoName, infoType);
      case 127:
         return ANARI_LIGHT_quad_visible_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_hdri_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_HDRI";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_hdri_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 2: // minimum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 3: // maximum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "color of the light";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_HDRI";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_hdri_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "up direction of the light in world space";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_HDRI";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_hdri_radiance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "the amount of light emitted by a point on the light source in a direction in W/sr/m^2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_HDRI";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_hdri_layout_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "equirectangular";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "radiance image layout";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"equirectangular", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_HDRI";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_hdri_scale_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "scale factor for radiance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_HDRI";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_hdri_visible_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "visibility of the light geometry";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_hdri_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_LIGHT_hdri_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_LIGHT_hdri_color_info(paramType, infoName, infoType);
      case 114:
         return ANARI_LIGHT_hdri_up_info(paramType, infoName, infoType);
      case 89:
         return ANARI_LIGHT_hdri_radiance_info(paramType, infoName, infoType);
      case 62:
         return ANARI_LIGHT_hdri_layout_info(paramType, infoName, infoType);
      case 96:
         return ANARI_LIGHT_hdri_scale_info(paramType, infoName, infoType);
      case 127:
         return ANARI_LIGHT_hdri_visible_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_default_shutter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
            static const float default_value[2] = {0.500000f, 0.500000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "start and end of shutter time";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_SHUTTER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_apertureRadius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aperture radius";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_DEPTH_OF_FIELD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 12;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_focusDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "focus distance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_DEPTH_OF_FIELD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 12;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_motion_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "world space transforms uniformly distributed in time";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_MOTION_TRANSFORMATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_motion_scale_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "scaling uniformly distributed in time";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_MOTION_TRANSFORMATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_motion_rotation_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "rotations uniformly distributed in time";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_QUAT_IJKW, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_MOTION_TRANSFORMATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_motion_translation_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "translations uniformly distributed in time";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_MOTION_TRANSFORMATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_time_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
            static const float default_value[2] = {0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "time associated with the first and laste entry in the motion.transform array";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_MOTION_TRANSFORMATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_rollingShutterDirection_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "rolling direction of the shutter";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "left", "right", "down", "up", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_SHUTTER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_rollingShutterDuration_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "open time per line";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_SHUTTER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_stereoMode_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "stereo mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "left", "right", "sideBySide", "topBottom", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_STEREO";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 17;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_interpupillaryDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.063500f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "interpupillary distance for stereo rendering";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_STEREO";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 17;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 99:
         return ANARI_CAMERA_default_shutter_info(paramType, infoName, infoType);
      case 6:
         return ANARI_CAMERA_default_apertureRadius_info(paramType, infoName, infoType);
      case 39:
         return ANARI_CAMERA_default_focusDistance_info(paramType, infoName, infoType);
      case 68:
         return ANARI_CAMERA_default_motion_transform_info(paramType, infoName, infoType);
      case 67:
         return ANARI_CAMERA_default_motion_scale_info(paramType, infoName, infoType);
      case 66:
         return ANARI_CAMERA_default_motion_rotation_info(paramType, infoName, infoType);
      case 69:
         return ANARI_CAMERA_default_motion_translation_info(paramType, infoName, infoType);
      case 110:
         return ANARI_CAMERA_default_time_info(paramType, infoName, infoType);
      case 93:
         return ANARI_CAMERA_default_rollingShutterDirection_info(paramType, infoName, infoType);
      case 94:
         return ANARI_CAMERA_default_rollingShutterDuration_info(paramType, infoName, infoType);
      case 107:
         return ANARI_CAMERA_default_stereoMode_info(paramType, infoName, infoType);
      case 56:
         return ANARI_CAMERA_default_interpupillaryDistance_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_DEVICE_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_statusCallback_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "callback used to report information to the application";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_statusCallbackUserData_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional pointer passed as the first argument of the status callback";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_DEVICE_name_info(paramType, infoName, infoType);
      case 105:
         return ANARI_DEVICE_statusCallback_info(paramType, infoName, infoType);
      case 106:
         return ANARI_DEVICE_statusCallbackUserData_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY1D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY1D_region_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "active region of the array";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_ARRAY1D_REGION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 11;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY1D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_ARRAY1D_name_info(paramType, infoName, infoType);
      case 91:
         return ANARI_ARRAY1D_region_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY2D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY2D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_ARRAY2D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY3D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY3D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_ARRAY3D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_FRAME_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_world_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "world to be rendererd";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_renderer_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "renderer which renders the frame";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_camera_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera used to render the world";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_size_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "size of the frame in pixels (width, height)";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the color channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8_VEC4, ANARI_UFIXED8_RGBA_SRGB, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_depth_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the color channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_accumulation_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enable device internal buffers for frame accumulation";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_ACCUMULATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 19;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_albedo_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the albedo channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8_VEC3, ANARI_UFIXED8_RGB_SRGB, ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_CHANNEL_ALBEDO";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 20;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_instanceId_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the instanceId channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_CHANNEL_INSTANCE_ID";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 21;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_normal_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the normal channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FIXED16_VEC3, ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_CHANNEL_NORMAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 22;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_objectId_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the objectId channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_CHANNEL_OBJECT_ID";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 23;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_primitiveId_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the primitiveId channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_CHANNEL_PRIMITIVE_ID";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 24;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_frameCompletionCallback_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "function called on frame render completion";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_COMPLETION_CALLBACK";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 25;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_frameCompletionCallbackUserData_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional pointer passed as the first argument of the frame continuation callback";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_COMPLETION_CALLBACK";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 25;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_FRAME_name_info(paramType, infoName, infoType);
      case 130:
         return ANARI_FRAME_world_info(paramType, infoName, infoType);
      case 92:
         return ANARI_FRAME_renderer_info(paramType, infoName, infoType);
      case 18:
         return ANARI_FRAME_camera_info(paramType, infoName, infoType);
      case 101:
         return ANARI_FRAME_size_info(paramType, infoName, infoType);
      case 21:
         return ANARI_FRAME_channel_color_info(paramType, infoName, infoType);
      case 22:
         return ANARI_FRAME_channel_depth_info(paramType, infoName, infoType);
      case 0:
         return ANARI_FRAME_accumulation_info(paramType, infoName, infoType);
      case 20:
         return ANARI_FRAME_channel_albedo_info(paramType, infoName, infoType);
      case 23:
         return ANARI_FRAME_channel_instanceId_info(paramType, infoName, infoType);
      case 24:
         return ANARI_FRAME_channel_normal_info(paramType, infoName, infoType);
      case 25:
         return ANARI_FRAME_channel_objectId_info(paramType, infoName, infoType);
      case 26:
         return ANARI_FRAME_channel_primitiveId_info(paramType, infoName, infoType);
      case 41:
         return ANARI_FRAME_frameCompletionCallback_info(paramType, infoName, infoType);
      case 42:
         return ANARI_FRAME_frameCompletionCallbackUserData_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GROUP_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_surface_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of surface objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_volume_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of volume objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_VOLUME, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_light_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of light objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_GROUP_name_info(paramType, infoName, infoType);
      case 108:
         return ANARI_GROUP_surface_info(paramType, infoName, infoType);
      case 128:
         return ANARI_GROUP_volume_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GROUP_light_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_WORLD_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_instance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of instance objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_INSTANCE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_surface_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced surface objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_volume_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced volume objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_light_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced light objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_WORLD_name_info(paramType, infoName, infoType);
      case 53:
         return ANARI_WORLD_instance_info(paramType, infoName, infoType);
      case 108:
         return ANARI_WORLD_surface_info(paramType, infoName, infoType);
      case 128:
         return ANARI_WORLD_volume_info(paramType, infoName, infoType);
      case 63:
         return ANARI_WORLD_light_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_default_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_ambientColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "ambient light color";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_RENDERER_AMBIENT_LIGHT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 37;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_ambientRadiance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "the amount of light emitted by a point on the ambient light source in a direction, in W/sr/m^2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_RENDERER_AMBIENT_LIGHT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 37;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_background_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "the background color";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_RENDERER_BACKGROUND_COLOR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 38;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_volumeSampleRateFactor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "Factor applied to volume sample rate";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "EXP_VOLUME_SAMPLE_RATE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 46;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_RENDERER_default_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_default_ambientColor_info(paramType, infoName, infoType);
      case 4:
         return ANARI_RENDERER_default_ambientRadiance_info(paramType, infoName, infoType);
      case 15:
         return ANARI_RENDERER_default_background_info(paramType, infoName, infoType);
      case 129:
         return ANARI_RENDERER_default_volumeSampleRateFactor_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SURFACE_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_geometry_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "geometry object defining the surface geometry";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_material_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "material object defining the surface appearance";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "user id for objectId channel";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_CHANNEL_OBJECT_ID";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 23;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_SURFACE_name_info(paramType, infoName, infoType);
      case 43:
         return ANARI_SURFACE_geometry_info(paramType, infoName, infoType);
      case 64:
         return ANARI_SURFACE_material_info(paramType, infoName, infoType);
      case 46:
         return ANARI_SURFACE_id_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionScaleRotationTranslation_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionScaleRotationTranslation_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to objects in the instance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionScaleRotationTranslation_group_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "group object being instanced";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionScaleRotationTranslation_motion_scale_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "scaling uniformly distributed in time";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionScaleRotationTranslation_motion_rotation_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "rotations uniformly distributed in time";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_QUAT_IJKW, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionScaleRotationTranslation_motion_translation_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "translations uniformly distributed in time";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionScaleRotationTranslation_time_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
            static const float default_value[2] = {0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "time associated with the first and laste entry in the motion.transform array";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionScaleRotationTranslation_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "user id for instanceId channel";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_CHANNEL_INSTANCE_ID";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 21;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionScaleRotationTranslation_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_INSTANCE_motionScaleRotationTranslation_name_info(paramType, infoName, infoType);
      case 111:
         return ANARI_INSTANCE_motionScaleRotationTranslation_transform_info(paramType, infoName, infoType);
      case 44:
         return ANARI_INSTANCE_motionScaleRotationTranslation_group_info(paramType, infoName, infoType);
      case 67:
         return ANARI_INSTANCE_motionScaleRotationTranslation_motion_scale_info(paramType, infoName, infoType);
      case 66:
         return ANARI_INSTANCE_motionScaleRotationTranslation_motion_rotation_info(paramType, infoName, infoType);
      case 69:
         return ANARI_INSTANCE_motionScaleRotationTranslation_motion_translation_info(paramType, infoName, infoType);
      case 110:
         return ANARI_INSTANCE_motionScaleRotationTranslation_time_info(paramType, infoName, infoType);
      case 46:
         return ANARI_INSTANCE_motionScaleRotationTranslation_id_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionTransform_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionTransform_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to objects in the instance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionTransform_group_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "group object being instanced";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionTransform_motion_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "world space transforms uniformly distributed in time";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionTransform_time_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
            static const float default_value[2] = {0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "time associated with the first and laste entry in the motion.transform array";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionTransform_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_INSTANCE_motionTransform_name_info(paramType, infoName, infoType);
      case 111:
         return ANARI_INSTANCE_motionTransform_transform_info(paramType, infoName, infoType);
      case 44:
         return ANARI_INSTANCE_motionTransform_group_info(paramType, infoName, infoType);
      case 68:
         return ANARI_INSTANCE_motionTransform_motion_transform_info(paramType, infoName, infoType);
      case 110:
         return ANARI_INSTANCE_motionTransform_time_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_INSTANCE_transform_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_transform_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to objects in the instance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_transform_group_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "group object being instanced";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_transform_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_INSTANCE_transform_name_info(paramType, infoName, infoType);
      case 111:
         return ANARI_INSTANCE_transform_transform_info(paramType, infoName, infoType);
      case 44:
         return ANARI_INSTANCE_transform_group_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_VOLUME_transferFunction1D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_transferFunction1D_value_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "spatial field used for the field values of the volume";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_transferFunction1D_valueRange_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
            static const float default_value[2] = {0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sampled values of field are clamped to this range";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_transferFunction1D_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sampled color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_transferFunction1D_opacity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sampled opacity";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_transferFunction1D_unitDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "makes volumes uniformly thinner or thicker";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_transferFunction1D_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "user id for objectId channel";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_FRAME_CHANNEL_OBJECT_ID";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 23;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_transferFunction1D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_VOLUME_transferFunction1D_name_info(paramType, infoName, infoType);
      case 115:
         return ANARI_VOLUME_transferFunction1D_value_info(paramType, infoName, infoType);
      case 116:
         return ANARI_VOLUME_transferFunction1D_valueRange_info(paramType, infoName, infoType);
      case 30:
         return ANARI_VOLUME_transferFunction1D_color_info(paramType, infoName, infoType);
      case 74:
         return ANARI_VOLUME_transferFunction1D_opacity_info(paramType, infoName, infoType);
      case 113:
         return ANARI_VOLUME_transferFunction1D_unitDistance_info(paramType, infoName, infoType);
      case 46:
         return ANARI_VOLUME_transferFunction1D_id_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_visible_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_BOOL && infoType == ANARI_BOOL) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "visibility of the light geometry";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_SPOT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 34;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 2: // minimum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 3: // maximum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "color of the light";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_SPOT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 34;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "point";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "position of the light source";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_SPOT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 34;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "the axis of the spot";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_SPOT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 34;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_openingAngle_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {3.141593f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "opening angle in radians";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_SPOT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 34;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_falloffAngle_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.100000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "falloff angle in radians";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_SPOT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 34;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_intensity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light emitted in a direction in W/sr";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_SPOT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 34;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_power_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light energy emitted in W";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_SPOT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 34;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 127:
         return ANARI_LIGHT_spot_visible_info(paramType, infoName, infoType);
      case 70:
         return ANARI_LIGHT_spot_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_LIGHT_spot_color_info(paramType, infoName, infoType);
      case 79:
         return ANARI_LIGHT_spot_position_info(paramType, infoName, infoType);
      case 32:
         return ANARI_LIGHT_spot_direction_info(paramType, infoName, infoType);
      case 75:
         return ANARI_LIGHT_spot_openingAngle_info(paramType, infoName, infoType);
      case 36:
         return ANARI_LIGHT_spot_falloffAngle_info(paramType, infoName, infoType);
      case 54:
         return ANARI_LIGHT_spot_intensity_info(paramType, infoName, infoType);
      case 80:
         return ANARI_LIGHT_spot_power_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_OMNIDIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 14;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "point";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera position";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_OMNIDIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 14;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "main viewing direction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_OMNIDIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 14;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera up direction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_OMNIDIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 14;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_imageRegion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "region mapped to the frame";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_OMNIDIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 14;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_layout_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "equirectangular";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "pixel layout";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"equirectangular", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_OMNIDIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 14;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_CAMERA_omnidirectional_name_info(paramType, infoName, infoType);
      case 79:
         return ANARI_CAMERA_omnidirectional_position_info(paramType, infoName, infoType);
      case 32:
         return ANARI_CAMERA_omnidirectional_direction_info(paramType, infoName, infoType);
      case 114:
         return ANARI_CAMERA_omnidirectional_up_info(paramType, infoName, infoType);
      case 48:
         return ANARI_CAMERA_omnidirectional_imageRegion_info(paramType, infoName, infoType);
      case 62:
         return ANARI_CAMERA_omnidirectional_layout_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "point";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera position";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "main viewing direction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera up direction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_imageRegion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "region mapped to the frame";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_aspect_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aspect ratio";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_height_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "height of image plane";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_near_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "near plane clip distance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_far_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "far plane clip distance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_CAMERA_orthographic_name_info(paramType, infoName, infoType);
      case 79:
         return ANARI_CAMERA_orthographic_position_info(paramType, infoName, infoType);
      case 32:
         return ANARI_CAMERA_orthographic_direction_info(paramType, infoName, infoType);
      case 114:
         return ANARI_CAMERA_orthographic_up_info(paramType, infoName, infoType);
      case 48:
         return ANARI_CAMERA_orthographic_imageRegion_info(paramType, infoName, infoType);
      case 8:
         return ANARI_CAMERA_orthographic_aspect_info(paramType, infoName, infoType);
      case 45:
         return ANARI_CAMERA_orthographic_height_info(paramType, infoName, infoType);
      case 71:
         return ANARI_CAMERA_orthographic_near_info(paramType, infoName, infoType);
      case 37:
         return ANARI_CAMERA_orthographic_far_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "point";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera position";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "main viewing direction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "direction";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera up direction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_imageRegion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "region mapped to the frame";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_fovy_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.047198f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertical field of view in radians";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_aspect_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aspect ratio";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_near_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "near plane clip distance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_far_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "far plane clip distance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_CAMERA_perspective_name_info(paramType, infoName, infoType);
      case 79:
         return ANARI_CAMERA_perspective_position_info(paramType, infoName, infoType);
      case 32:
         return ANARI_CAMERA_perspective_direction_info(paramType, infoName, infoType);
      case 114:
         return ANARI_CAMERA_perspective_up_info(paramType, infoName, infoType);
      case 48:
         return ANARI_CAMERA_perspective_imageRegion_info(paramType, infoName, infoType);
      case 40:
         return ANARI_CAMERA_perspective_fovy_info(paramType, infoName, infoType);
      case 8:
         return ANARI_CAMERA_perspective_aspect_info(paramType, infoName, infoType);
      case 71:
         return ANARI_CAMERA_perspective_near_info(paramType, infoName, infoType);
      case 37:
         return ANARI_CAMERA_perspective_far_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform color";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute0";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute1";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute3";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_cap_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex cap type";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_caps_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global cap type";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "first", "second", "both", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 26;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_GEOMETRY_cone_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_GEOMETRY_cone_color_info(paramType, infoName, infoType);
      case 11:
         return ANARI_GEOMETRY_cone_attribute0_info(paramType, infoName, infoType);
      case 12:
         return ANARI_GEOMETRY_cone_attribute1_info(paramType, infoName, infoType);
      case 13:
         return ANARI_GEOMETRY_cone_attribute2_info(paramType, infoName, infoType);
      case 14:
         return ANARI_GEOMETRY_cone_attribute3_info(paramType, infoName, infoType);
      case 85:
         return ANARI_GEOMETRY_cone_primitive_color_info(paramType, infoName, infoType);
      case 81:
         return ANARI_GEOMETRY_cone_primitive_attribute0_info(paramType, infoName, infoType);
      case 82:
         return ANARI_GEOMETRY_cone_primitive_attribute1_info(paramType, infoName, infoType);
      case 83:
         return ANARI_GEOMETRY_cone_primitive_attribute2_info(paramType, infoName, infoType);
      case 84:
         return ANARI_GEOMETRY_cone_primitive_attribute3_info(paramType, infoName, infoType);
      case 86:
         return ANARI_GEOMETRY_cone_primitive_id_info(paramType, infoName, infoType);
      case 124:
         return ANARI_GEOMETRY_cone_vertex_position_info(paramType, infoName, infoType);
      case 125:
         return ANARI_GEOMETRY_cone_vertex_radius_info(paramType, infoName, infoType);
      case 121:
         return ANARI_GEOMETRY_cone_vertex_cap_info(paramType, infoName, infoType);
      case 122:
         return ANARI_GEOMETRY_cone_vertex_color_info(paramType, infoName, infoType);
      case 117:
         return ANARI_GEOMETRY_cone_vertex_attribute0_info(paramType, infoName, infoType);
      case 118:
         return ANARI_GEOMETRY_cone_vertex_attribute1_info(paramType, infoName, infoType);
      case 119:
         return ANARI_GEOMETRY_cone_vertex_attribute2_info(paramType, infoName, infoType);
      case 120:
         return ANARI_GEOMETRY_cone_vertex_attribute3_info(paramType, infoName, infoType);
      case 87:
         return ANARI_GEOMETRY_cone_primitive_index_info(paramType, infoName, infoType);
      case 19:
         return ANARI_GEOMETRY_cone_caps_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform color";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute0";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute1";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute3";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global radius";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 27;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_GEOMETRY_curve_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_GEOMETRY_curve_color_info(paramType, infoName, infoType);
      case 11:
         return ANARI_GEOMETRY_curve_attribute0_info(paramType, infoName, infoType);
      case 12:
         return ANARI_GEOMETRY_curve_attribute1_info(paramType, infoName, infoType);
      case 13:
         return ANARI_GEOMETRY_curve_attribute2_info(paramType, infoName, infoType);
      case 14:
         return ANARI_GEOMETRY_curve_attribute3_info(paramType, infoName, infoType);
      case 85:
         return ANARI_GEOMETRY_curve_primitive_color_info(paramType, infoName, infoType);
      case 81:
         return ANARI_GEOMETRY_curve_primitive_attribute0_info(paramType, infoName, infoType);
      case 82:
         return ANARI_GEOMETRY_curve_primitive_attribute1_info(paramType, infoName, infoType);
      case 83:
         return ANARI_GEOMETRY_curve_primitive_attribute2_info(paramType, infoName, infoType);
      case 84:
         return ANARI_GEOMETRY_curve_primitive_attribute3_info(paramType, infoName, infoType);
      case 86:
         return ANARI_GEOMETRY_curve_primitive_id_info(paramType, infoName, infoType);
      case 124:
         return ANARI_GEOMETRY_curve_vertex_position_info(paramType, infoName, infoType);
      case 125:
         return ANARI_GEOMETRY_curve_vertex_radius_info(paramType, infoName, infoType);
      case 122:
         return ANARI_GEOMETRY_curve_vertex_color_info(paramType, infoName, infoType);
      case 117:
         return ANARI_GEOMETRY_curve_vertex_attribute0_info(paramType, infoName, infoType);
      case 118:
         return ANARI_GEOMETRY_curve_vertex_attribute1_info(paramType, infoName, infoType);
      case 119:
         return ANARI_GEOMETRY_curve_vertex_attribute2_info(paramType, infoName, infoType);
      case 120:
         return ANARI_GEOMETRY_curve_vertex_attribute3_info(paramType, infoName, infoType);
      case 87:
         return ANARI_GEOMETRY_curve_primitive_index_info(paramType, infoName, infoType);
      case 90:
         return ANARI_GEOMETRY_curve_radius_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform color";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute0";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute1";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute3";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_cap_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "cylinder cap type";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "cylinder radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global cylinder radius";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_caps_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global cylinder cap type";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "first", "second", "both", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 28;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_GEOMETRY_cylinder_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_GEOMETRY_cylinder_color_info(paramType, infoName, infoType);
      case 11:
         return ANARI_GEOMETRY_cylinder_attribute0_info(paramType, infoName, infoType);
      case 12:
         return ANARI_GEOMETRY_cylinder_attribute1_info(paramType, infoName, infoType);
      case 13:
         return ANARI_GEOMETRY_cylinder_attribute2_info(paramType, infoName, infoType);
      case 14:
         return ANARI_GEOMETRY_cylinder_attribute3_info(paramType, infoName, infoType);
      case 85:
         return ANARI_GEOMETRY_cylinder_primitive_color_info(paramType, infoName, infoType);
      case 81:
         return ANARI_GEOMETRY_cylinder_primitive_attribute0_info(paramType, infoName, infoType);
      case 82:
         return ANARI_GEOMETRY_cylinder_primitive_attribute1_info(paramType, infoName, infoType);
      case 83:
         return ANARI_GEOMETRY_cylinder_primitive_attribute2_info(paramType, infoName, infoType);
      case 84:
         return ANARI_GEOMETRY_cylinder_primitive_attribute3_info(paramType, infoName, infoType);
      case 86:
         return ANARI_GEOMETRY_cylinder_primitive_id_info(paramType, infoName, infoType);
      case 124:
         return ANARI_GEOMETRY_cylinder_vertex_position_info(paramType, infoName, infoType);
      case 121:
         return ANARI_GEOMETRY_cylinder_vertex_cap_info(paramType, infoName, infoType);
      case 122:
         return ANARI_GEOMETRY_cylinder_vertex_color_info(paramType, infoName, infoType);
      case 117:
         return ANARI_GEOMETRY_cylinder_vertex_attribute0_info(paramType, infoName, infoType);
      case 118:
         return ANARI_GEOMETRY_cylinder_vertex_attribute1_info(paramType, infoName, infoType);
      case 119:
         return ANARI_GEOMETRY_cylinder_vertex_attribute2_info(paramType, infoName, infoType);
      case 120:
         return ANARI_GEOMETRY_cylinder_vertex_attribute3_info(paramType, infoName, infoType);
      case 87:
         return ANARI_GEOMETRY_cylinder_primitive_index_info(paramType, infoName, infoType);
      case 88:
         return ANARI_GEOMETRY_cylinder_primitive_radius_info(paramType, infoName, infoType);
      case 90:
         return ANARI_GEOMETRY_cylinder_radius_info(paramType, infoName, infoType);
      case 19:
         return ANARI_GEOMETRY_cylinder_caps_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform color";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute0";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute1";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute3";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_normal_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_tangent_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_FLOAT32_VEC4, ANARI_FIXED16_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC4, ANARI_UINT64_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 29;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_time_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
            static const float default_value[2] = {0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "time associated with the first and laste entry in the motion.transform array";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD_MOTION_DEFORMATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 30;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_GEOMETRY_quad_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_GEOMETRY_quad_color_info(paramType, infoName, infoType);
      case 11:
         return ANARI_GEOMETRY_quad_attribute0_info(paramType, infoName, infoType);
      case 12:
         return ANARI_GEOMETRY_quad_attribute1_info(paramType, infoName, infoType);
      case 13:
         return ANARI_GEOMETRY_quad_attribute2_info(paramType, infoName, infoType);
      case 14:
         return ANARI_GEOMETRY_quad_attribute3_info(paramType, infoName, infoType);
      case 85:
         return ANARI_GEOMETRY_quad_primitive_color_info(paramType, infoName, infoType);
      case 81:
         return ANARI_GEOMETRY_quad_primitive_attribute0_info(paramType, infoName, infoType);
      case 82:
         return ANARI_GEOMETRY_quad_primitive_attribute1_info(paramType, infoName, infoType);
      case 83:
         return ANARI_GEOMETRY_quad_primitive_attribute2_info(paramType, infoName, infoType);
      case 84:
         return ANARI_GEOMETRY_quad_primitive_attribute3_info(paramType, infoName, infoType);
      case 86:
         return ANARI_GEOMETRY_quad_primitive_id_info(paramType, infoName, infoType);
      case 124:
         return ANARI_GEOMETRY_quad_vertex_position_info(paramType, infoName, infoType);
      case 123:
         return ANARI_GEOMETRY_quad_vertex_normal_info(paramType, infoName, infoType);
      case 126:
         return ANARI_GEOMETRY_quad_vertex_tangent_info(paramType, infoName, infoType);
      case 122:
         return ANARI_GEOMETRY_quad_vertex_color_info(paramType, infoName, infoType);
      case 117:
         return ANARI_GEOMETRY_quad_vertex_attribute0_info(paramType, infoName, infoType);
      case 118:
         return ANARI_GEOMETRY_quad_vertex_attribute1_info(paramType, infoName, infoType);
      case 119:
         return ANARI_GEOMETRY_quad_vertex_attribute2_info(paramType, infoName, infoType);
      case 120:
         return ANARI_GEOMETRY_quad_vertex_attribute3_info(paramType, infoName, infoType);
      case 87:
         return ANARI_GEOMETRY_quad_primitive_index_info(paramType, infoName, infoType);
      case 110:
         return ANARI_GEOMETRY_quad_time_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform color";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute0";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute1";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute3";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sphere position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sphere radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global sphere radius";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 31;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_GEOMETRY_sphere_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_GEOMETRY_sphere_color_info(paramType, infoName, infoType);
      case 11:
         return ANARI_GEOMETRY_sphere_attribute0_info(paramType, infoName, infoType);
      case 12:
         return ANARI_GEOMETRY_sphere_attribute1_info(paramType, infoName, infoType);
      case 13:
         return ANARI_GEOMETRY_sphere_attribute2_info(paramType, infoName, infoType);
      case 14:
         return ANARI_GEOMETRY_sphere_attribute3_info(paramType, infoName, infoType);
      case 85:
         return ANARI_GEOMETRY_sphere_primitive_color_info(paramType, infoName, infoType);
      case 81:
         return ANARI_GEOMETRY_sphere_primitive_attribute0_info(paramType, infoName, infoType);
      case 82:
         return ANARI_GEOMETRY_sphere_primitive_attribute1_info(paramType, infoName, infoType);
      case 83:
         return ANARI_GEOMETRY_sphere_primitive_attribute2_info(paramType, infoName, infoType);
      case 84:
         return ANARI_GEOMETRY_sphere_primitive_attribute3_info(paramType, infoName, infoType);
      case 86:
         return ANARI_GEOMETRY_sphere_primitive_id_info(paramType, infoName, infoType);
      case 124:
         return ANARI_GEOMETRY_sphere_vertex_position_info(paramType, infoName, infoType);
      case 125:
         return ANARI_GEOMETRY_sphere_vertex_radius_info(paramType, infoName, infoType);
      case 122:
         return ANARI_GEOMETRY_sphere_vertex_color_info(paramType, infoName, infoType);
      case 117:
         return ANARI_GEOMETRY_sphere_vertex_attribute0_info(paramType, infoName, infoType);
      case 118:
         return ANARI_GEOMETRY_sphere_vertex_attribute1_info(paramType, infoName, infoType);
      case 119:
         return ANARI_GEOMETRY_sphere_vertex_attribute2_info(paramType, infoName, infoType);
      case 120:
         return ANARI_GEOMETRY_sphere_vertex_attribute3_info(paramType, infoName, infoType);
      case 87:
         return ANARI_GEOMETRY_sphere_primitive_index_info(paramType, infoName, infoType);
      case 90:
         return ANARI_GEOMETRY_sphere_radius_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform color";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute0";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute1";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute2";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "uniform attribute3";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_normal_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_tangent_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_FLOAT32_VEC4, ANARI_FIXED16_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC3, ANARI_UINT64_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 32;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_time_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
            static const float default_value[2] = {0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "time associated with the first and laste entry in the motion.transform array";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE_MOTION_DEFORMATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 33;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_GEOMETRY_triangle_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_GEOMETRY_triangle_color_info(paramType, infoName, infoType);
      case 11:
         return ANARI_GEOMETRY_triangle_attribute0_info(paramType, infoName, infoType);
      case 12:
         return ANARI_GEOMETRY_triangle_attribute1_info(paramType, infoName, infoType);
      case 13:
         return ANARI_GEOMETRY_triangle_attribute2_info(paramType, infoName, infoType);
      case 14:
         return ANARI_GEOMETRY_triangle_attribute3_info(paramType, infoName, infoType);
      case 85:
         return ANARI_GEOMETRY_triangle_primitive_color_info(paramType, infoName, infoType);
      case 81:
         return ANARI_GEOMETRY_triangle_primitive_attribute0_info(paramType, infoName, infoType);
      case 82:
         return ANARI_GEOMETRY_triangle_primitive_attribute1_info(paramType, infoName, infoType);
      case 83:
         return ANARI_GEOMETRY_triangle_primitive_attribute2_info(paramType, infoName, infoType);
      case 84:
         return ANARI_GEOMETRY_triangle_primitive_attribute3_info(paramType, infoName, infoType);
      case 86:
         return ANARI_GEOMETRY_triangle_primitive_id_info(paramType, infoName, infoType);
      case 124:
         return ANARI_GEOMETRY_triangle_vertex_position_info(paramType, infoName, infoType);
      case 123:
         return ANARI_GEOMETRY_triangle_vertex_normal_info(paramType, infoName, infoType);
      case 126:
         return ANARI_GEOMETRY_triangle_vertex_tangent_info(paramType, infoName, infoType);
      case 122:
         return ANARI_GEOMETRY_triangle_vertex_color_info(paramType, infoName, infoType);
      case 117:
         return ANARI_GEOMETRY_triangle_vertex_attribute0_info(paramType, infoName, infoType);
      case 118:
         return ANARI_GEOMETRY_triangle_vertex_attribute1_info(paramType, infoName, infoType);
      case 119:
         return ANARI_GEOMETRY_triangle_vertex_attribute2_info(paramType, infoName, infoType);
      case 120:
         return ANARI_GEOMETRY_triangle_vertex_attribute3_info(paramType, infoName, infoType);
      case 87:
         return ANARI_GEOMETRY_triangle_primitive_index_info(paramType, infoName, infoType);
      case 110:
         return ANARI_GEOMETRY_triangle_time_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 35;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.800000f, 0.800000f, 0.800000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "diffuse color";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 35;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_opacity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "opacity";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 35;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_alphaMode_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "opaque";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "alpha mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"opaque", "blend", "mask", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 35;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_alphaCutoff_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.500000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "cutoff for alpha mask mode";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 35;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_MATERIAL_matte_name_info(paramType, infoName, infoType);
      case 30:
         return ANARI_MATERIAL_matte_color_info(paramType, infoName, infoType);
      case 74:
         return ANARI_MATERIAL_matte_opacity_info(paramType, infoName, infoType);
      case 2:
         return ANARI_MATERIAL_matte_alphaMode_info(paramType, infoName, infoType);
      case 1:
         return ANARI_MATERIAL_matte_alphaCutoff_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_baseColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "base color";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_opacity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "opacity";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_metallic_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "metallic factor";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_roughness_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "roughness factor";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_normal_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "normal map";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_emissive_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "emissive factor";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_occlusion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "precomputed occlusion";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_alphaMode_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "opaque";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "alpha mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"opaque", "blend", "mask", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_alphaCutoff_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.500000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "cutoff for alpha mask mode";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_specular_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "specular factor";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_specularColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "specular color";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_clearcoat_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "clearcoat factor";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_clearcoatRoughness_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "clearcoat roughness";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_clearcoatNormal_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "clearcoat normal map";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_transmission_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transmission factor";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_ior_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.500000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index of refraction";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_thickness_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wall thickness";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_attenuationDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {INFINITY};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "attenuation distance";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_attenuationColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "attenuation color";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_sheenColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 11: // use
         if(infoType == ANARI_STRING) {
            return "color";
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sheen color";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_sheenRoughness_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sheen roughness";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_iridescence_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "iridescence factor";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_iridescenceIor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.300000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "iridescence index of refraction";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_iridescenceThickness_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "iridescence thicknness";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 36;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_MATERIAL_physicallyBased_name_info(paramType, infoName, infoType);
      case 16:
         return ANARI_MATERIAL_physicallyBased_baseColor_info(paramType, infoName, infoType);
      case 74:
         return ANARI_MATERIAL_physicallyBased_opacity_info(paramType, infoName, infoType);
      case 65:
         return ANARI_MATERIAL_physicallyBased_metallic_info(paramType, infoName, infoType);
      case 95:
         return ANARI_MATERIAL_physicallyBased_roughness_info(paramType, infoName, infoType);
      case 72:
         return ANARI_MATERIAL_physicallyBased_normal_info(paramType, infoName, infoType);
      case 35:
         return ANARI_MATERIAL_physicallyBased_emissive_info(paramType, infoName, infoType);
      case 73:
         return ANARI_MATERIAL_physicallyBased_occlusion_info(paramType, infoName, infoType);
      case 2:
         return ANARI_MATERIAL_physicallyBased_alphaMode_info(paramType, infoName, infoType);
      case 1:
         return ANARI_MATERIAL_physicallyBased_alphaCutoff_info(paramType, infoName, infoType);
      case 103:
         return ANARI_MATERIAL_physicallyBased_specular_info(paramType, infoName, infoType);
      case 104:
         return ANARI_MATERIAL_physicallyBased_specularColor_info(paramType, infoName, infoType);
      case 27:
         return ANARI_MATERIAL_physicallyBased_clearcoat_info(paramType, infoName, infoType);
      case 29:
         return ANARI_MATERIAL_physicallyBased_clearcoatRoughness_info(paramType, infoName, infoType);
      case 28:
         return ANARI_MATERIAL_physicallyBased_clearcoatNormal_info(paramType, infoName, infoType);
      case 112:
         return ANARI_MATERIAL_physicallyBased_transmission_info(paramType, infoName, infoType);
      case 57:
         return ANARI_MATERIAL_physicallyBased_ior_info(paramType, infoName, infoType);
      case 109:
         return ANARI_MATERIAL_physicallyBased_thickness_info(paramType, infoName, infoType);
      case 10:
         return ANARI_MATERIAL_physicallyBased_attenuationDistance_info(paramType, infoName, infoType);
      case 9:
         return ANARI_MATERIAL_physicallyBased_attenuationColor_info(paramType, infoName, infoType);
      case 97:
         return ANARI_MATERIAL_physicallyBased_sheenColor_info(paramType, infoName, infoType);
      case 98:
         return ANARI_MATERIAL_physicallyBased_sheenRoughness_info(paramType, infoName, infoType);
      case 58:
         return ANARI_MATERIAL_physicallyBased_iridescence_info(paramType, infoName, infoType);
      case 59:
         return ANARI_MATERIAL_physicallyBased_iridescenceIor_info(paramType, infoName, infoType);
      case 60:
         return ANARI_MATERIAL_physicallyBased_iridescenceThickness_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 40;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_image_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array backing the sampler";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 40;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_inAttribute_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "input surface attribute (texture coordinate)";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 40;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_filter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "filter mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 40;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_wrapMode1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 1st dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 40;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_inTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the input attribute before sampling";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 40;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_inOffset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to output inTransform result";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 40;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_outTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the sampled values";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 40;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_outOffset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to output outTransform result";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 40;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_SAMPLER_image1D_name_info(paramType, infoName, infoType);
      case 47:
         return ANARI_SAMPLER_image1D_image_info(paramType, infoName, infoType);
      case 49:
         return ANARI_SAMPLER_image1D_inAttribute_info(paramType, infoName, infoType);
      case 38:
         return ANARI_SAMPLER_image1D_filter_info(paramType, infoName, infoType);
      case 131:
         return ANARI_SAMPLER_image1D_wrapMode1_info(paramType, infoName, infoType);
      case 51:
         return ANARI_SAMPLER_image1D_inTransform_info(paramType, infoName, infoType);
      case 50:
         return ANARI_SAMPLER_image1D_inOffset_info(paramType, infoName, infoType);
      case 78:
         return ANARI_SAMPLER_image1D_outTransform_info(paramType, infoName, infoType);
      case 77:
         return ANARI_SAMPLER_image1D_outOffset_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 41;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_image_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array backing the sampler";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 41;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_inAttribute_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "input surface attribute (texture coordinate)";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 41;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_filter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "filter mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 41;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_wrapMode1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 1st dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 41;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_wrapMode2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 2nd dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 41;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_inTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the input attribute before sampling";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 41;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_inOffset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to output inTransform result";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 41;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_outTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the sampled values";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 41;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_outOffset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to output outTransform result";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 41;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_SAMPLER_image2D_name_info(paramType, infoName, infoType);
      case 47:
         return ANARI_SAMPLER_image2D_image_info(paramType, infoName, infoType);
      case 49:
         return ANARI_SAMPLER_image2D_inAttribute_info(paramType, infoName, infoType);
      case 38:
         return ANARI_SAMPLER_image2D_filter_info(paramType, infoName, infoType);
      case 131:
         return ANARI_SAMPLER_image2D_wrapMode1_info(paramType, infoName, infoType);
      case 132:
         return ANARI_SAMPLER_image2D_wrapMode2_info(paramType, infoName, infoType);
      case 51:
         return ANARI_SAMPLER_image2D_inTransform_info(paramType, infoName, infoType);
      case 50:
         return ANARI_SAMPLER_image2D_inOffset_info(paramType, infoName, infoType);
      case 78:
         return ANARI_SAMPLER_image2D_outTransform_info(paramType, infoName, infoType);
      case 77:
         return ANARI_SAMPLER_image2D_outOffset_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_image_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array backing the sampler";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_inAttribute_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "input surface attribute (texture coordinate)";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_filter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "filter mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_wrapMode1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 1st dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_wrapMode2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 2nd dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_wrapMode3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 3rd dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_inTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the input attribute before sampling";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_inOffset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to output inTransform result";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_outTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the sampled values";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_outOffset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to output outTransform result";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 42;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_SAMPLER_image3D_name_info(paramType, infoName, infoType);
      case 47:
         return ANARI_SAMPLER_image3D_image_info(paramType, infoName, infoType);
      case 49:
         return ANARI_SAMPLER_image3D_inAttribute_info(paramType, infoName, infoType);
      case 38:
         return ANARI_SAMPLER_image3D_filter_info(paramType, infoName, infoType);
      case 131:
         return ANARI_SAMPLER_image3D_wrapMode1_info(paramType, infoName, infoType);
      case 132:
         return ANARI_SAMPLER_image3D_wrapMode2_info(paramType, infoName, infoType);
      case 133:
         return ANARI_SAMPLER_image3D_wrapMode3_info(paramType, infoName, infoType);
      case 51:
         return ANARI_SAMPLER_image3D_inTransform_info(paramType, infoName, infoType);
      case 50:
         return ANARI_SAMPLER_image3D_inOffset_info(paramType, infoName, infoType);
      case 78:
         return ANARI_SAMPLER_image3D_outTransform_info(paramType, infoName, infoType);
      case 77:
         return ANARI_SAMPLER_image3D_outOffset_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_PRIMITIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 43;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_array_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "backing array of the sampler";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_PRIMITIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 43;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_inOffset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_UINT64 && infoType == ANARI_UINT64) {
            static const uint64_t default_value[1] = {UINT64_C(0)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to primitiveId";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_PRIMITIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 43;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_SAMPLER_primitive_name_info(paramType, infoName, infoType);
      case 7:
         return ANARI_SAMPLER_primitive_array_info(paramType, infoName, infoType);
      case 50:
         return ANARI_SAMPLER_primitive_inOffset_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 44;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_inAttribute_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "input surface attribute (texture coordinate)";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 44;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_outTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the input attribute";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 44;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_outOffset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to output outTransform result";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 44;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_SAMPLER_transform_name_info(paramType, infoName, infoType);
      case 49:
         return ANARI_SAMPLER_transform_inAttribute_info(paramType, infoName, infoType);
      case 78:
         return ANARI_SAMPLER_transform_outTransform_info(paramType, infoName, infoType);
      case 77:
         return ANARI_SAMPLER_transform_outOffset_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 45;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_data_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of vertex centered scalar values";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT8, ANARI_INT16, ANARI_UINT16, ANARI_FLOAT32, ANARI_FLOAT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 45;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_origin_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "origin of the grid in object-space";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 45;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "size of the grid cells in object-space";
            return description;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 45;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_filter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "linear";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "filter mode used to interpolate the grid";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 45;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 70:
         return ANARI_SPATIAL_FIELD_structuredRegular_name_info(paramType, infoName, infoType);
      case 31:
         return ANARI_SPATIAL_FIELD_structuredRegular_data_info(paramType, infoName, infoType);
      case 76:
         return ANARI_SPATIAL_FIELD_structuredRegular_origin_info(paramType, infoName, infoType);
      case 102:
         return ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(paramType, infoName, infoType);
      case 38:
         return ANARI_SPATIAL_FIELD_structuredRegular_filter_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 3:
         return ANARI_CAMERA_default_param_info(paramName, paramType, infoName, infoType);
      case 12:
         return ANARI_CAMERA_omnidirectional_param_info(paramName, paramType, infoName, infoType);
      case 13:
         return ANARI_CAMERA_orthographic_param_info(paramName, paramType, infoName, infoType);
      case 14:
         return ANARI_CAMERA_perspective_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 0:
         return ANARI_GEOMETRY_cone_param_info(paramName, paramType, infoName, infoType);
      case 1:
         return ANARI_GEOMETRY_curve_param_info(paramName, paramType, infoName, infoType);
      case 2:
         return ANARI_GEOMETRY_cylinder_param_info(paramName, paramType, infoName, infoType);
      case 18:
         return ANARI_GEOMETRY_quad_param_info(paramName, paramType, infoName, infoType);
      case 20:
         return ANARI_GEOMETRY_sphere_param_info(paramName, paramType, infoName, infoType);
      case 25:
         return ANARI_GEOMETRY_triangle_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_INSTANCE_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 10:
         return ANARI_INSTANCE_motionScaleRotationTranslation_param_info(paramName, paramType, infoName, infoType);
      case 11:
         return ANARI_INSTANCE_motionTransform_param_info(paramName, paramType, infoName, infoType);
      case 24:
         return ANARI_INSTANCE_transform_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 4:
         return ANARI_LIGHT_directional_param_info(paramName, paramType, infoName, infoType);
      case 16:
         return ANARI_LIGHT_point_param_info(paramName, paramType, infoName, infoType);
      case 19:
         return ANARI_LIGHT_ring_param_info(paramName, paramType, infoName, infoType);
      case 18:
         return ANARI_LIGHT_quad_param_info(paramName, paramType, infoName, infoType);
      case 5:
         return ANARI_LIGHT_hdri_param_info(paramName, paramType, infoName, infoType);
      case 21:
         return ANARI_LIGHT_spot_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 9:
         return ANARI_MATERIAL_matte_param_info(paramName, paramType, infoName, infoType);
      case 15:
         return ANARI_MATERIAL_physicallyBased_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 3:
         return ANARI_RENDERER_default_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 6:
         return ANARI_SAMPLER_image1D_param_info(paramName, paramType, infoName, infoType);
      case 7:
         return ANARI_SAMPLER_image2D_param_info(paramName, paramType, infoName, infoType);
      case 8:
         return ANARI_SAMPLER_image3D_param_info(paramName, paramType, infoName, infoType);
      case 17:
         return ANARI_SAMPLER_primitive_param_info(paramName, paramType, infoName, infoType);
      case 24:
         return ANARI_SAMPLER_transform_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 22:
         return ANARI_SPATIAL_FIELD_structuredRegular_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_VOLUME_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 23:
         return ANARI_VOLUME_transferFunction1D_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_param_info_enum(ANARIDataType type, const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(type) {
      case ANARI_CAMERA:
         return ANARI_CAMERA_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_GEOMETRY:
         return ANARI_GEOMETRY_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_INSTANCE:
         return ANARI_INSTANCE_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_LIGHT:
         return ANARI_LIGHT_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_MATERIAL:
         return ANARI_MATERIAL_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_RENDERER:
         return ANARI_RENDERER_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_SAMPLER:
         return ANARI_SAMPLER_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_SPATIAL_FIELD:
         return ANARI_SPATIAL_FIELD_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_VOLUME:
         return ANARI_VOLUME_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_DEVICE:
         return ANARI_DEVICE_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY1D:
         return ANARI_ARRAY1D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY2D:
         return ANARI_ARRAY2D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY3D:
         return ANARI_ARRAY3D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_FRAME:
         return ANARI_FRAME_param_info(paramName, paramType, infoName, infoType);
      case ANARI_GROUP:
         return ANARI_GROUP_param_info(paramName, paramType, infoName, infoType);
      case ANARI_WORLD:
         return ANARI_WORLD_param_info(paramName, paramType, infoName, infoType);
      case ANARI_SURFACE:
         return ANARI_SURFACE_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_param_info(ANARIDataType type, const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoNameString, ANARIDataType infoType) {
   int infoName = info_hash(infoNameString);
   return query_param_info_enum(type, subtype, paramName, paramType, infoName, infoType);
}
static const void * ANARI_LIGHT_directional_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "directional light object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"irradiance", ANARI_FLOAT32},
               {"direction", ANARI_FLOAT32_VEC3},
               {"angularDiameter", ANARI_FLOAT32},
               {"radiance", ANARI_FLOAT32},
               {"visible", ANARI_BOOL},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_DIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 0;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "point light object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"position", ANARI_FLOAT32_VEC3},
               {"intensity", ANARI_FLOAT32},
               {"power", ANARI_FLOAT32},
               {"radius", ANARI_FLOAT32},
               {"radiance", ANARI_FLOAT32},
               {"visible", ANARI_BOOL},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_POINT";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_ring_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "ring light object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"openingAngle", ANARI_FLOAT32},
               {"falloffAngle", ANARI_FLOAT32},
               {"intensity", ANARI_FLOAT32},
               {"power", ANARI_FLOAT32},
               {"radius", ANARI_FLOAT32},
               {"innerRadius", ANARI_FLOAT32},
               {"radiance", ANARI_FLOAT32},
               {"intensityDistribution", ANARI_ARRAY1D},
               {"intensityDistribution", ANARI_ARRAY2D},
               {"c0", ANARI_FLOAT32_VEC3},
               {"visible", ANARI_BOOL},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_RING";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 2;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_quad_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "quad light object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"position", ANARI_FLOAT32_VEC3},
               {"edge1", ANARI_FLOAT32_VEC3},
               {"edge2", ANARI_FLOAT32_VEC3},
               {"intensity", ANARI_FLOAT32},
               {"power", ANARI_FLOAT32},
               {"radiance", ANARI_FLOAT32},
               {"side", ANARI_STRING},
               {"intensityDistribution", ANARI_ARRAY1D},
               {"intensityDistribution", ANARI_ARRAY2D},
               {"visible", ANARI_BOOL},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 3;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_hdri_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "hdri light object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"radiance", ANARI_ARRAY2D},
               {"layout", ANARI_STRING},
               {"scale", ANARI_FLOAT32},
               {"visible", ANARI_BOOL},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_LIGHT_HDRI";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 4;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_default_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"shutter", ANARI_FLOAT32_BOX1},
               {"apertureRadius", ANARI_FLOAT32},
               {"focusDistance", ANARI_FLOAT32},
               {"motion.transform", ANARI_ARRAY1D},
               {"motion.scale", ANARI_ARRAY1D},
               {"motion.rotation", ANARI_ARRAY1D},
               {"motion.translation", ANARI_ARRAY1D},
               {"time", ANARI_FLOAT32_BOX1},
               {"rollingShutterDirection", ANARI_STRING},
               {"rollingShutterDuration", ANARI_FLOAT32},
               {"stereoMode", ANARI_STRING},
               {"interpupillaryDistance", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_SHUTTER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 5;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "device object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"statusCallback", ANARI_STATUS_CALLBACK},
               {"statusCallbackUserData", ANARI_VOID_POINTER},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 8: // extension
         if(infoType == ANARI_STRING_LIST) {
            static const char *extensions[] = {
               "ANARI_KHR_LIGHT_DIRECTIONAL",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_LIGHT_RING",
               "ANARI_KHR_LIGHT_QUAD",
               "ANARI_KHR_LIGHT_HDRI",
               "ANARI_KHR_CAMERA_SHUTTER",
               "ANARI_KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION",
               "ANARI_KHR_INSTANCE_MOTION_TRANSFORM",
               "ANARI_KHR_INSTANCE_TRANSFORM",
               "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
               "ANARI_KHR_AREA_LIGHTS",
               "ANARI_KHR_ARRAY1D_REGION",
               "ANARI_KHR_CAMERA_DEPTH_OF_FIELD",
               "ANARI_KHR_CAMERA_MOTION_TRANSFORMATION",
               "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_CAMERA_STEREO",
               "ANARI_KHR_DEVICE_SYNCHRONIZATION",
               "ANARI_KHR_FRAME_ACCUMULATION",
               "ANARI_KHR_FRAME_CHANNEL_ALBEDO",
               "ANARI_KHR_FRAME_CHANNEL_INSTANCE_ID",
               "ANARI_KHR_FRAME_CHANNEL_NORMAL",
               "ANARI_KHR_FRAME_CHANNEL_OBJECT_ID",
               "ANARI_KHR_FRAME_CHANNEL_PRIMITIVE_ID",
               "ANARI_KHR_FRAME_COMPLETION_CALLBACK",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_QUAD_MOTION_DEFORMATION",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_GEOMETRY_TRIANGLE_MOTION_DEFORMATION",
               "ANARI_KHR_LIGHT_SPOT",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
               "ANARI_KHR_RENDERER_AMBIENT_LIGHT",
               "ANARI_KHR_RENDERER_BACKGROUND_COLOR",
               "ANARI_KHR_RENDERER_BACKGROUND_IMAGE",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SAMPLER_IMAGE2D",
               "ANARI_KHR_SAMPLER_IMAGE3D",
               "ANARI_KHR_SAMPLER_PRIMITIVE",
               "ANARI_KHR_SAMPLER_TRANSFORM",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               "ANARI_EXP_VOLUME_SAMPLE_RATE",
               0
            };
            return extensions;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY1D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "one dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"region", ANARI_UINT64_REGION1},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY2D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "two dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY3D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "three dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "frame object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"world", ANARI_WORLD},
               {"renderer", ANARI_RENDERER},
               {"camera", ANARI_CAMERA},
               {"size", ANARI_UINT32_VEC2},
               {"channel.color", ANARI_DATA_TYPE},
               {"channel.depth", ANARI_DATA_TYPE},
               {"accumulation", ANARI_BOOL},
               {"channel.albedo", ANARI_DATA_TYPE},
               {"channel.instanceId", ANARI_DATA_TYPE},
               {"channel.normal", ANARI_DATA_TYPE},
               {"channel.objectId", ANARI_DATA_TYPE},
               {"channel.primitiveId", ANARI_DATA_TYPE},
               {"frameCompletionCallback", ANARI_FRAME_COMPLETION_CALLBACK},
               {"frameCompletionCallbackUserData", ANARI_VOID_POINTER},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 10: // channel
         if(infoType == ANARI_STRING_LIST) {
            static const char *channel[] = {
               "channel.color",
               "channel.depth",
               "channel.albedo",
               "channel.instanceId",
               "channel.normal",
               "channel.objectId",
               "channel.primitiveId",
               0
            };
            return channel;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "group object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"surface", ANARI_ARRAY1D},
               {"volume", ANARI_ARRAY1D},
               {"light", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "world object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"instance", ANARI_ARRAY1D},
               {"surface", ANARI_ARRAY1D},
               {"volume", ANARI_ARRAY1D},
               {"light", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "default renderer";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"ambientColor", ANARI_FLOAT32_VEC3},
               {"ambientRadiance", ANARI_FLOAT32},
               {"background", ANARI_FLOAT32_VEC4},
               {"background", ANARI_ARRAY2D},
               {"volumeSampleRateFactor", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 8: // extension
         if(infoType == ANARI_STRING_LIST) {
            static const char *extensions[] = {
               "ANARI_KHR_LIGHT_DIRECTIONAL",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_LIGHT_RING",
               "ANARI_KHR_LIGHT_QUAD",
               "ANARI_KHR_LIGHT_HDRI",
               "ANARI_KHR_CAMERA_SHUTTER",
               "ANARI_KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION",
               "ANARI_KHR_INSTANCE_MOTION_TRANSFORM",
               "ANARI_KHR_INSTANCE_TRANSFORM",
               "ANARI_KHR_VOLUME_TRANSFER_FUNCTION1D",
               "ANARI_KHR_AREA_LIGHTS",
               "ANARI_KHR_ARRAY1D_REGION",
               "ANARI_KHR_CAMERA_DEPTH_OF_FIELD",
               "ANARI_KHR_CAMERA_MOTION_TRANSFORMATION",
               "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_CAMERA_STEREO",
               "ANARI_KHR_DEVICE_SYNCHRONIZATION",
               "ANARI_KHR_FRAME_ACCUMULATION",
               "ANARI_KHR_FRAME_CHANNEL_ALBEDO",
               "ANARI_KHR_FRAME_CHANNEL_INSTANCE_ID",
               "ANARI_KHR_FRAME_CHANNEL_NORMAL",
               "ANARI_KHR_FRAME_CHANNEL_OBJECT_ID",
               "ANARI_KHR_FRAME_CHANNEL_PRIMITIVE_ID",
               "ANARI_KHR_FRAME_COMPLETION_CALLBACK",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_QUAD_MOTION_DEFORMATION",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_GEOMETRY_TRIANGLE_MOTION_DEFORMATION",
               "ANARI_KHR_LIGHT_SPOT",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_MATERIAL_PHYSICALLY_BASED",
               "ANARI_KHR_RENDERER_AMBIENT_LIGHT",
               "ANARI_KHR_RENDERER_BACKGROUND_COLOR",
               "ANARI_KHR_RENDERER_BACKGROUND_IMAGE",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SAMPLER_IMAGE2D",
               "ANARI_KHR_SAMPLER_IMAGE3D",
               "ANARI_KHR_SAMPLER_PRIMITIVE",
               "ANARI_KHR_SAMPLER_TRANSFORM",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               "ANARI_EXP_VOLUME_SAMPLE_RATE",
               0
            };
            return extensions;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "surface object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"geometry", ANARI_GEOMETRY},
               {"material", ANARI_MATERIAL},
               {"id", ANARI_UINT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionScaleRotationTranslation_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "motion instance object with separate scale, rotation and translation";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"transform", ANARI_FLOAT32_MAT4},
               {"group", ANARI_GROUP},
               {"motion.scale", ANARI_ARRAY1D},
               {"motion.rotation", ANARI_ARRAY1D},
               {"motion.translation", ANARI_ARRAY1D},
               {"time", ANARI_FLOAT32_BOX1},
               {"id", ANARI_UINT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_SCALE_ROTATION_TRANSLATION";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 6;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_motionTransform_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "motion transform instance object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"transform", ANARI_FLOAT32_MAT4},
               {"group", ANARI_GROUP},
               {"motion.transform", ANARI_ARRAY1D},
               {"time", ANARI_FLOAT32_BOX1},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_MOTION_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 7;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_transform_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "instance object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"transform", ANARI_FLOAT32_MAT4},
               {"group", ANARI_GROUP},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_INSTANCE_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 8;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_transferFunction1D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "transferFunction1D volume object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"value", ANARI_SPATIAL_FIELD},
               {"valueRange", ANARI_FLOAT32_BOX1},
               {"valueRange", ANARI_FLOAT64_BOX1},
               {"color", ANARI_FLOAT32_VEC4},
               {"color", ANARI_FLOAT32_VEC3},
               {"color", ANARI_ARRAY1D},
               {"opacity", ANARI_FLOAT32},
               {"opacity", ANARI_ARRAY1D},
               {"unitDistance", ANARI_FLOAT32},
               {"id", ANARI_UINT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_VOLUME_TRANSFER_FUNCTION1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 9;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "spot light object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"visible", ANARI_BOOL},
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"openingAngle", ANARI_FLOAT32},
               {"falloffAngle", ANARI_FLOAT32},
               {"intensity", ANARI_FLOAT32},
               {"power", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_AREA_LIGHTS";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 10;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "omnidirectional camera object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"imageRegion", ANARI_FLOAT32_BOX2},
               {"layout", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_OMNIDIRECTIONAL";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 14;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "orthographic camera object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"imageRegion", ANARI_FLOAT32_BOX2},
               {"aspect", ANARI_FLOAT32},
               {"height", ANARI_FLOAT32},
               {"near", ANARI_FLOAT32},
               {"far", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_ORTHOGRAPHIC";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 15;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "perspective camera object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"imageRegion", ANARI_FLOAT32_BOX2},
               {"fovy", ANARI_FLOAT32},
               {"aspect", ANARI_FLOAT32},
               {"near", ANARI_FLOAT32},
               {"far", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_CAMERA_PERSPECTIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 16;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "cone geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC4},
               {"attribute0", ANARI_FLOAT32_VEC4},
               {"attribute1", ANARI_FLOAT32_VEC4},
               {"attribute2", ANARI_FLOAT32_VEC4},
               {"attribute3", ANARI_FLOAT32_VEC4},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.radius", ANARI_ARRAY1D},
               {"vertex.cap", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"caps", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CONE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 26;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "curve geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC4},
               {"attribute0", ANARI_FLOAT32_VEC4},
               {"attribute1", ANARI_FLOAT32_VEC4},
               {"attribute2", ANARI_FLOAT32_VEC4},
               {"attribute3", ANARI_FLOAT32_VEC4},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.radius", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"radius", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CURVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 27;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "cylinder geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC4},
               {"attribute0", ANARI_FLOAT32_VEC4},
               {"attribute1", ANARI_FLOAT32_VEC4},
               {"attribute2", ANARI_FLOAT32_VEC4},
               {"attribute3", ANARI_FLOAT32_VEC4},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.cap", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"primitive.radius", ANARI_ARRAY1D},
               {"radius", ANARI_FLOAT32},
               {"caps", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_CYLINDER";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 28;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "quad geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC4},
               {"attribute0", ANARI_FLOAT32_VEC4},
               {"attribute1", ANARI_FLOAT32_VEC4},
               {"attribute2", ANARI_FLOAT32_VEC4},
               {"attribute3", ANARI_FLOAT32_VEC4},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.normal", ANARI_ARRAY1D},
               {"vertex.normal", ANARI_ARRAY1D},
               {"vertex.tangent", ANARI_ARRAY1D},
               {"vertex.tangent", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"time", ANARI_FLOAT32_BOX1},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_QUAD";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 29;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "sphere geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC4},
               {"attribute0", ANARI_FLOAT32_VEC4},
               {"attribute1", ANARI_FLOAT32_VEC4},
               {"attribute2", ANARI_FLOAT32_VEC4},
               {"attribute3", ANARI_FLOAT32_VEC4},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.radius", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"radius", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_SPHERE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 31;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "triangle geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC4},
               {"attribute0", ANARI_FLOAT32_VEC4},
               {"attribute1", ANARI_FLOAT32_VEC4},
               {"attribute2", ANARI_FLOAT32_VEC4},
               {"attribute3", ANARI_FLOAT32_VEC4},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.normal", ANARI_ARRAY1D},
               {"vertex.normal", ANARI_ARRAY1D},
               {"vertex.tangent", ANARI_ARRAY1D},
               {"vertex.tangent", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"time", ANARI_FLOAT32_BOX1},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_GEOMETRY_TRIANGLE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 32;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "matte material object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"color", ANARI_SAMPLER},
               {"color", ANARI_STRING},
               {"opacity", ANARI_FLOAT32},
               {"opacity", ANARI_SAMPLER},
               {"opacity", ANARI_STRING},
               {"alphaMode", ANARI_STRING},
               {"alphaCutoff", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_MATTE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 35;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_physicallyBased_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "physically based material object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"baseColor", ANARI_FLOAT32_VEC3},
               {"baseColor", ANARI_SAMPLER},
               {"baseColor", ANARI_STRING},
               {"opacity", ANARI_FLOAT32},
               {"opacity", ANARI_SAMPLER},
               {"opacity", ANARI_STRING},
               {"metallic", ANARI_FLOAT32},
               {"metallic", ANARI_SAMPLER},
               {"metallic", ANARI_STRING},
               {"roughness", ANARI_FLOAT32},
               {"roughness", ANARI_SAMPLER},
               {"roughness", ANARI_STRING},
               {"normal", ANARI_SAMPLER},
               {"emissive", ANARI_FLOAT32_VEC3},
               {"emissive", ANARI_SAMPLER},
               {"emissive", ANARI_STRING},
               {"occlusion", ANARI_SAMPLER},
               {"alphaMode", ANARI_STRING},
               {"alphaCutoff", ANARI_FLOAT32},
               {"specular", ANARI_FLOAT32},
               {"specular", ANARI_SAMPLER},
               {"specular", ANARI_STRING},
               {"specularColor", ANARI_FLOAT32_VEC3},
               {"specularColor", ANARI_SAMPLER},
               {"specularColor", ANARI_STRING},
               {"clearcoat", ANARI_FLOAT32},
               {"clearcoat", ANARI_SAMPLER},
               {"clearcoat", ANARI_STRING},
               {"clearcoatRoughness", ANARI_FLOAT32},
               {"clearcoatRoughness", ANARI_SAMPLER},
               {"clearcoatRoughness", ANARI_STRING},
               {"clearcoatNormal", ANARI_SAMPLER},
               {"transmission", ANARI_FLOAT32},
               {"transmission", ANARI_SAMPLER},
               {"transmission", ANARI_STRING},
               {"ior", ANARI_FLOAT32},
               {"ior", ANARI_SAMPLER},
               {"ior", ANARI_STRING},
               {"thickness", ANARI_FLOAT32},
               {"thickness", ANARI_SAMPLER},
               {"thickness", ANARI_STRING},
               {"attenuationDistance", ANARI_FLOAT32},
               {"attenuationColor", ANARI_FLOAT32_VEC3},
               {"sheenColor", ANARI_FLOAT32_VEC3},
               {"sheenColor", ANARI_SAMPLER},
               {"sheenColor", ANARI_STRING},
               {"sheenRoughness", ANARI_FLOAT32},
               {"sheenRoughness", ANARI_SAMPLER},
               {"sheenRoughness", ANARI_STRING},
               {"iridescence", ANARI_FLOAT32},
               {"iridescence", ANARI_SAMPLER},
               {"iridescence", ANARI_STRING},
               {"iridescenceIor", ANARI_FLOAT32},
               {"iridescenceThickness", ANARI_FLOAT32},
               {"iridescenceThickness", ANARI_SAMPLER},
               {"iridescenceThickness", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_MATERIAL_PHYSICALLY_BASED";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 36;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "image1D object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"image", ANARI_ARRAY1D},
               {"inAttribute", ANARI_STRING},
               {"filter", ANARI_STRING},
               {"wrapMode1", ANARI_STRING},
               {"inTransform", ANARI_FLOAT32_MAT4},
               {"inOffset", ANARI_FLOAT32_VEC4},
               {"outTransform", ANARI_FLOAT32_MAT4},
               {"outOffset", ANARI_FLOAT32_VEC4},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE1D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 40;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "image2D object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"image", ANARI_ARRAY2D},
               {"inAttribute", ANARI_STRING},
               {"filter", ANARI_STRING},
               {"wrapMode1", ANARI_STRING},
               {"wrapMode2", ANARI_STRING},
               {"inTransform", ANARI_FLOAT32_MAT4},
               {"inOffset", ANARI_FLOAT32_VEC4},
               {"outTransform", ANARI_FLOAT32_MAT4},
               {"outOffset", ANARI_FLOAT32_VEC4},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE2D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 41;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "image3D object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"image", ANARI_ARRAY3D},
               {"inAttribute", ANARI_STRING},
               {"filter", ANARI_STRING},
               {"wrapMode1", ANARI_STRING},
               {"wrapMode2", ANARI_STRING},
               {"wrapMode3", ANARI_STRING},
               {"inTransform", ANARI_FLOAT32_MAT4},
               {"inOffset", ANARI_FLOAT32_VEC4},
               {"outTransform", ANARI_FLOAT32_MAT4},
               {"outOffset", ANARI_FLOAT32_VEC4},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_IMAGE3D";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 42;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "primitive sampler object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"array", ANARI_ARRAY1D},
               {"inOffset", ANARI_UINT64},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_PRIMITIVE";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 43;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "transform sampler object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"inAttribute", ANARI_STRING},
               {"outTransform", ANARI_FLOAT32_MAT4},
               {"outOffset", ANARI_FLOAT32_VEC4},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SAMPLER_TRANSFORM";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 44;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "structured regular spatial field object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"data", ANARI_ARRAY3D},
               {"origin", ANARI_FLOAT32_VEC3},
               {"spacing", ANARI_FLOAT32_VEC3},
               {"filter", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceExtension
         if(infoType == ANARI_STRING) {
            static const char *extension = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return extension;
         } else if(infoType == ANARI_INT32) {
            static const int value = 45;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 3:
         return ANARI_CAMERA_default_info(infoName, infoType);
      case 12:
         return ANARI_CAMERA_omnidirectional_info(infoName, infoType);
      case 13:
         return ANARI_CAMERA_orthographic_info(infoName, infoType);
      case 14:
         return ANARI_CAMERA_perspective_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 0:
         return ANARI_GEOMETRY_cone_info(infoName, infoType);
      case 1:
         return ANARI_GEOMETRY_curve_info(infoName, infoType);
      case 2:
         return ANARI_GEOMETRY_cylinder_info(infoName, infoType);
      case 18:
         return ANARI_GEOMETRY_quad_info(infoName, infoType);
      case 20:
         return ANARI_GEOMETRY_sphere_info(infoName, infoType);
      case 25:
         return ANARI_GEOMETRY_triangle_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_INSTANCE_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 10:
         return ANARI_INSTANCE_motionScaleRotationTranslation_info(infoName, infoType);
      case 11:
         return ANARI_INSTANCE_motionTransform_info(infoName, infoType);
      case 24:
         return ANARI_INSTANCE_transform_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 4:
         return ANARI_LIGHT_directional_info(infoName, infoType);
      case 16:
         return ANARI_LIGHT_point_info(infoName, infoType);
      case 19:
         return ANARI_LIGHT_ring_info(infoName, infoType);
      case 18:
         return ANARI_LIGHT_quad_info(infoName, infoType);
      case 5:
         return ANARI_LIGHT_hdri_info(infoName, infoType);
      case 21:
         return ANARI_LIGHT_spot_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 9:
         return ANARI_MATERIAL_matte_info(infoName, infoType);
      case 15:
         return ANARI_MATERIAL_physicallyBased_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 3:
         return ANARI_RENDERER_default_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 6:
         return ANARI_SAMPLER_image1D_info(infoName, infoType);
      case 7:
         return ANARI_SAMPLER_image2D_info(infoName, infoType);
      case 8:
         return ANARI_SAMPLER_image3D_info(infoName, infoType);
      case 17:
         return ANARI_SAMPLER_primitive_info(infoName, infoType);
      case 24:
         return ANARI_SAMPLER_transform_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 22:
         return ANARI_SPATIAL_FIELD_structuredRegular_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_VOLUME_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 23:
         return ANARI_VOLUME_transferFunction1D_info(infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_object_info_enum(ANARIDataType type, const char *subtype, int infoName, ANARIDataType infoType) {
   switch(type) {
      case ANARI_CAMERA:
         return ANARI_CAMERA_info(subtype, infoName, infoType);
      case ANARI_GEOMETRY:
         return ANARI_GEOMETRY_info(subtype, infoName, infoType);
      case ANARI_INSTANCE:
         return ANARI_INSTANCE_info(subtype, infoName, infoType);
      case ANARI_LIGHT:
         return ANARI_LIGHT_info(subtype, infoName, infoType);
      case ANARI_MATERIAL:
         return ANARI_MATERIAL_info(subtype, infoName, infoType);
      case ANARI_RENDERER:
         return ANARI_RENDERER_info(subtype, infoName, infoType);
      case ANARI_SAMPLER:
         return ANARI_SAMPLER_info(subtype, infoName, infoType);
      case ANARI_SPATIAL_FIELD:
         return ANARI_SPATIAL_FIELD_info(subtype, infoName, infoType);
      case ANARI_VOLUME:
         return ANARI_VOLUME_info(subtype, infoName, infoType);
      case ANARI_DEVICE:
         return ANARI_DEVICE_info(infoName, infoType);
      case ANARI_ARRAY1D:
         return ANARI_ARRAY1D_info(infoName, infoType);
      case ANARI_ARRAY2D:
         return ANARI_ARRAY2D_info(infoName, infoType);
      case ANARI_ARRAY3D:
         return ANARI_ARRAY3D_info(infoName, infoType);
      case ANARI_FRAME:
         return ANARI_FRAME_info(infoName, infoType);
      case ANARI_GROUP:
         return ANARI_GROUP_info(infoName, infoType);
      case ANARI_WORLD:
         return ANARI_WORLD_info(infoName, infoType);
      case ANARI_SURFACE:
         return ANARI_SURFACE_info(infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_object_info(ANARIDataType type, const char *subtype, const char *infoNameString, ANARIDataType infoType) {
   int infoName = info_hash(infoNameString);   return query_object_info_enum(type, subtype, infoName, infoType);}
}
