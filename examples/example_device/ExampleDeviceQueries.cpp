// Copyright 2021 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_queries.py
// Don't make changes to this directly

#include <anari/anari.h>
namespace anari {
namespace example_device {
static int subtype_hash(const char *str) {
   static const uint32_t table[] = {0x706f0014u,0x0u,0x7a6f0016u,0x6a65002fu,0x0u,0x0u,0x0u,0x0u,0x6e6d004bu,0x0u,0x0u,0x0u,0x62610058u,0x0u,0x736d005du,0x7361007cu,0x767500adu,0x626100b1u,0x756300dau,0x7372010fu,0x1000015u,0x80000000u,0x6f6e0021u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720024u,0x0u,0x0u,0x0u,0x6d6c0028u,0x66650022u,0x1000023u,0x80000001u,0x77760025u,0x66650026u,0x1000027u,0x80000002u,0x6a690029u,0x6f6e002au,0x6564002bu,0x6665002cu,0x7372002du,0x100002eu,0x80000003u,0x67620034u,0x0u,0x0u,0x0u,0x73720041u,0x76750039u,0x0u,0x0u,0x0u,0x6261003cu,0x6867003au,0x100003bu,0x80000004u,0x7675003du,0x6d6c003eu,0x7574003fu,0x1000040u,0x80000005u,0x66650042u,0x64630043u,0x75740044u,0x6a690045u,0x706f0046u,0x6f6e0047u,0x62610048u,0x6d6c0049u,0x100004au,0x80000006u,0x6261004cu,0x6867004du,0x6665004eu,0x3431004fu,0x45440052u,0x45440054u,0x45440056u,0x1000053u,0x80000007u,0x1000055u,0x80000008u,0x1000057u,0x80000009u,0x75740059u,0x7574005au,0x6665005bu,0x100005cu,0x8000000au,0x6f6e0063u,0x0u,0x0u,0x0u,0x0u,0x75740071u,0x6a690064u,0x65640065u,0x6a690066u,0x73720067u,0x66650068u,0x64630069u,0x7574006au,0x6a69006bu,0x706f006cu,0x6f6e006du,0x6261006eu,0x6d6c006fu,0x1000070u,0x8000000bu,0x69680072u,0x706f0073u,0x68670074u,0x73720075u,0x62610076u,0x71700077u,0x69680078u,0x6a690079u,0x6463007au,0x100007bu,0x8000000cu,0x7574008eu,0x0u,0x0u,0x0u,0x73720097u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a6900a1u,0x0u,0x0u,0x6a6900a5u,0x6968008fu,0x75740090u,0x73720091u,0x62610092u,0x64630093u,0x66650094u,0x73720095u,0x1000096u,0x8000000du,0x74730098u,0x71700099u,0x6665009au,0x6463009bu,0x7574009cu,0x6a69009du,0x7776009eu,0x6665009fu,0x10000a0u,0x8000000eu,0x6f6e00a2u,0x757400a3u,0x10000a4u,0x8000000fu,0x6e6d00a6u,0x6a6900a7u,0x757400a8u,0x6a6900a9u,0x777600aau,0x666500abu,0x10000acu,0x80000010u,0x626100aeu,0x656400afu,0x10000b0u,0x80000011u,0x7a7900b2u,0x644400b3u,0x6a6900d3u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100d6u,0x737200d4u,0x10000d5u,0x80000012u,0x747300d7u,0x757400d8u,0x10000d9u,0x80000013u,0x6a6900ecu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706800f1u,0x0u,0x0u,0x0u,0x737200ffu,0x777600edu,0x6a6900eeu,0x747300efu,0x10000f0u,0x80000014u,0x666500f9u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x757400fdu,0x737200fau,0x666500fbu,0x10000fcu,0x80000015u,0x10000feu,0x80000016u,0x76750100u,0x64630101u,0x75740102u,0x76750103u,0x73720104u,0x66650105u,0x65640106u,0x53520107u,0x66650108u,0x68670109u,0x7675010au,0x6d6c010bu,0x6261010cu,0x7372010du,0x100010eu,0x80000017u,0x6a610110u,0x6f6e0119u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610135u,0x7473011au,0x7166011bu,0x706f0126u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261012au,0x73720127u,0x6e6d0128u,0x1000129u,0x80000018u,0x7372012bu,0x6665012cu,0x6f6e012du,0x7574012eu,0x4e4d012fu,0x62610130u,0x75740131u,0x75740132u,0x66650133u,0x1000134u,0x80000019u,0x6f6e0136u,0x68670137u,0x6d6c0138u,0x66650139u,0x100013au,0x8000001au};
   uint32_t cur = 0x75610000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static int param_hash(const char *str) {
   static const uint32_t table[] = {0x74700017u,0x62610031u,0x70610040u,0x6a610094u,0x0u,0x706100b8u,0x73650102u,0x0u,0x736d011bu,0x0u,0x0u,0x6a6101eeu,0x62610200u,0x62610208u,0x7670020cu,0x7369026du,0x0u,0x666102d5u,0x766902e6u,0x73720378u,0x71700381u,0x70610383u,0x736f03f0u,0x6665001bu,0x0u,0x73720028u,0x7170002cu,0x7372001cu,0x7574001du,0x7675001eu,0x7372001fu,0x66650020u,0x53520021u,0x62610022u,0x65640023u,0x6a690024u,0x76750025u,0x74730026u,0x1000027u,0x80000000u,0x62610029u,0x7a79002au,0x100002bu,0x80000001u,0x6665002du,0x6463002eu,0x7574002fu,0x1000030u,0x80000002u,0x64630032u,0x6c6b0033u,0x68670034u,0x73720035u,0x706f0036u,0x76750037u,0x6f6e0038u,0x65640039u,0x4443003au,0x706f003bu,0x6d6c003cu,0x706f003du,0x7372003eu,0x100003fu,0x80000003u,0x716d004fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c0059u,0x66650053u,0x0u,0x0u,0x74730057u,0x73720054u,0x62610055u,0x1000056u,0x80000004u,0x1000058u,0x80000005u,0x706f005au,0x7372005bu,0x2f00005cu,0x80000006u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7170008bu,0x706f008cu,0x7473008du,0x6a69008eu,0x7574008fu,0x6a690090u,0x706f0091u,0x6f6e0092u,0x1000093u,0x80000007u,0x7574009du,0x0u,0x0u,0x0u,0x716e00a0u,0x0u,0x0u,0x0u,0x737200b0u,0x6261009eu,0x100009fu,0x80000008u,0x747300a3u,0x0u,0x757400adu,0x6a6900a4u,0x757400a5u,0x7a7900a6u,0x545300a7u,0x646300a8u,0x626100a9u,0x6d6c00aau,0x666500abu,0x10000acu,0x80000009u,0x696800aeu,0x10000afu,0x8000000au,0x666500b1u,0x646300b2u,0x757400b3u,0x6a6900b4u,0x706f00b5u,0x6f6e00b6u,0x10000b7u,0x8000000bu,0x6d6c00c7u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6500d2u,0x0u,0x0u,0x0u,0x0u,0x0u,0x776300e1u,0x6d6c00c8u,0x706f00c9u,0x676600cau,0x676600cbu,0x424100ccu,0x6f6e00cdu,0x686700ceu,0x6d6c00cfu,0x666500d0u,0x10000d1u,0x8000000cu,0x6d6c00dau,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x757400ddu,0x656400dbu,0x10000dcu,0x8000000du,0x666500deu,0x737200dfu,0x10000e0u,0x8000000eu,0x767500f5u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7a790100u,0x747300f6u,0x454400f7u,0x6a6900f8u,0x747300f9u,0x757400fau,0x626100fbu,0x6f6e00fcu,0x646300fdu,0x666500feu,0x10000ffu,0x8000000fu,0x1000101u,0x80000010u,0x706f0110u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0117u,0x6e6d0111u,0x66650112u,0x75740113u,0x73720114u,0x7a790115u,0x1000116u,0x80000011u,0x76750118u,0x71700119u,0x100011au,0x80000012u,0x62610121u,0x7541017du,0x0u,0x0u,0x0u,0x737201e6u,0x68670122u,0x66650123u,0x53000124u,0x80000013u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x66650177u,0x68670178u,0x6a690179u,0x706f017au,0x6f6e017bu,0x100017cu,0x80000014u,0x757401b1u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x737201bau,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x757401c3u,0x666501c9u,0x757401b2u,0x737201b3u,0x6a6901b4u,0x636201b5u,0x767501b6u,0x757401b7u,0x666501b8u,0x10001b9u,0x80000015u,0x626101bbu,0x6f6e01bcu,0x747301bdu,0x676601beu,0x706f01bfu,0x737201c0u,0x6e6d01c1u,0x10001c2u,0x80000016u,0x626101c4u,0x6f6e01c5u,0x646301c6u,0x666501c7u,0x10001c8u,0x80000017u,0x736e01cau,0x747301cfu,0x0u,0x0u,0x0u,0x717001d4u,0x6a6901d0u,0x757401d1u,0x7a7901d2u,0x10001d3u,0x80000018u,0x767501d5u,0x717001d6u,0x6a6901d7u,0x6d6c01d8u,0x6d6c01d9u,0x626101dau,0x737201dbu,0x7a7901dcu,0x454401ddu,0x6a6901deu,0x747301dfu,0x757401e0u,0x626101e1u,0x6f6e01e2u,0x646301e3u,0x666501e4u,0x10001e5u,0x80000019u,0x6a6901e7u,0x656401e8u,0x626101e9u,0x6f6e01eau,0x646301ebu,0x666501ecu,0x10001edu,0x8000001au,0x7a7901f7u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x686701fcu,0x706f01f8u,0x767501f9u,0x757401fau,0x10001fbu,0x8000001bu,0x696801fdu,0x757401feu,0x10001ffu,0x8000001cu,0x75740201u,0x66650202u,0x73720203u,0x6a690204u,0x62610205u,0x6d6c0206u,0x1000207u,0x8000001du,0x6e6d0209u,0x6665020au,0x100020bu,0x8000001eu,0x66610212u,0x0u,0x6a69025du,0x0u,0x0u,0x75740262u,0x64630217u,0x0u,0x0u,0x0u,0x6f6e0253u,0x6a690218u,0x75740219u,0x7a79021au,0x2f00021bu,0x8000001fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7170024au,0x706f024bu,0x7473024cu,0x6a69024du,0x7574024eu,0x6a69024fu,0x706f0250u,0x6f6e0251u,0x1000252u,0x80000020u,0x6a690254u,0x6f6e0255u,0x68670256u,0x42410257u,0x6f6e0258u,0x68670259u,0x6d6c025au,0x6665025bu,0x100025cu,0x80000021u,0x6867025eu,0x6a69025fu,0x6f6e0260u,0x1000261u,0x80000022u,0x55540263u,0x73720264u,0x62610265u,0x6f6e0266u,0x74730267u,0x67660268u,0x706f0269u,0x7372026au,0x6e6d026bu,0x100026cu,0x80000023u,0x79780277u,0x0u,0x0u,0x0u,0x0u,0x0u,0x78730282u,0x0u,0x0u,0x6a690290u,0x66650278u,0x6d6c0279u,0x5453027au,0x6261027bu,0x6e6d027cu,0x7170027du,0x6d6c027eu,0x6665027fu,0x74730280u,0x1000281u,0x80000024u,0x6a690287u,0x0u,0x0u,0x0u,0x6665028du,0x75740288u,0x6a690289u,0x706f028au,0x6f6e028bu,0x100028cu,0x80000025u,0x7372028eu,0x100028fu,0x80000026u,0x6e6d0291u,0x6a690292u,0x75740293u,0x6a690294u,0x77760295u,0x66650296u,0x2f2e0297u,0x73610298u,0x757402aau,0x0u,0x706f02bau,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f6402bfu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626102cfu,0x757402abu,0x737202acu,0x6a6902adu,0x636202aeu,0x767502afu,0x757402b0u,0x666502b1u,0x343002b2u,0x10002b6u,0x10002b7u,0x10002b8u,0x10002b9u,0x80000027u,0x80000028u,0x80000029u,0x8000002au,0x6d6c02bbu,0x706f02bcu,0x737202bdu,0x10002beu,0x8000002bu,0x10002cau,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x656402cbu,0x8000002cu,0x666502ccu,0x797802cdu,0x10002ceu,0x8000002du,0x656402d0u,0x6a6902d1u,0x767502d2u,0x747302d3u,0x10002d4u,0x8000002eu,0x656402dau,0x0u,0x0u,0x0u,0x6f6e02dfu,0x6a6902dbu,0x767502dcu,0x747302ddu,0x10002deu,0x8000002fu,0x656402e0u,0x666502e1u,0x737202e2u,0x666502e3u,0x737202e4u,0x10002e5u,0x80000030u,0x7b7a02f3u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626102f6u,0x0u,0x0u,0x0u,0x666102fcu,0x73720372u,0x666502f4u,0x10002f5u,0x80000031u,0x646302f7u,0x6a6902f8u,0x6f6e02f9u,0x686702fau,0x10002fbu,0x80000032u,0x75740301u,0x0u,0x0u,0x0u,0x7372036au,0x76750302u,0x74730303u,0x44430304u,0x62610305u,0x6d6c0306u,0x6d6c0307u,0x63620308u,0x62610309u,0x6463030au,0x6c6b030bu,0x5600030cu,0x80000033u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x74730362u,0x66650363u,0x73720364u,0x45440365u,0x62610366u,0x75740367u,0x62610368u,0x1000369u,0x80000034u,0x6665036bu,0x706f036cu,0x4e4d036du,0x706f036eu,0x6564036fu,0x66650370u,0x1000371u,0x80000035u,0x67660373u,0x62610374u,0x64630375u,0x66650376u,0x1000377u,0x80000036u,0x62610379u,0x6f6e037au,0x7473037bu,0x6766037cu,0x706f037du,0x7372037eu,0x6e6d037fu,0x1000380u,0x80000037u,0x1000382u,0x80000038u,0x6d6c0392u,0x0u,0x0u,0x0u,0x7372039bu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c03ebu,0x76750393u,0x66650394u,0x53520395u,0x62610396u,0x6f6e0397u,0x68670398u,0x66650399u,0x100039au,0x80000039u,0x7574039cu,0x6665039du,0x7978039eu,0x2f2e039fu,0x736103a0u,0x757403b2u,0x0u,0x706103c2u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f03d7u,0x0u,0x706f03ddu,0x0u,0x626103e5u,0x757403b3u,0x737203b4u,0x6a6903b5u,0x636203b6u,0x767503b7u,0x757403b8u,0x666503b9u,0x343003bau,0x10003beu,0x10003bfu,0x10003c0u,0x10003c1u,0x8000003au,0x8000003bu,0x8000003cu,0x8000003du,0x717003d1u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c03d3u,0x10003d2u,0x8000003eu,0x706f03d4u,0x737203d5u,0x10003d6u,0x8000003fu,0x737203d8u,0x6e6d03d9u,0x626103dau,0x6d6c03dbu,0x10003dcu,0x80000040u,0x747303deu,0x6a6903dfu,0x757403e0u,0x6a6903e1u,0x706f03e2u,0x6f6e03e3u,0x10003e4u,0x80000041u,0x656403e6u,0x6a6903e7u,0x767503e8u,0x747303e9u,0x10003eau,0x80000042u,0x767503ecu,0x6e6d03edu,0x666503eeu,0x10003efu,0x80000043u,0x737203f4u,0x0u,0x0u,0x626103f8u,0x6d6c03f5u,0x656403f6u,0x10003f7u,0x80000044u,0x717003f9u,0x4e4d03fau,0x706f03fbu,0x656403fcu,0x666503fdu,0x343103feu,0x1000401u,0x1000402u,0x1000403u,0x80000045u,0x80000046u,0x80000047u};
   uint32_t cur = 0x78610000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
const char ** query_extensions() {
   static const char *features[] = {
      "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
      "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
      "ANARI_KHR_CAMERA_PERSPECTIVE",
      "ANARI_KHR_GEOMETRY_CONE",
      "ANARI_KHR_GEOMETRY_CURVE",
      "ANARI_KHR_GEOMETRY_CYLINDER",
      "ANARI_KHR_GEOMETRY_QUAD",
      "ANARI_KHR_GEOMETRY_SPHERE",
      "ANARI_KHR_GEOMETRY_TRIANGLE",
      "ANARI_KHR_LIGHT_DIRECTIONAL",
      "ANARI_KHR_LIGHT_POINT",
      "ANARI_KHR_LIGHT_SPOT",
      "ANARI_KHR_MATERIAL_MATTE",
      "ANARI_KHR_MATERIAL_TRANSPARENT_MATTE",
      "ANARI_KHR_SAMPLER_IMAGE1D",
      "ANARI_KHR_SAMPLER_IMAGE2D",
      "ANARI_KHR_SAMPLER_IMAGE3D",
      "ANARI_KHR_SAMPLER_PRIMITIVE",
      "ANARI_KHR_SAMPLER_TRANSFORM",
      "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
      "ANARI_KHR_VOLUME_SCIVIS",
      "ANARI_KHR_FRAME_CONTINUATION",
      0
   };
   return features;
}
const char ** query_object_types(ANARIDataType type) {
   switch(type) {
      case ANARI_RENDERER:
      {
         static const char *ANARI_RENDERER_subtypes[] = {"default", "scivis", "ao", "pathtracer", "debug", "raycast", "rayDir", 0};
         return ANARI_RENDERER_subtypes;
      }
      case ANARI_CAMERA:
      {
         static const char *ANARI_CAMERA_subtypes[] = {"omnidirectional", "orthographic", "perspective", 0};
         return ANARI_CAMERA_subtypes;
      }
      case ANARI_GEOMETRY:
      {
         static const char *ANARI_GEOMETRY_subtypes[] = {"cone", "curve", "cylinder", "quad", "sphere", "triangle", 0};
         return ANARI_GEOMETRY_subtypes;
      }
      case ANARI_LIGHT:
      {
         static const char *ANARI_LIGHT_subtypes[] = {"directional", "point", "spot", 0};
         return ANARI_LIGHT_subtypes;
      }
      case ANARI_MATERIAL:
      {
         static const char *ANARI_MATERIAL_subtypes[] = {"matte", "transparentMatte", 0};
         return ANARI_MATERIAL_subtypes;
      }
      case ANARI_SAMPLER:
      {
         static const char *ANARI_SAMPLER_subtypes[] = {"image1D", "image2D", "image3D", "primitive", "transform", 0};
         return ANARI_SAMPLER_subtypes;
      }
      case ANARI_SPATIAL_FIELD:
      {
         static const char *ANARI_SPATIAL_FIELD_subtypes[] = {"structuredRegular", 0};
         return ANARI_SPATIAL_FIELD_subtypes;
      }
      case ANARI_VOLUME:
      {
         static const char *ANARI_VOLUME_subtypes[] = {"scivis", 0};
         return ANARI_VOLUME_subtypes;
      }
      default:
      {
         static const char *none_subtypes[] = {0};
         return none_subtypes;
      }
   }
}
static const ANARIParameter * ANARI_CAMERA_params(const char *subtype) {
   switch(subtype_hash(subtype)) {
      case 11:
      {
         static const ANARIParameter omnidirectional_params[] = {{"name", ANARI_STRING}, {"position", ANARI_FLOAT32_VEC3}, {"direction", ANARI_FLOAT32_VEC3}, {"up", ANARI_FLOAT32_VEC3}, {"transform", ANARI_FLOAT32_MAT3x4}, {"imageRegion", ANARI_FLOAT32_BOX2}, {"apertureRadius", ANARI_FLOAT32}, {"focusDistance", ANARI_FLOAT32}, {"stereoMode", ANARI_STRING}, {"interpupillaryDistance", ANARI_FLOAT32}, {"layout", ANARI_STRING}, {0, ANARI_UNKNOWN}};
         return omnidirectional_params;
      }
      case 12:
      {
         static const ANARIParameter orthographic_params[] = {{"name", ANARI_STRING}, {"position", ANARI_FLOAT32_VEC3}, {"direction", ANARI_FLOAT32_VEC3}, {"up", ANARI_FLOAT32_VEC3}, {"transform", ANARI_FLOAT32_MAT3x4}, {"imageRegion", ANARI_FLOAT32_BOX2}, {"apertureRadius", ANARI_FLOAT32}, {"focusDistance", ANARI_FLOAT32}, {"stereoMode", ANARI_STRING}, {"interpupillaryDistance", ANARI_FLOAT32}, {"aspect", ANARI_FLOAT32}, {0, ANARI_UNKNOWN}};
         return orthographic_params;
      }
      case 14:
      {
         static const ANARIParameter perspective_params[] = {{"name", ANARI_STRING}, {"position", ANARI_FLOAT32_VEC3}, {"direction", ANARI_FLOAT32_VEC3}, {"up", ANARI_FLOAT32_VEC3}, {"transform", ANARI_FLOAT32_MAT3x4}, {"imageRegion", ANARI_FLOAT32_BOX2}, {"apertureRadius", ANARI_FLOAT32}, {"focusDistance", ANARI_FLOAT32}, {"stereoMode", ANARI_STRING}, {"interpupillaryDistance", ANARI_FLOAT32}, {"fovy", ANARI_FLOAT32}, {"aspect", ANARI_FLOAT32}, {0, ANARI_UNKNOWN}};
         return perspective_params;
      }
      default:
      {
         static const ANARIParameter none[] = {{0, ANARI_UNKNOWN}};
         return none;
      }
   }
}
static const ANARIParameter * ANARI_GEOMETRY_params(const char *subtype) {
   switch(subtype_hash(subtype)) {
      case 1:
      {
         static const ANARIParameter cone_params[] = {{"name", ANARI_STRING}, {"primitive.color", ANARI_ARRAY1D}, {"primitive.attribute0", ANARI_ARRAY1D}, {"primitive.attribute1", ANARI_ARRAY1D}, {"primitive.attribute2", ANARI_ARRAY1D}, {"primitive.attribute3", ANARI_ARRAY1D}, {"primitive.id", ANARI_ARRAY1D}, {"vertex.position", ANARI_ARRAY1D}, {"vertex.radius", ANARI_ARRAY1D}, {"vertex.cap", ANARI_ARRAY1D}, {"vertex.color", ANARI_ARRAY1D}, {"vertex.attribute0", ANARI_ARRAY1D}, {"vertex.attribute1", ANARI_ARRAY1D}, {"vertex.attribute2", ANARI_ARRAY1D}, {"vertex.attribute3", ANARI_ARRAY1D}, {"primitive.index", ANARI_ARRAY1D}, {"caps", ANARI_STRING}, {0, ANARI_UNKNOWN}};
         return cone_params;
      }
      case 2:
      {
         static const ANARIParameter curve_params[] = {{"name", ANARI_STRING}, {"primitive.color", ANARI_ARRAY1D}, {"primitive.attribute0", ANARI_ARRAY1D}, {"primitive.attribute1", ANARI_ARRAY1D}, {"primitive.attribute2", ANARI_ARRAY1D}, {"primitive.attribute3", ANARI_ARRAY1D}, {"primitive.id", ANARI_ARRAY1D}, {"vertex.position", ANARI_ARRAY1D}, {"vertex.radius", ANARI_ARRAY1D}, {"vertex.color", ANARI_ARRAY1D}, {"vertex.attribute0", ANARI_ARRAY1D}, {"vertex.attribute1", ANARI_ARRAY1D}, {"vertex.attribute2", ANARI_ARRAY1D}, {"vertex.attribute3", ANARI_ARRAY1D}, {"primitive.index", ANARI_ARRAY1D}, {"radius", ANARI_FLOAT32}, {0, ANARI_UNKNOWN}};
         return curve_params;
      }
      case 3:
      {
         static const ANARIParameter cylinder_params[] = {{"name", ANARI_STRING}, {"primitive.color", ANARI_ARRAY1D}, {"primitive.attribute0", ANARI_ARRAY1D}, {"primitive.attribute1", ANARI_ARRAY1D}, {"primitive.attribute2", ANARI_ARRAY1D}, {"primitive.attribute3", ANARI_ARRAY1D}, {"primitive.id", ANARI_ARRAY1D}, {"vertex.position", ANARI_ARRAY1D}, {"vertex.cap", ANARI_ARRAY1D}, {"vertex.color", ANARI_ARRAY1D}, {"vertex.attribute0", ANARI_ARRAY1D}, {"vertex.attribute1", ANARI_ARRAY1D}, {"vertex.attribute2", ANARI_ARRAY1D}, {"vertex.attribute3", ANARI_ARRAY1D}, {"primitive.index", ANARI_ARRAY1D}, {"primitive.radius", ANARI_ARRAY1D}, {"radius", ANARI_FLOAT32}, {"caps", ANARI_STRING}, {0, ANARI_UNKNOWN}};
         return cylinder_params;
      }
      case 17:
      {
         static const ANARIParameter quad_params[] = {{"name", ANARI_STRING}, {"primitive.color", ANARI_ARRAY1D}, {"primitive.attribute0", ANARI_ARRAY1D}, {"primitive.attribute1", ANARI_ARRAY1D}, {"primitive.attribute2", ANARI_ARRAY1D}, {"primitive.attribute3", ANARI_ARRAY1D}, {"primitive.id", ANARI_ARRAY1D}, {"vertex.position", ANARI_ARRAY1D}, {"vertex.normal", ANARI_ARRAY1D}, {"vertex.color", ANARI_ARRAY1D}, {"vertex.attribute0", ANARI_ARRAY1D}, {"vertex.attribute1", ANARI_ARRAY1D}, {"vertex.attribute2", ANARI_ARRAY1D}, {"vertex.attribute3", ANARI_ARRAY1D}, {"primitive.index", ANARI_ARRAY1D}, {0, ANARI_UNKNOWN}};
         return quad_params;
      }
      case 21:
      {
         static const ANARIParameter sphere_params[] = {{"name", ANARI_STRING}, {"primitive.color", ANARI_ARRAY1D}, {"primitive.attribute0", ANARI_ARRAY1D}, {"primitive.attribute1", ANARI_ARRAY1D}, {"primitive.attribute2", ANARI_ARRAY1D}, {"primitive.attribute3", ANARI_ARRAY1D}, {"primitive.id", ANARI_ARRAY1D}, {"vertex.position", ANARI_ARRAY1D}, {"vertex.radius", ANARI_ARRAY1D}, {"vertex.color", ANARI_ARRAY1D}, {"vertex.attribute0", ANARI_ARRAY1D}, {"vertex.attribute1", ANARI_ARRAY1D}, {"vertex.attribute2", ANARI_ARRAY1D}, {"vertex.attribute3", ANARI_ARRAY1D}, {"primitive.index", ANARI_ARRAY1D}, {"radius", ANARI_FLOAT32}, {0, ANARI_UNKNOWN}};
         return sphere_params;
      }
      case 26:
      {
         static const ANARIParameter triangle_params[] = {{"name", ANARI_STRING}, {"primitive.color", ANARI_ARRAY1D}, {"primitive.attribute0", ANARI_ARRAY1D}, {"primitive.attribute1", ANARI_ARRAY1D}, {"primitive.attribute2", ANARI_ARRAY1D}, {"primitive.attribute3", ANARI_ARRAY1D}, {"primitive.id", ANARI_ARRAY1D}, {"vertex.position", ANARI_ARRAY1D}, {"vertex.normal", ANARI_ARRAY1D}, {"vertex.color", ANARI_ARRAY1D}, {"vertex.attribute0", ANARI_ARRAY1D}, {"vertex.attribute1", ANARI_ARRAY1D}, {"vertex.attribute2", ANARI_ARRAY1D}, {"vertex.attribute3", ANARI_ARRAY1D}, {"primitive.index", ANARI_ARRAY1D}, {0, ANARI_UNKNOWN}};
         return triangle_params;
      }
      default:
      {
         static const ANARIParameter none[] = {{0, ANARI_UNKNOWN}};
         return none;
      }
   }
}
static const ANARIParameter * ANARI_LIGHT_params(const char *subtype) {
   switch(subtype_hash(subtype)) {
      case 6:
      {
         static const ANARIParameter directional_params[] = {{"name", ANARI_STRING}, {"color", ANARI_FLOAT32_VEC3}, {"irridance", ANARI_FLOAT32}, {"direction", ANARI_FLOAT32_VEC3}, {0, ANARI_UNKNOWN}};
         return directional_params;
      }
      case 15:
      {
         static const ANARIParameter point_params[] = {{"name", ANARI_STRING}, {"color", ANARI_FLOAT32_VEC3}, {"position", ANARI_FLOAT32_VEC3}, {"intensity", ANARI_FLOAT32}, {"power", ANARI_FLOAT32}, {0, ANARI_UNKNOWN}};
         return point_params;
      }
      case 22:
      {
         static const ANARIParameter spot_params[] = {{"name", ANARI_STRING}, {"color", ANARI_FLOAT32_VEC3}, {"position", ANARI_FLOAT32_VEC3}, {"direction", ANARI_FLOAT32_VEC3}, {"openingAngle", ANARI_FLOAT32}, {"falloffAngle", ANARI_FLOAT32}, {"intensity", ANARI_FLOAT32}, {"power", ANARI_FLOAT32}, {0, ANARI_UNKNOWN}};
         return spot_params;
      }
      default:
      {
         static const ANARIParameter none[] = {{0, ANARI_UNKNOWN}};
         return none;
      }
   }
}
static const ANARIParameter * ANARI_MATERIAL_params(const char *subtype) {
   switch(subtype_hash(subtype)) {
      case 10:
      {
         static const ANARIParameter matte_params[] = {{"name", ANARI_STRING}, {"color", ANARI_FLOAT32_VEC3}, {"color", ANARI_SAMPLER}, {"color", ANARI_STRING}, {0, ANARI_UNKNOWN}};
         return matte_params;
      }
      case 25:
      {
         static const ANARIParameter transparentMatte_params[] = {{"name", ANARI_STRING}, {"color", ANARI_FLOAT32_VEC3}, {"color", ANARI_SAMPLER}, {"color", ANARI_STRING}, {"opacity", ANARI_FLOAT32}, {"opacity", ANARI_SAMPLER}, {"opacity", ANARI_STRING}, {0, ANARI_UNKNOWN}};
         return transparentMatte_params;
      }
      default:
      {
         static const ANARIParameter none[] = {{0, ANARI_UNKNOWN}};
         return none;
      }
   }
}
static const ANARIParameter * ANARI_RENDERER_params(const char *subtype) {
   switch(subtype_hash(subtype)) {
      case 5:
      {
         static const ANARIParameter default_params[] = {{"backgroundColor", ANARI_FLOAT32_VEC4}, {"pixelSamples", ANARI_INT32}, {"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
         return default_params;
      }
      case 20:
      {
         static const ANARIParameter scivis_params[] = {{"name", ANARI_STRING}, {"backgroundColor", ANARI_FLOAT32_VEC4}, {"pixelSamples", ANARI_INT32}, {0, ANARI_UNKNOWN}};
         return scivis_params;
      }
      case 0:
      {
         static const ANARIParameter ao_params[] = {{"name", ANARI_STRING}, {"backgroundColor", ANARI_FLOAT32_VEC4}, {"pixelSamples", ANARI_INT32}, {0, ANARI_UNKNOWN}};
         return ao_params;
      }
      case 13:
      {
         static const ANARIParameter pathtracer_params[] = {{"name", ANARI_STRING}, {"backgroundColor", ANARI_FLOAT32_VEC4}, {"pixelSamples", ANARI_INT32}, {0, ANARI_UNKNOWN}};
         return pathtracer_params;
      }
      case 4:
      {
         static const ANARIParameter debug_params[] = {{"name", ANARI_STRING}, {"backgroundColor", ANARI_FLOAT32_VEC4}, {"pixelSamples", ANARI_INT32}, {0, ANARI_UNKNOWN}};
         return debug_params;
      }
      case 19:
      {
         static const ANARIParameter raycast_params[] = {{"name", ANARI_STRING}, {"backgroundColor", ANARI_FLOAT32_VEC4}, {"pixelSamples", ANARI_INT32}, {0, ANARI_UNKNOWN}};
         return raycast_params;
      }
      case 18:
      {
         static const ANARIParameter rayDir_params[] = {{"name", ANARI_STRING}, {"backgroundColor", ANARI_FLOAT32_VEC4}, {"pixelSamples", ANARI_INT32}, {0, ANARI_UNKNOWN}};
         return rayDir_params;
      }
      default:
      {
         static const ANARIParameter none[] = {{0, ANARI_UNKNOWN}};
         return none;
      }
   }
}
static const ANARIParameter * ANARI_SAMPLER_params(const char *subtype) {
   switch(subtype_hash(subtype)) {
      case 7:
      {
         static const ANARIParameter image1D_params[] = {{"name", ANARI_STRING}, {"image", ANARI_ARRAY1D}, {"inAttribute", ANARI_STRING}, {"filter", ANARI_STRING}, {"wrapMode1", ANARI_STRING}, {"inTransform", ANARI_FLOAT32_MAT4}, {"outTransform", ANARI_FLOAT32_MAT4}, {0, ANARI_UNKNOWN}};
         return image1D_params;
      }
      case 8:
      {
         static const ANARIParameter image2D_params[] = {{"name", ANARI_STRING}, {"image", ANARI_ARRAY2D}, {"inAttribute", ANARI_STRING}, {"filter", ANARI_STRING}, {"wrapMode1", ANARI_STRING}, {"wrapMode2", ANARI_STRING}, {"inTransform", ANARI_FLOAT32_MAT4}, {"outTransform", ANARI_FLOAT32_MAT4}, {0, ANARI_UNKNOWN}};
         return image2D_params;
      }
      case 9:
      {
         static const ANARIParameter image3D_params[] = {{"name", ANARI_STRING}, {"image", ANARI_ARRAY3D}, {"inAttribute", ANARI_STRING}, {"filter", ANARI_STRING}, {"wrapMode1", ANARI_STRING}, {"wrapMode2", ANARI_STRING}, {"wrapMode3", ANARI_STRING}, {"inTransform", ANARI_FLOAT32_MAT4}, {"outTransform", ANARI_FLOAT32_MAT4}, {0, ANARI_UNKNOWN}};
         return image3D_params;
      }
      case 16:
      {
         static const ANARIParameter primitive_params[] = {{"name", ANARI_STRING}, {"array", ANARI_ARRAY1D}, {0, ANARI_UNKNOWN}};
         return primitive_params;
      }
      case 24:
      {
         static const ANARIParameter transform_params[] = {{"name", ANARI_STRING}, {"inAttribute", ANARI_STRING}, {"transform", ANARI_FLOAT32_MAT4}, {0, ANARI_UNKNOWN}};
         return transform_params;
      }
      default:
      {
         static const ANARIParameter none[] = {{0, ANARI_UNKNOWN}};
         return none;
      }
   }
}
static const ANARIParameter * ANARI_SPATIAL_FIELD_params(const char *subtype) {
   switch(subtype_hash(subtype)) {
      case 23:
      {
         static const ANARIParameter structuredRegular_params[] = {{"name", ANARI_STRING}, {"data", ANARI_ARRAY3D}, {"origin", ANARI_FLOAT32_VEC3}, {"spacing", ANARI_FLOAT32_VEC3}, {"filter", ANARI_STRING}, {0, ANARI_UNKNOWN}};
         return structuredRegular_params;
      }
      default:
      {
         static const ANARIParameter none[] = {{0, ANARI_UNKNOWN}};
         return none;
      }
   }
}
static const ANARIParameter * ANARI_VOLUME_params(const char *subtype) {
   switch(subtype_hash(subtype)) {
      case 20:
      {
         static const ANARIParameter scivis_params[] = {{"name", ANARI_STRING}, {"field", ANARI_SPATIAL_FIELD}, {"valueRange", ANARI_FLOAT32_BOX1}, {"color", ANARI_ARRAY1D}, {"color.position", ANARI_ARRAY1D}, {"opacity", ANARI_ARRAY1D}, {"opacity.position", ANARI_ARRAY1D}, {"densityScale", ANARI_FLOAT32}, {0, ANARI_UNKNOWN}};
         return scivis_params;
      }
      default:
      {
         static const ANARIParameter none[] = {{0, ANARI_UNKNOWN}};
         return none;
      }
   }
}
const ANARIParameter * query_params(ANARIDataType type, const char *subtype) {
   switch(type) {
      case ANARI_CAMERA:
         return ANARI_CAMERA_params(subtype);
      case ANARI_GEOMETRY:
         return ANARI_GEOMETRY_params(subtype);
      case ANARI_LIGHT:
         return ANARI_LIGHT_params(subtype);
      case ANARI_MATERIAL:
         return ANARI_MATERIAL_params(subtype);
      case ANARI_RENDERER:
         return ANARI_RENDERER_params(subtype);
      case ANARI_SAMPLER:
         return ANARI_SAMPLER_params(subtype);
      case ANARI_SPATIAL_FIELD:
         return ANARI_SPATIAL_FIELD_params(subtype);
      case ANARI_VOLUME:
         return ANARI_VOLUME_params(subtype);
      case ANARI_DEVICE:
      {
         static const ANARIParameter ANARI_DEVICE_params[] = {{"name", ANARI_STRING}, {"statusCallback", ANARI_STATUS_CALLBACK}, {"statusCallbackUserData", ANARI_VOID_POINTER}, {0, ANARI_UNKNOWN}};
         return ANARI_DEVICE_params;
      }
      case ANARI_ARRAY1D:
      {
         static const ANARIParameter ANARI_ARRAY1D_params[] = {{"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
         return ANARI_ARRAY1D_params;
      }
      case ANARI_ARRAY2D:
      {
         static const ANARIParameter ANARI_ARRAY2D_params[] = {{"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
         return ANARI_ARRAY2D_params;
      }
      case ANARI_ARRAY3D:
      {
         static const ANARIParameter ANARI_ARRAY3D_params[] = {{"name", ANARI_STRING}, {0, ANARI_UNKNOWN}};
         return ANARI_ARRAY3D_params;
      }
      case ANARI_FRAME:
      {
         static const ANARIParameter ANARI_FRAME_params[] = {{"name", ANARI_STRING}, {"world", ANARI_WORLD}, {"renderer", ANARI_RENDERER}, {"camera", ANARI_CAMERA}, {"size", ANARI_UINT32_VEC2}, {"color", ANARI_DATA_TYPE}, {"depth", ANARI_DATA_TYPE}, {0, ANARI_UNKNOWN}};
         return ANARI_FRAME_params;
      }
      case ANARI_GROUP:
      {
         static const ANARIParameter ANARI_GROUP_params[] = {{"name", ANARI_STRING}, {"surface", ANARI_ARRAY1D}, {"volume", ANARI_ARRAY1D}, {"light", ANARI_ARRAY1D}, {0, ANARI_UNKNOWN}};
         return ANARI_GROUP_params;
      }
      case ANARI_INSTANCE:
      {
         static const ANARIParameter ANARI_INSTANCE_params[] = {{"name", ANARI_STRING}, {"transform", ANARI_FLOAT32_MAT3x4}, {"group", ANARI_GROUP}, {0, ANARI_UNKNOWN}};
         return ANARI_INSTANCE_params;
      }
      case ANARI_WORLD:
      {
         static const ANARIParameter ANARI_WORLD_params[] = {{"name", ANARI_STRING}, {"instance", ANARI_ARRAY1D}, {"surface", ANARI_ARRAY1D}, {"volume", ANARI_ARRAY1D}, {"light", ANARI_ARRAY1D}, {0, ANARI_UNKNOWN}};
         return ANARI_WORLD_params;
      }
      case ANARI_SURFACE:
      {
         static const ANARIParameter ANARI_SURFACE_params[] = {{"name", ANARI_STRING}, {"geometry", ANARI_GEOMETRY}, {"material", ANARI_MATERIAL}, {0, ANARI_UNKNOWN}};
         return ANARI_SURFACE_params;
      }
      default:
      {
         static const ANARIParameter none[] = {{0, ANARI_UNKNOWN}};
         return none;
      }
   }
}
static int info_hash(const char *str) {
   static const uint32_t table[] = {0x66650013u,0x6d6c0030u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a61003bu,0x0u,0x0u,0x0u,0x0u,0x66650050u,0x0u,0x0u,0x0u,0x62610058u,0x74660014u,0x62610022u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x64630027u,0x76750023u,0x6d6c0024u,0x75740025u,0x1000026u,0x80000001u,0x73720028u,0x6a690029u,0x7170002au,0x7574002bu,0x6a69002cu,0x706f002du,0x6f6e002eu,0x100002fu,0x80000004u,0x66650031u,0x6e6d0032u,0x66650033u,0x6f6e0034u,0x75740035u,0x55540036u,0x7a790037u,0x71700038u,0x66650039u,0x100003au,0x80000005u,0x79780044u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f6e004au,0x6a690045u,0x6e6d0046u,0x76750047u,0x6e6d0048u,0x1000049u,0x80000003u,0x6a69004bu,0x6e6d004cu,0x7675004du,0x6e6d004eu,0x100004fu,0x80000002u,0x72710051u,0x76750052u,0x6a690053u,0x73720054u,0x66650055u,0x65640056u,0x1000057u,0x80000000u,0x6d6c0059u,0x7675005au,0x6665005bu,0x7473005cu,0x100005du,0x80000006u};
   uint32_t cur = 0x77640000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static const int32_t anari_true = 1;static const int32_t anari_false = 0;static const void * ANARI_RENDERER_default_backgroundColor_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.0, 1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "background color and alpha (RGBA)";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_pixelSamples_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "samples per pixel";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 3:
         return ANARI_RENDERER_default_backgroundColor_info(paramType, infoName, infoType);
      case 36:
         return ANARI_RENDERER_default_pixelSamples_info(paramType, infoName, infoType);
      case 30:
         return ANARI_RENDERER_default_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_scivis_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_scivis_backgroundColor_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.0, 1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "background color and alpha (RGBA)";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_scivis_pixelSamples_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "samples per pixel";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_scivis_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_RENDERER_scivis_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_scivis_backgroundColor_info(paramType, infoName, infoType);
      case 36:
         return ANARI_RENDERER_scivis_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_ao_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_ao_backgroundColor_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.0, 1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "background color and alpha (RGBA)";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_ao_pixelSamples_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "samples per pixel";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_ao_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_RENDERER_ao_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_ao_backgroundColor_info(paramType, infoName, infoType);
      case 36:
         return ANARI_RENDERER_ao_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_pathtracer_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_pathtracer_backgroundColor_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.0, 1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "background color and alpha (RGBA)";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_pathtracer_pixelSamples_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "samples per pixel";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_pathtracer_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_RENDERER_pathtracer_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_pathtracer_backgroundColor_info(paramType, infoName, infoType);
      case 36:
         return ANARI_RENDERER_pathtracer_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_debug_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_debug_backgroundColor_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.0, 1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "background color and alpha (RGBA)";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_debug_pixelSamples_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "samples per pixel";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_debug_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_RENDERER_debug_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_debug_backgroundColor_info(paramType, infoName, infoType);
      case 36:
         return ANARI_RENDERER_debug_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_raycast_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_raycast_backgroundColor_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.0, 1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "background color and alpha (RGBA)";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_raycast_pixelSamples_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "samples per pixel";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_raycast_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_RENDERER_raycast_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_raycast_backgroundColor_info(paramType, infoName, infoType);
      case 36:
         return ANARI_RENDERER_raycast_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_rayDir_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_rayDir_backgroundColor_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.0, 1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "background color and alpha (RGBA)";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_rayDir_pixelSamples_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            const char *description = "samples per pixel";
            return description;
         }
       default: return nullptr;
   }
}
static const void * ANARI_RENDERER_rayDir_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_RENDERER_rayDir_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_rayDir_backgroundColor_info(paramType, infoName, infoType);
      case 36:
         return ANARI_RENDERER_rayDir_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_DEVICE_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_DEVICE_statusCallback_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_DEVICE_statusCallbackUserData_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_DEVICE_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_DEVICE_name_info(paramType, infoName, infoType);
      case 51:
         return ANARI_DEVICE_statusCallback_info(paramType, infoName, infoType);
      case 52:
         return ANARI_DEVICE_statusCallbackUserData_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY1D_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_ARRAY1D_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_ARRAY1D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY2D_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_ARRAY2D_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_ARRAY2D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY3D_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_ARRAY3D_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_ARRAY3D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_FRAME_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_FRAME_world_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_FRAME_renderer_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_FRAME_camera_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_FRAME_size_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_FRAME_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"ANARI_UFIXED8_VEC4", "ANARI_UFIXED8_RGBA_SRGB", "ANARI_FLOAT32_VEC4", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_FRAME_depth_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"ANARI_FLOAT32", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_FRAME_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_FRAME_name_info(paramType, infoName, infoType);
      case 68:
         return ANARI_FRAME_world_info(paramType, infoName, infoType);
      case 48:
         return ANARI_FRAME_renderer_info(paramType, infoName, infoType);
      case 4:
         return ANARI_FRAME_camera_info(paramType, infoName, infoType);
      case 49:
         return ANARI_FRAME_size_info(paramType, infoName, infoType);
      case 6:
         return ANARI_FRAME_color_info(paramType, infoName, infoType);
      case 10:
         return ANARI_FRAME_depth_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GROUP_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GROUP_surface_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GROUP_volume_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GROUP_light_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GROUP_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_GROUP_name_info(paramType, infoName, infoType);
      case 54:
         return ANARI_GROUP_surface_info(paramType, infoName, infoType);
      case 67:
         return ANARI_GROUP_volume_info(paramType, infoName, infoType);
      case 28:
         return ANARI_GROUP_light_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_INSTANCE_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_transform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT3x4 && infoType == ANARI_FLOAT32_MAT3x4) {
            static const float default_value[12] = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_group_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_INSTANCE_name_info(paramType, infoName, infoType);
      case 55:
         return ANARI_INSTANCE_transform_info(paramType, infoName, infoType);
      case 18:
         return ANARI_INSTANCE_group_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_WORLD_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_WORLD_instance_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_WORLD_surface_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_WORLD_volume_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_WORLD_light_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_WORLD_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_WORLD_name_info(paramType, infoName, infoType);
      case 23:
         return ANARI_WORLD_instance_info(paramType, infoName, infoType);
      case 54:
         return ANARI_WORLD_surface_info(paramType, infoName, infoType);
      case 67:
         return ANARI_WORLD_volume_info(paramType, infoName, infoType);
      case 28:
         return ANARI_WORLD_light_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SURFACE_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SURFACE_geometry_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SURFACE_material_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SURFACE_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_SURFACE_name_info(paramType, infoName, infoType);
      case 17:
         return ANARI_SURFACE_geometry_info(paramType, infoName, infoType);
      case 29:
         return ANARI_SURFACE_material_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_direction_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, -1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_up_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 1.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_transform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT3x4 && infoType == ANARI_FLOAT32_MAT3x4) {
            static const float default_value[12] = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_imageRegion_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.0, 0.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_apertureRadius_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_focusDistance_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_stereoMode_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"none", "left", "right", "sideBySide", "topBottom", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_interpupillaryDistance_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.0635};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_layout_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "equirectangular";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"equirectangular", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_CAMERA_omnidirectional_name_info(paramType, infoName, infoType);
      case 37:
         return ANARI_CAMERA_omnidirectional_position_info(paramType, infoName, infoType);
      case 11:
         return ANARI_CAMERA_omnidirectional_direction_info(paramType, infoName, infoType);
      case 56:
         return ANARI_CAMERA_omnidirectional_up_info(paramType, infoName, infoType);
      case 55:
         return ANARI_CAMERA_omnidirectional_transform_info(paramType, infoName, infoType);
      case 20:
         return ANARI_CAMERA_omnidirectional_imageRegion_info(paramType, infoName, infoType);
      case 0:
         return ANARI_CAMERA_omnidirectional_apertureRadius_info(paramType, infoName, infoType);
      case 15:
         return ANARI_CAMERA_omnidirectional_focusDistance_info(paramType, infoName, infoType);
      case 53:
         return ANARI_CAMERA_omnidirectional_stereoMode_info(paramType, infoName, infoType);
      case 25:
         return ANARI_CAMERA_omnidirectional_interpupillaryDistance_info(paramType, infoName, infoType);
      case 27:
         return ANARI_CAMERA_omnidirectional_layout_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_direction_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, -1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_up_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 1.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_transform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT3x4 && infoType == ANARI_FLOAT32_MAT3x4) {
            static const float default_value[12] = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_imageRegion_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.0, 0.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_apertureRadius_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_focusDistance_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_stereoMode_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"none", "left", "right", "sideBySide", "topBottom", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_interpupillaryDistance_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.0635};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_aspect_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_CAMERA_orthographic_name_info(paramType, infoName, infoType);
      case 37:
         return ANARI_CAMERA_orthographic_position_info(paramType, infoName, infoType);
      case 11:
         return ANARI_CAMERA_orthographic_direction_info(paramType, infoName, infoType);
      case 56:
         return ANARI_CAMERA_orthographic_up_info(paramType, infoName, infoType);
      case 55:
         return ANARI_CAMERA_orthographic_transform_info(paramType, infoName, infoType);
      case 20:
         return ANARI_CAMERA_orthographic_imageRegion_info(paramType, infoName, infoType);
      case 0:
         return ANARI_CAMERA_orthographic_apertureRadius_info(paramType, infoName, infoType);
      case 15:
         return ANARI_CAMERA_orthographic_focusDistance_info(paramType, infoName, infoType);
      case 53:
         return ANARI_CAMERA_orthographic_stereoMode_info(paramType, infoName, infoType);
      case 25:
         return ANARI_CAMERA_orthographic_interpupillaryDistance_info(paramType, infoName, infoType);
      case 2:
         return ANARI_CAMERA_orthographic_aspect_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_direction_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, -1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_up_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 1.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_transform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT3x4 && infoType == ANARI_FLOAT32_MAT3x4) {
            static const float default_value[12] = {1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_imageRegion_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.0, 0.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_apertureRadius_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_focusDistance_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_stereoMode_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"none", "left", "right", "sideBySide", "topBottom", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_interpupillaryDistance_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.0635};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_fovy_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.0471975512};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_aspect_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_CAMERA_perspective_name_info(paramType, infoName, infoType);
      case 37:
         return ANARI_CAMERA_perspective_position_info(paramType, infoName, infoType);
      case 11:
         return ANARI_CAMERA_perspective_direction_info(paramType, infoName, infoType);
      case 56:
         return ANARI_CAMERA_perspective_up_info(paramType, infoName, infoType);
      case 55:
         return ANARI_CAMERA_perspective_transform_info(paramType, infoName, infoType);
      case 20:
         return ANARI_CAMERA_perspective_imageRegion_info(paramType, infoName, infoType);
      case 0:
         return ANARI_CAMERA_perspective_apertureRadius_info(paramType, infoName, infoType);
      case 15:
         return ANARI_CAMERA_perspective_focusDistance_info(paramType, infoName, infoType);
      case 53:
         return ANARI_CAMERA_perspective_stereoMode_info(paramType, infoName, infoType);
      case 25:
         return ANARI_CAMERA_perspective_interpupillaryDistance_info(paramType, infoName, infoType);
      case 16:
         return ANARI_CAMERA_perspective_fovy_info(paramType, infoName, infoType);
      case 2:
         return ANARI_CAMERA_perspective_aspect_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_id_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_radius_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_cap_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_index_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_caps_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"none", "first", "second", "both", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_GEOMETRY_cone_name_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_cone_primitive_color_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_cone_primitive_attribute0_info(paramType, infoName, infoType);
      case 40:
         return ANARI_GEOMETRY_cone_primitive_attribute1_info(paramType, infoName, infoType);
      case 41:
         return ANARI_GEOMETRY_cone_primitive_attribute2_info(paramType, infoName, infoType);
      case 42:
         return ANARI_GEOMETRY_cone_primitive_attribute3_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_cone_primitive_id_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_cone_vertex_position_info(paramType, infoName, infoType);
      case 66:
         return ANARI_GEOMETRY_cone_vertex_radius_info(paramType, infoName, infoType);
      case 62:
         return ANARI_GEOMETRY_cone_vertex_cap_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_cone_vertex_color_info(paramType, infoName, infoType);
      case 58:
         return ANARI_GEOMETRY_cone_vertex_attribute0_info(paramType, infoName, infoType);
      case 59:
         return ANARI_GEOMETRY_cone_vertex_attribute1_info(paramType, infoName, infoType);
      case 60:
         return ANARI_GEOMETRY_cone_vertex_attribute2_info(paramType, infoName, infoType);
      case 61:
         return ANARI_GEOMETRY_cone_vertex_attribute3_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_cone_primitive_index_info(paramType, infoName, infoType);
      case 5:
         return ANARI_GEOMETRY_cone_caps_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_id_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_radius_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_index_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_radius_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_GEOMETRY_curve_name_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_curve_primitive_color_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_curve_primitive_attribute0_info(paramType, infoName, infoType);
      case 40:
         return ANARI_GEOMETRY_curve_primitive_attribute1_info(paramType, infoName, infoType);
      case 41:
         return ANARI_GEOMETRY_curve_primitive_attribute2_info(paramType, infoName, infoType);
      case 42:
         return ANARI_GEOMETRY_curve_primitive_attribute3_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_curve_primitive_id_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_curve_vertex_position_info(paramType, infoName, infoType);
      case 66:
         return ANARI_GEOMETRY_curve_vertex_radius_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_curve_vertex_color_info(paramType, infoName, infoType);
      case 58:
         return ANARI_GEOMETRY_curve_vertex_attribute0_info(paramType, infoName, infoType);
      case 59:
         return ANARI_GEOMETRY_curve_vertex_attribute1_info(paramType, infoName, infoType);
      case 60:
         return ANARI_GEOMETRY_curve_vertex_attribute2_info(paramType, infoName, infoType);
      case 61:
         return ANARI_GEOMETRY_curve_vertex_attribute3_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_curve_primitive_index_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_curve_radius_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_id_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_cap_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_index_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_radius_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_radius_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_caps_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"none", "first", "second", "both", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_GEOMETRY_cylinder_name_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_cylinder_primitive_color_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_cylinder_primitive_attribute0_info(paramType, infoName, infoType);
      case 40:
         return ANARI_GEOMETRY_cylinder_primitive_attribute1_info(paramType, infoName, infoType);
      case 41:
         return ANARI_GEOMETRY_cylinder_primitive_attribute2_info(paramType, infoName, infoType);
      case 42:
         return ANARI_GEOMETRY_cylinder_primitive_attribute3_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_cylinder_primitive_id_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_cylinder_vertex_position_info(paramType, infoName, infoType);
      case 62:
         return ANARI_GEOMETRY_cylinder_vertex_cap_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_cylinder_vertex_color_info(paramType, infoName, infoType);
      case 58:
         return ANARI_GEOMETRY_cylinder_vertex_attribute0_info(paramType, infoName, infoType);
      case 59:
         return ANARI_GEOMETRY_cylinder_vertex_attribute1_info(paramType, infoName, infoType);
      case 60:
         return ANARI_GEOMETRY_cylinder_vertex_attribute2_info(paramType, infoName, infoType);
      case 61:
         return ANARI_GEOMETRY_cylinder_vertex_attribute3_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_cylinder_primitive_index_info(paramType, infoName, infoType);
      case 46:
         return ANARI_GEOMETRY_cylinder_primitive_radius_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_cylinder_radius_info(paramType, infoName, infoType);
      case 5:
         return ANARI_GEOMETRY_cylinder_caps_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_id_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_normal_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_index_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_GEOMETRY_quad_name_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_quad_primitive_color_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_quad_primitive_attribute0_info(paramType, infoName, infoType);
      case 40:
         return ANARI_GEOMETRY_quad_primitive_attribute1_info(paramType, infoName, infoType);
      case 41:
         return ANARI_GEOMETRY_quad_primitive_attribute2_info(paramType, infoName, infoType);
      case 42:
         return ANARI_GEOMETRY_quad_primitive_attribute3_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_quad_primitive_id_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_quad_vertex_position_info(paramType, infoName, infoType);
      case 64:
         return ANARI_GEOMETRY_quad_vertex_normal_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_quad_vertex_color_info(paramType, infoName, infoType);
      case 58:
         return ANARI_GEOMETRY_quad_vertex_attribute0_info(paramType, infoName, infoType);
      case 59:
         return ANARI_GEOMETRY_quad_vertex_attribute1_info(paramType, infoName, infoType);
      case 60:
         return ANARI_GEOMETRY_quad_vertex_attribute2_info(paramType, infoName, infoType);
      case 61:
         return ANARI_GEOMETRY_quad_vertex_attribute3_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_quad_primitive_index_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_id_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_radius_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_index_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_radius_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_GEOMETRY_sphere_name_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_sphere_primitive_color_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_sphere_primitive_attribute0_info(paramType, infoName, infoType);
      case 40:
         return ANARI_GEOMETRY_sphere_primitive_attribute1_info(paramType, infoName, infoType);
      case 41:
         return ANARI_GEOMETRY_sphere_primitive_attribute2_info(paramType, infoName, infoType);
      case 42:
         return ANARI_GEOMETRY_sphere_primitive_attribute3_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_sphere_primitive_id_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_sphere_vertex_position_info(paramType, infoName, infoType);
      case 66:
         return ANARI_GEOMETRY_sphere_vertex_radius_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_sphere_vertex_color_info(paramType, infoName, infoType);
      case 58:
         return ANARI_GEOMETRY_sphere_vertex_attribute0_info(paramType, infoName, infoType);
      case 59:
         return ANARI_GEOMETRY_sphere_vertex_attribute1_info(paramType, infoName, infoType);
      case 60:
         return ANARI_GEOMETRY_sphere_vertex_attribute2_info(paramType, infoName, infoType);
      case 61:
         return ANARI_GEOMETRY_sphere_vertex_attribute3_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_sphere_primitive_index_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_sphere_radius_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_id_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_normal_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute0_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_index_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_GEOMETRY_triangle_name_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_triangle_primitive_color_info(paramType, infoName, infoType);
      case 39:
         return ANARI_GEOMETRY_triangle_primitive_attribute0_info(paramType, infoName, infoType);
      case 40:
         return ANARI_GEOMETRY_triangle_primitive_attribute1_info(paramType, infoName, infoType);
      case 41:
         return ANARI_GEOMETRY_triangle_primitive_attribute2_info(paramType, infoName, infoType);
      case 42:
         return ANARI_GEOMETRY_triangle_primitive_attribute3_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_triangle_primitive_id_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_triangle_vertex_position_info(paramType, infoName, infoType);
      case 64:
         return ANARI_GEOMETRY_triangle_vertex_normal_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_triangle_vertex_color_info(paramType, infoName, infoType);
      case 58:
         return ANARI_GEOMETRY_triangle_vertex_attribute0_info(paramType, infoName, infoType);
      case 59:
         return ANARI_GEOMETRY_triangle_vertex_attribute1_info(paramType, infoName, infoType);
      case 60:
         return ANARI_GEOMETRY_triangle_vertex_attribute2_info(paramType, infoName, infoType);
      case 61:
         return ANARI_GEOMETRY_triangle_vertex_attribute3_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_triangle_primitive_index_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_irridance_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_direction_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_LIGHT_directional_name_info(paramType, infoName, infoType);
      case 6:
         return ANARI_LIGHT_directional_color_info(paramType, infoName, infoType);
      case 26:
         return ANARI_LIGHT_directional_irridance_info(paramType, infoName, infoType);
      case 11:
         return ANARI_LIGHT_directional_direction_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_point_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_intensity_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_power_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_LIGHT_point_name_info(paramType, infoName, infoType);
      case 6:
         return ANARI_LIGHT_point_color_info(paramType, infoName, infoType);
      case 37:
         return ANARI_LIGHT_point_position_info(paramType, infoName, infoType);
      case 24:
         return ANARI_LIGHT_point_intensity_info(paramType, infoName, infoType);
      case 38:
         return ANARI_LIGHT_point_power_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_direction_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, -1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_openingAngle_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {3.14159265359};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_falloffAngle_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_intensity_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_power_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_LIGHT_spot_name_info(paramType, infoName, infoType);
      case 6:
         return ANARI_LIGHT_spot_color_info(paramType, infoName, infoType);
      case 37:
         return ANARI_LIGHT_spot_position_info(paramType, infoName, infoType);
      case 11:
         return ANARI_LIGHT_spot_direction_info(paramType, infoName, infoType);
      case 33:
         return ANARI_LIGHT_spot_openingAngle_info(paramType, infoName, infoType);
      case 12:
         return ANARI_LIGHT_spot_falloffAngle_info(paramType, infoName, infoType);
      case 24:
         return ANARI_LIGHT_spot_intensity_info(paramType, infoName, infoType);
      case 38:
         return ANARI_LIGHT_spot_power_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.8, 0.8, 0.8};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_MATERIAL_matte_name_info(paramType, infoName, infoType);
      case 6:
         return ANARI_MATERIAL_matte_color_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_transparentMatte_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_transparentMatte_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.8, 0.8, 0.8};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_transparentMatte_opacity_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_transparentMatte_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_MATERIAL_transparentMatte_name_info(paramType, infoName, infoType);
      case 6:
         return ANARI_MATERIAL_transparentMatte_color_info(paramType, infoName, infoType);
      case 31:
         return ANARI_MATERIAL_transparentMatte_opacity_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_image_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_inAttribute_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_filter_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_wrapMode1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_inTransform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_outTransform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_SAMPLER_image1D_name_info(paramType, infoName, infoType);
      case 19:
         return ANARI_SAMPLER_image1D_image_info(paramType, infoName, infoType);
      case 21:
         return ANARI_SAMPLER_image1D_inAttribute_info(paramType, infoName, infoType);
      case 14:
         return ANARI_SAMPLER_image1D_filter_info(paramType, infoName, infoType);
      case 69:
         return ANARI_SAMPLER_image1D_wrapMode1_info(paramType, infoName, infoType);
      case 22:
         return ANARI_SAMPLER_image1D_inTransform_info(paramType, infoName, infoType);
      case 35:
         return ANARI_SAMPLER_image1D_outTransform_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_image_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_inAttribute_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_filter_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_wrapMode1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_wrapMode2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_inTransform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_outTransform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_SAMPLER_image2D_name_info(paramType, infoName, infoType);
      case 19:
         return ANARI_SAMPLER_image2D_image_info(paramType, infoName, infoType);
      case 21:
         return ANARI_SAMPLER_image2D_inAttribute_info(paramType, infoName, infoType);
      case 14:
         return ANARI_SAMPLER_image2D_filter_info(paramType, infoName, infoType);
      case 69:
         return ANARI_SAMPLER_image2D_wrapMode1_info(paramType, infoName, infoType);
      case 70:
         return ANARI_SAMPLER_image2D_wrapMode2_info(paramType, infoName, infoType);
      case 22:
         return ANARI_SAMPLER_image2D_inTransform_info(paramType, infoName, infoType);
      case 35:
         return ANARI_SAMPLER_image2D_outTransform_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_image_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_inAttribute_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_filter_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_wrapMode1_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_wrapMode2_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_wrapMode3_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_inTransform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_outTransform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_SAMPLER_image3D_name_info(paramType, infoName, infoType);
      case 19:
         return ANARI_SAMPLER_image3D_image_info(paramType, infoName, infoType);
      case 21:
         return ANARI_SAMPLER_image3D_inAttribute_info(paramType, infoName, infoType);
      case 14:
         return ANARI_SAMPLER_image3D_filter_info(paramType, infoName, infoType);
      case 69:
         return ANARI_SAMPLER_image3D_wrapMode1_info(paramType, infoName, infoType);
      case 70:
         return ANARI_SAMPLER_image3D_wrapMode2_info(paramType, infoName, infoType);
      case 71:
         return ANARI_SAMPLER_image3D_wrapMode3_info(paramType, infoName, infoType);
      case 22:
         return ANARI_SAMPLER_image3D_inTransform_info(paramType, infoName, infoType);
      case 35:
         return ANARI_SAMPLER_image3D_outTransform_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_array_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_SAMPLER_primitive_name_info(paramType, infoName, infoType);
      case 1:
         return ANARI_SAMPLER_primitive_array_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_inAttribute_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_transform_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_SAMPLER_transform_name_info(paramType, infoName, infoType);
      case 21:
         return ANARI_SAMPLER_transform_inAttribute_info(paramType, infoName, infoType);
      case 55:
         return ANARI_SAMPLER_transform_transform_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_data_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_origin_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.0, 0.0, 0.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.0, 1.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_filter_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 6: // values
         if(paramType == ANARI_STRING) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_SPATIAL_FIELD_structuredRegular_name_info(paramType, infoName, infoType);
      case 8:
         return ANARI_SPATIAL_FIELD_structuredRegular_data_info(paramType, infoName, infoType);
      case 34:
         return ANARI_SPATIAL_FIELD_structuredRegular_origin_info(paramType, infoName, infoType);
      case 50:
         return ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(paramType, infoName, infoType);
      case 14:
         return ANARI_SPATIAL_FIELD_structuredRegular_filter_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_name_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_field_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_valueRange_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
            static const float default_value[2] = {0.0, 1.0};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_color_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_color_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_opacity_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_opacity_position_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_densityScale_info(ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(info_hash(infoName)) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1};
            return default_value;
         } else {
            return nullptr;
         }
       default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_param_info(const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 30:
         return ANARI_VOLUME_scivis_name_info(paramType, infoName, infoType);
      case 13:
         return ANARI_VOLUME_scivis_field_info(paramType, infoName, infoType);
      case 57:
         return ANARI_VOLUME_scivis_valueRange_info(paramType, infoName, infoType);
      case 6:
         return ANARI_VOLUME_scivis_color_info(paramType, infoName, infoType);
      case 7:
         return ANARI_VOLUME_scivis_color_position_info(paramType, infoName, infoType);
      case 31:
         return ANARI_VOLUME_scivis_opacity_info(paramType, infoName, infoType);
      case 32:
         return ANARI_VOLUME_scivis_opacity_position_info(paramType, infoName, infoType);
      case 9:
         return ANARI_VOLUME_scivis_densityScale_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 11:
         return ANARI_CAMERA_omnidirectional_param_info(paramName, paramType, infoName, infoType);
      case 12:
         return ANARI_CAMERA_orthographic_param_info(paramName, paramType, infoName, infoType);
      case 14:
         return ANARI_CAMERA_perspective_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 1:
         return ANARI_GEOMETRY_cone_param_info(paramName, paramType, infoName, infoType);
      case 2:
         return ANARI_GEOMETRY_curve_param_info(paramName, paramType, infoName, infoType);
      case 3:
         return ANARI_GEOMETRY_cylinder_param_info(paramName, paramType, infoName, infoType);
      case 17:
         return ANARI_GEOMETRY_quad_param_info(paramName, paramType, infoName, infoType);
      case 21:
         return ANARI_GEOMETRY_sphere_param_info(paramName, paramType, infoName, infoType);
      case 26:
         return ANARI_GEOMETRY_triangle_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 6:
         return ANARI_LIGHT_directional_param_info(paramName, paramType, infoName, infoType);
      case 15:
         return ANARI_LIGHT_point_param_info(paramName, paramType, infoName, infoType);
      case 22:
         return ANARI_LIGHT_spot_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 10:
         return ANARI_MATERIAL_matte_param_info(paramName, paramType, infoName, infoType);
      case 25:
         return ANARI_MATERIAL_transparentMatte_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 5:
         return ANARI_RENDERER_default_param_info(paramName, paramType, infoName, infoType);
      case 20:
         return ANARI_RENDERER_scivis_param_info(paramName, paramType, infoName, infoType);
      case 0:
         return ANARI_RENDERER_ao_param_info(paramName, paramType, infoName, infoType);
      case 13:
         return ANARI_RENDERER_pathtracer_param_info(paramName, paramType, infoName, infoType);
      case 4:
         return ANARI_RENDERER_debug_param_info(paramName, paramType, infoName, infoType);
      case 19:
         return ANARI_RENDERER_raycast_param_info(paramName, paramType, infoName, infoType);
      case 18:
         return ANARI_RENDERER_rayDir_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 7:
         return ANARI_SAMPLER_image1D_param_info(paramName, paramType, infoName, infoType);
      case 8:
         return ANARI_SAMPLER_image2D_param_info(paramName, paramType, infoName, infoType);
      case 9:
         return ANARI_SAMPLER_image3D_param_info(paramName, paramType, infoName, infoType);
      case 16:
         return ANARI_SAMPLER_primitive_param_info(paramName, paramType, infoName, infoType);
      case 24:
         return ANARI_SAMPLER_transform_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 23:
         return ANARI_SPATIAL_FIELD_structuredRegular_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_VOLUME_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 20:
         return ANARI_VOLUME_scivis_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_param_info(ANARIDataType type, const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoName, ANARIDataType infoType) {
   switch(type) {
      case ANARI_CAMERA:
         return ANARI_CAMERA_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_GEOMETRY:
         return ANARI_GEOMETRY_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_LIGHT:
         return ANARI_LIGHT_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_MATERIAL:
         return ANARI_MATERIAL_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_RENDERER:
         return ANARI_RENDERER_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_SAMPLER:
         return ANARI_SAMPLER_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_SPATIAL_FIELD:
         return ANARI_SPATIAL_FIELD_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_VOLUME:
         return ANARI_VOLUME_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_DEVICE:
         return ANARI_DEVICE_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY1D:
         return ANARI_ARRAY1D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY2D:
         return ANARI_ARRAY2D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY3D:
         return ANARI_ARRAY3D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_FRAME:
         return ANARI_FRAME_param_info(paramName, paramType, infoName, infoType);
      case ANARI_GROUP:
         return ANARI_GROUP_param_info(paramName, paramType, infoName, infoType);
      case ANARI_INSTANCE:
         return ANARI_INSTANCE_param_info(paramName, paramType, infoName, infoType);
      case ANARI_WORLD:
         return ANARI_WORLD_param_info(paramName, paramType, infoName, infoType);
      case ANARI_SURFACE:
         return ANARI_SURFACE_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
}
}
