// Copyright 2021 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_queries.py
// Don't make changes to this directly

#include <stdint.h>
#include <anari/anari.h>
namespace anari {
namespace example_device {
static int subtype_hash(const char *str) {
   static const uint32_t table[] = {0x706f0014u,0x0u,0x7a6f0016u,0x6a65002fu,0x0u,0x0u,0x0u,0x0u,0x6e6d004bu,0x0u,0x0u,0x0u,0x62610058u,0x0u,0x736d005du,0x7361007cu,0x767500adu,0x626100b1u,0x756300dau,0x7372010fu,0x1000015u,0x80000000u,0x6f6e0021u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720024u,0x0u,0x0u,0x0u,0x6d6c0028u,0x66650022u,0x1000023u,0x80000001u,0x77760025u,0x66650026u,0x1000027u,0x80000002u,0x6a690029u,0x6f6e002au,0x6564002bu,0x6665002cu,0x7372002du,0x100002eu,0x80000003u,0x67620034u,0x0u,0x0u,0x0u,0x73720041u,0x76750039u,0x0u,0x0u,0x0u,0x6261003cu,0x6867003au,0x100003bu,0x80000004u,0x7675003du,0x6d6c003eu,0x7574003fu,0x1000040u,0x80000005u,0x66650042u,0x64630043u,0x75740044u,0x6a690045u,0x706f0046u,0x6f6e0047u,0x62610048u,0x6d6c0049u,0x100004au,0x80000006u,0x6261004cu,0x6867004du,0x6665004eu,0x3431004fu,0x45440052u,0x45440054u,0x45440056u,0x1000053u,0x80000007u,0x1000055u,0x80000008u,0x1000057u,0x80000009u,0x75740059u,0x7574005au,0x6665005bu,0x100005cu,0x8000000au,0x6f6e0063u,0x0u,0x0u,0x0u,0x0u,0x75740071u,0x6a690064u,0x65640065u,0x6a690066u,0x73720067u,0x66650068u,0x64630069u,0x7574006au,0x6a69006bu,0x706f006cu,0x6f6e006du,0x6261006eu,0x6d6c006fu,0x1000070u,0x8000000bu,0x69680072u,0x706f0073u,0x68670074u,0x73720075u,0x62610076u,0x71700077u,0x69680078u,0x6a690079u,0x6463007au,0x100007bu,0x8000000cu,0x7574008eu,0x0u,0x0u,0x0u,0x73720097u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a6900a1u,0x0u,0x0u,0x6a6900a5u,0x6968008fu,0x75740090u,0x73720091u,0x62610092u,0x64630093u,0x66650094u,0x73720095u,0x1000096u,0x8000000du,0x74730098u,0x71700099u,0x6665009au,0x6463009bu,0x7574009cu,0x6a69009du,0x7776009eu,0x6665009fu,0x10000a0u,0x8000000eu,0x6f6e00a2u,0x757400a3u,0x10000a4u,0x8000000fu,0x6e6d00a6u,0x6a6900a7u,0x757400a8u,0x6a6900a9u,0x777600aau,0x666500abu,0x10000acu,0x80000010u,0x626100aeu,0x656400afu,0x10000b0u,0x80000011u,0x7a7900b2u,0x644400b3u,0x6a6900d3u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100d6u,0x737200d4u,0x10000d5u,0x80000012u,0x747300d7u,0x757400d8u,0x10000d9u,0x80000013u,0x6a6900ecu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706800f1u,0x0u,0x0u,0x0u,0x737200ffu,0x777600edu,0x6a6900eeu,0x747300efu,0x10000f0u,0x80000014u,0x666500f9u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x757400fdu,0x737200fau,0x666500fbu,0x10000fcu,0x80000015u,0x10000feu,0x80000016u,0x76750100u,0x64630101u,0x75740102u,0x76750103u,0x73720104u,0x66650105u,0x65640106u,0x53520107u,0x66650108u,0x68670109u,0x7675010au,0x6d6c010bu,0x6261010cu,0x7372010du,0x100010eu,0x80000017u,0x6a610110u,0x6f6e0119u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610135u,0x7473011au,0x7166011bu,0x706f0126u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261012au,0x73720127u,0x6e6d0128u,0x1000129u,0x80000018u,0x7372012bu,0x6665012cu,0x6f6e012du,0x7574012eu,0x4e4d012fu,0x62610130u,0x75740131u,0x75740132u,0x66650133u,0x1000134u,0x80000019u,0x6f6e0136u,0x68670137u,0x6d6c0138u,0x66650139u,0x100013au,0x8000001au};
   uint32_t cur = 0x75610000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static int param_hash(const char *str) {
   static const uint32_t table[] = {0x74700017u,0x62610031u,0x70610040u,0x6a6100a6u,0x0u,0x736100c5u,0x73650185u,0x0u,0x736d019eu,0x0u,0x0u,0x6a610272u,0x62610284u,0x6261028cu,0x76660290u,0x73690300u,0x0u,0x66610368u,0x76690379u,0x7372040bu,0x71700414u,0x70610416u,0x736f0483u,0x6665001bu,0x0u,0x73720028u,0x7170002cu,0x7372001cu,0x7574001du,0x7675001eu,0x7372001fu,0x66650020u,0x53520021u,0x62610022u,0x65640023u,0x6a690024u,0x76750025u,0x74730026u,0x1000027u,0x80000000u,0x62610029u,0x7a79002au,0x100002bu,0x80000001u,0x6665002du,0x6463002eu,0x7574002fu,0x1000030u,0x80000002u,0x64630032u,0x6c6b0033u,0x68670034u,0x73720035u,0x706f0036u,0x76750037u,0x6f6e0038u,0x65640039u,0x4443003au,0x706f003bu,0x6d6c003cu,0x706f003du,0x7372003eu,0x100003fu,0x80000003u,0x716d004fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610059u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c006bu,0x66650053u,0x0u,0x0u,0x74730057u,0x73720054u,0x62610055u,0x1000056u,0x80000004u,0x1000058u,0x80000005u,0x6f6e005au,0x6f6e005bu,0x6665005cu,0x6d6c005du,0x2f2e005eu,0x6563005fu,0x706f0061u,0x66650066u,0x6d6c0062u,0x706f0063u,0x73720064u,0x1000065u,0x80000006u,0x71700067u,0x75740068u,0x69680069u,0x100006au,0x80000007u,0x706f006cu,0x7372006du,0x2f00006eu,0x80000008u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7170009du,0x706f009eu,0x7473009fu,0x6a6900a0u,0x757400a1u,0x6a6900a2u,0x706f00a3u,0x6f6e00a4u,0x10000a5u,0x80000009u,0x757400afu,0x0u,0x0u,0x0u,0x6f6e00b2u,0x0u,0x0u,0x0u,0x737200bdu,0x626100b0u,0x10000b1u,0x8000000au,0x747300b3u,0x6a6900b4u,0x757400b5u,0x7a7900b6u,0x545300b7u,0x646300b8u,0x626100b9u,0x6d6c00bau,0x666500bbu,0x10000bcu,0x8000000bu,0x666500beu,0x646300bfu,0x757400c0u,0x6a6900c1u,0x706f00c2u,0x6f6e00c3u,0x10000c4u,0x8000000cu,0x6d6c00d7u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6500e2u,0x0u,0x0u,0x0u,0x0u,0x0u,0x776300f1u,0x0u,0x0u,0x62610112u,0x6d6c00d8u,0x706f00d9u,0x676600dau,0x676600dbu,0x424100dcu,0x6f6e00ddu,0x686700deu,0x6d6c00dfu,0x666500e0u,0x10000e1u,0x8000000du,0x6d6c00eau,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x757400edu,0x656400ebu,0x10000ecu,0x8000000eu,0x666500eeu,0x737200efu,0x10000f0u,0x8000000fu,0x76750105u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7a790110u,0x74730106u,0x45440107u,0x6a690108u,0x74730109u,0x7574010au,0x6261010bu,0x6f6e010cu,0x6463010du,0x6665010eu,0x100010fu,0x80000010u,0x1000111u,0x80000011u,0x6e6d0113u,0x66650114u,0x44430115u,0x706f0116u,0x6e6d0117u,0x71700118u,0x6d6c0119u,0x6665011au,0x7574011bu,0x6a69011cu,0x706f011du,0x6f6e011eu,0x4443011fu,0x62610120u,0x6d6c0121u,0x6d6c0122u,0x63620123u,0x62610124u,0x64630125u,0x6c6b0126u,0x56000127u,0x80000012u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7473017du,0x6665017eu,0x7372017fu,0x45440180u,0x62610181u,0x75740182u,0x62610183u,0x1000184u,0x80000013u,0x706f0193u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f019au,0x6e6d0194u,0x66650195u,0x75740196u,0x73720197u,0x7a790198u,0x1000199u,0x80000014u,0x7675019bu,0x7170019cu,0x100019du,0x80000015u,0x626101a4u,0x75410200u,0x0u,0x0u,0x0u,0x73720269u,0x686701a5u,0x666501a6u,0x530001a7u,0x80000016u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666501fau,0x686701fbu,0x6a6901fcu,0x706f01fdu,0x6f6e01feu,0x10001ffu,0x80000017u,0x75740234u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372023du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x75740246u,0x6665024cu,0x75740235u,0x73720236u,0x6a690237u,0x63620238u,0x76750239u,0x7574023au,0x6665023bu,0x100023cu,0x80000018u,0x6261023eu,0x6f6e023fu,0x74730240u,0x67660241u,0x706f0242u,0x73720243u,0x6e6d0244u,0x1000245u,0x80000019u,0x62610247u,0x6f6e0248u,0x64630249u,0x6665024au,0x100024bu,0x8000001au,0x736e024du,0x74730252u,0x0u,0x0u,0x0u,0x71700257u,0x6a690253u,0x75740254u,0x7a790255u,0x1000256u,0x8000001bu,0x76750258u,0x71700259u,0x6a69025au,0x6d6c025bu,0x6d6c025cu,0x6261025du,0x7372025eu,0x7a79025fu,0x45440260u,0x6a690261u,0x74730262u,0x75740263u,0x62610264u,0x6f6e0265u,0x64630266u,0x66650267u,0x1000268u,0x8000001cu,0x6261026au,0x6564026bu,0x6a69026cu,0x6261026du,0x6f6e026eu,0x6463026fu,0x66650270u,0x1000271u,0x8000001du,0x7a79027bu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x68670280u,0x706f027cu,0x7675027du,0x7574027eu,0x100027fu,0x8000001eu,0x69680281u,0x75740282u,0x1000283u,0x8000001fu,0x75740285u,0x66650286u,0x73720287u,0x6a690288u,0x62610289u,0x6d6c028au,0x100028bu,0x80000020u,0x6e6d028du,0x6665028eu,0x100028fu,0x80000021u,0x676602a0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666102a5u,0x0u,0x6a6902f0u,0x0u,0x0u,0x757402f5u,0x747302a1u,0x666502a2u,0x757402a3u,0x10002a4u,0x80000022u,0x646302aau,0x0u,0x0u,0x0u,0x6f6e02e6u,0x6a6902abu,0x757402acu,0x7a7902adu,0x2f0002aeu,0x80000023u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x717002ddu,0x706f02deu,0x747302dfu,0x6a6902e0u,0x757402e1u,0x6a6902e2u,0x706f02e3u,0x6f6e02e4u,0x10002e5u,0x80000024u,0x6a6902e7u,0x6f6e02e8u,0x686702e9u,0x424102eau,0x6f6e02ebu,0x686702ecu,0x6d6c02edu,0x666502eeu,0x10002efu,0x80000025u,0x686702f1u,0x6a6902f2u,0x6f6e02f3u,0x10002f4u,0x80000026u,0x555402f6u,0x737202f7u,0x626102f8u,0x6f6e02f9u,0x747302fau,0x676602fbu,0x706f02fcu,0x737202fdu,0x6e6d02feu,0x10002ffu,0x80000027u,0x7978030au,0x0u,0x0u,0x0u,0x0u,0x0u,0x78730315u,0x0u,0x0u,0x6a690323u,0x6665030bu,0x6d6c030cu,0x5453030du,0x6261030eu,0x6e6d030fu,0x71700310u,0x6d6c0311u,0x66650312u,0x74730313u,0x1000314u,0x80000028u,0x6a69031au,0x0u,0x0u,0x0u,0x66650320u,0x7574031bu,0x6a69031cu,0x706f031du,0x6f6e031eu,0x100031fu,0x80000029u,0x73720321u,0x1000322u,0x8000002au,0x6e6d0324u,0x6a690325u,0x75740326u,0x6a690327u,0x77760328u,0x66650329u,0x2f2e032au,0x7361032bu,0x7574033du,0x0u,0x706f034du,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640352u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610362u,0x7574033eu,0x7372033fu,0x6a690340u,0x63620341u,0x76750342u,0x75740343u,0x66650344u,0x34300345u,0x1000349u,0x100034au,0x100034bu,0x100034cu,0x8000002bu,0x8000002cu,0x8000002du,0x8000002eu,0x6d6c034eu,0x706f034fu,0x73720350u,0x1000351u,0x8000002fu,0x100035du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6564035eu,0x80000030u,0x6665035fu,0x79780360u,0x1000361u,0x80000031u,0x65640363u,0x6a690364u,0x76750365u,0x74730366u,0x1000367u,0x80000032u,0x6564036du,0x0u,0x0u,0x0u,0x6f6e0372u,0x6a69036eu,0x7675036fu,0x74730370u,0x1000371u,0x80000033u,0x65640373u,0x66650374u,0x73720375u,0x66650376u,0x73720377u,0x1000378u,0x80000034u,0x7b7a0386u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610389u,0x0u,0x0u,0x0u,0x6661038fu,0x73720405u,0x66650387u,0x1000388u,0x80000035u,0x6463038au,0x6a69038bu,0x6f6e038cu,0x6867038du,0x100038eu,0x80000036u,0x75740394u,0x0u,0x0u,0x0u,0x737203fdu,0x76750395u,0x74730396u,0x44430397u,0x62610398u,0x6d6c0399u,0x6d6c039au,0x6362039bu,0x6261039cu,0x6463039du,0x6c6b039eu,0x5600039fu,0x80000037u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x747303f5u,0x666503f6u,0x737203f7u,0x454403f8u,0x626103f9u,0x757403fau,0x626103fbu,0x10003fcu,0x80000038u,0x666503feu,0x706f03ffu,0x4e4d0400u,0x706f0401u,0x65640402u,0x66650403u,0x1000404u,0x80000039u,0x67660406u,0x62610407u,0x64630408u,0x66650409u,0x100040au,0x8000003au,0x6261040cu,0x6f6e040du,0x7473040eu,0x6766040fu,0x706f0410u,0x73720411u,0x6e6d0412u,0x1000413u,0x8000003bu,0x1000415u,0x8000003cu,0x6d6c0425u,0x0u,0x0u,0x0u,0x7372042eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c047eu,0x76750426u,0x66650427u,0x53520428u,0x62610429u,0x6f6e042au,0x6867042bu,0x6665042cu,0x100042du,0x8000003du,0x7574042fu,0x66650430u,0x79780431u,0x2f2e0432u,0x73610433u,0x75740445u,0x0u,0x70610455u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f046au,0x0u,0x706f0470u,0x0u,0x62610478u,0x75740446u,0x73720447u,0x6a690448u,0x63620449u,0x7675044au,0x7574044bu,0x6665044cu,0x3430044du,0x1000451u,0x1000452u,0x1000453u,0x1000454u,0x8000003eu,0x8000003fu,0x80000040u,0x80000041u,0x71700464u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c0466u,0x1000465u,0x80000042u,0x706f0467u,0x73720468u,0x1000469u,0x80000043u,0x7372046bu,0x6e6d046cu,0x6261046du,0x6d6c046eu,0x100046fu,0x80000044u,0x74730471u,0x6a690472u,0x75740473u,0x6a690474u,0x706f0475u,0x6f6e0476u,0x1000477u,0x80000045u,0x65640479u,0x6a69047au,0x7675047bu,0x7473047cu,0x100047du,0x80000046u,0x7675047fu,0x6e6d0480u,0x66650481u,0x1000482u,0x80000047u,0x73720487u,0x0u,0x0u,0x6261048bu,0x6d6c0488u,0x65640489u,0x100048au,0x80000048u,0x7170048cu,0x4e4d048du,0x706f048eu,0x6564048fu,0x66650490u,0x34310491u,0x1000494u,0x1000495u,0x1000496u,0x80000049u,0x8000004au,0x8000004bu};
   uint32_t cur = 0x78610000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static int info_hash(const char *str) {
   static const uint32_t table[] = {0x69680014u,0x6665001bu,0x6d6c0038u,0x66650043u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a61004au,0x0u,0x0u,0x6261005fu,0x0u,0x66650068u,0x706f0070u,0x0u,0x0u,0x6261007du,0x62610015u,0x6f6e0016u,0x6f6e0017u,0x66650018u,0x6d6c0019u,0x100001au,0x8000000au,0x7466001cu,0x6261002au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6463002fu,0x7675002bu,0x6d6c002cu,0x7574002du,0x100002eu,0x80000001u,0x73720030u,0x6a690031u,0x71700032u,0x75740033u,0x6a690034u,0x706f0035u,0x6f6e0036u,0x1000037u,0x80000004u,0x66650039u,0x6e6d003au,0x6665003bu,0x6f6e003cu,0x7574003du,0x5554003eu,0x7a79003fu,0x71700040u,0x66650041u,0x1000042u,0x80000005u,0x62610044u,0x75740045u,0x76750046u,0x73720047u,0x66650048u,0x1000049u,0x80000008u,0x79780053u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f6e0059u,0x6a690054u,0x6e6d0055u,0x76750056u,0x6e6d0057u,0x1000058u,0x80000003u,0x6a69005au,0x6e6d005bu,0x7675005cu,0x6e6d005du,0x100005eu,0x80000002u,0x73720060u,0x62610061u,0x6e6d0062u,0x66650063u,0x75740064u,0x66650065u,0x73720066u,0x1000067u,0x80000009u,0x72710069u,0x7675006au,0x6a69006bu,0x7372006cu,0x6665006du,0x6564006eu,0x100006fu,0x80000000u,0x76750071u,0x73720072u,0x64630073u,0x66650074u,0x47460075u,0x66650076u,0x62610077u,0x75740078u,0x76750079u,0x7372007au,0x6665007bu,0x100007cu,0x80000007u,0x6d6c007eu,0x7675007fu,0x66650080u,0x1000081u,0x80000006u};
   uint32_t cur = 0x77630000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static const int32_t anari_true = 1;static const int32_t anari_false = 0;const char ** query_extensions() {
   static const char *features[] = {
      "ANARI_example_device",
      "ANARI_CORE_OBJECTS",
      "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
      "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
      "ANARI_KHR_CAMERA_PERSPECTIVE",
      "ANARI_KHR_GEOMETRY_CONE",
      "ANARI_KHR_GEOMETRY_CURVE",
      "ANARI_KHR_GEOMETRY_CYLINDER",
      "ANARI_KHR_GEOMETRY_QUAD",
      "ANARI_KHR_GEOMETRY_SPHERE",
      "ANARI_KHR_GEOMETRY_TRIANGLE",
      "ANARI_KHR_LIGHT_DIRECTIONAL",
      "ANARI_KHR_LIGHT_POINT",
      "ANARI_KHR_LIGHT_SPOT",
      "ANARI_KHR_MATERIAL_MATTE",
      "ANARI_KHR_MATERIAL_TRANSPARENT_MATTE",
      "ANARI_KHR_SAMPLER_IMAGE1D",
      "ANARI_KHR_SAMPLER_IMAGE2D",
      "ANARI_KHR_SAMPLER_IMAGE3D",
      "ANARI_KHR_SAMPLER_PRIMITIVE",
      "ANARI_KHR_SAMPLER_TRANSFORM",
      "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
      "ANARI_KHR_VOLUME_SCIVIS",
      "ANARI_CORE_API",
      "ANARI_SPEC_ALL",
      "ANARI_KHR_FRAME_CONTINUATION",
      0
   };
   return features;
}
const char ** query_object_types(ANARIDataType type) {
   switch(type) {
      case ANARI_RENDERER:
      {
         static const char *ANARI_RENDERER_subtypes[] = {"default", "scivis", "ao", "pathtracer", "debug", "raycast", "rayDir", 0};
         return ANARI_RENDERER_subtypes;
      }
      case ANARI_CAMERA:
      {
         static const char *ANARI_CAMERA_subtypes[] = {"omnidirectional", "orthographic", "perspective", 0};
         return ANARI_CAMERA_subtypes;
      }
      case ANARI_GEOMETRY:
      {
         static const char *ANARI_GEOMETRY_subtypes[] = {"cone", "curve", "cylinder", "quad", "sphere", "triangle", 0};
         return ANARI_GEOMETRY_subtypes;
      }
      case ANARI_LIGHT:
      {
         static const char *ANARI_LIGHT_subtypes[] = {"directional", "point", "spot", 0};
         return ANARI_LIGHT_subtypes;
      }
      case ANARI_MATERIAL:
      {
         static const char *ANARI_MATERIAL_subtypes[] = {"matte", "transparentMatte", 0};
         return ANARI_MATERIAL_subtypes;
      }
      case ANARI_SAMPLER:
      {
         static const char *ANARI_SAMPLER_subtypes[] = {"image1D", "image2D", "image3D", "primitive", "transform", 0};
         return ANARI_SAMPLER_subtypes;
      }
      case ANARI_SPATIAL_FIELD:
      {
         static const char *ANARI_SPATIAL_FIELD_subtypes[] = {"structuredRegular", 0};
         return ANARI_SPATIAL_FIELD_subtypes;
      }
      case ANARI_VOLUME:
      {
         static const char *ANARI_VOLUME_subtypes[] = {"scivis", 0};
         return ANARI_VOLUME_subtypes;
      }
      default:
      {
         static const char *none_subtypes[] = {0};
         return none_subtypes;
      }
   }
}
static const void * ANARI_RENDERER_default_backgroundColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.000000f, 1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "background color and alpha (RGBA)";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_pixelSamples_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "samples per pixel";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 3:
         return ANARI_RENDERER_default_backgroundColor_info(paramType, infoName, infoType);
      case 40:
         return ANARI_RENDERER_default_pixelSamples_info(paramType, infoName, infoType);
      case 33:
         return ANARI_RENDERER_default_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_scivis_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_scivis_backgroundColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.000000f, 1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "background color and alpha (RGBA)";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_scivis_pixelSamples_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "samples per pixel";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_scivis_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_RENDERER_scivis_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_scivis_backgroundColor_info(paramType, infoName, infoType);
      case 40:
         return ANARI_RENDERER_scivis_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_ao_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_ao_backgroundColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.000000f, 1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "background color and alpha (RGBA)";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_ao_pixelSamples_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "samples per pixel";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_ao_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_RENDERER_ao_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_ao_backgroundColor_info(paramType, infoName, infoType);
      case 40:
         return ANARI_RENDERER_ao_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_pathtracer_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_pathtracer_backgroundColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.000000f, 1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "background color and alpha (RGBA)";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_pathtracer_pixelSamples_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "samples per pixel";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_pathtracer_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_RENDERER_pathtracer_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_pathtracer_backgroundColor_info(paramType, infoName, infoType);
      case 40:
         return ANARI_RENDERER_pathtracer_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_debug_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_debug_backgroundColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.000000f, 1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "background color and alpha (RGBA)";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_debug_pixelSamples_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "samples per pixel";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_debug_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_RENDERER_debug_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_debug_backgroundColor_info(paramType, infoName, infoType);
      case 40:
         return ANARI_RENDERER_debug_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_raycast_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_raycast_backgroundColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.000000f, 1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "background color and alpha (RGBA)";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_raycast_pixelSamples_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "samples per pixel";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_raycast_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_RENDERER_raycast_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_raycast_backgroundColor_info(paramType, infoName, infoType);
      case 40:
         return ANARI_RENDERER_raycast_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_rayDir_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_rayDir_backgroundColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {1.000000f, 1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "background color and alpha (RGBA)";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_rayDir_pixelSamples_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_INT32 && infoType == ANARI_INT32) {
            static const int32_t default_value[1] = {INT32_C(1)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "samples per pixel";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_rayDir_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_RENDERER_rayDir_name_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_rayDir_backgroundColor_info(paramType, infoName, infoType);
      case 40:
         return ANARI_RENDERER_rayDir_pixelSamples_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_DEVICE_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_statusCallback_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "callback used to report information to the application";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_statusCallbackUserData_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional pointer passed as the first argument of the status callback";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_DEVICE_name_info(paramType, infoName, infoType);
      case 55:
         return ANARI_DEVICE_statusCallback_info(paramType, infoName, infoType);
      case 56:
         return ANARI_DEVICE_statusCallbackUserData_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY1D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY1D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_ARRAY1D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY2D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY2D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_ARRAY2D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY3D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY3D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_ARRAY3D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_FRAME_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_world_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "world to be rendererd";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_renderer_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "renderer which renders the frame";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_camera_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera used to render the world";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_size_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "size of the frame in pixels (width, height)";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the color channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8_VEC4, ANARI_UFIXED8_RGBA_SRGB, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_depth_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the color channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_frameCompletionCallback_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "function called on frame render completion";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_FRAME_CONTINUATION";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 25;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_frameCompletionCallbackUserData_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional pointer passed as the first argument of the frame continuation callback";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_FRAME_CONTINUATION";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 25;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_FRAME_name_info(paramType, infoName, infoType);
      case 72:
         return ANARI_FRAME_world_info(paramType, infoName, infoType);
      case 52:
         return ANARI_FRAME_renderer_info(paramType, infoName, infoType);
      case 4:
         return ANARI_FRAME_camera_info(paramType, infoName, infoType);
      case 53:
         return ANARI_FRAME_size_info(paramType, infoName, infoType);
      case 6:
         return ANARI_FRAME_channel_color_info(paramType, infoName, infoType);
      case 7:
         return ANARI_FRAME_channel_depth_info(paramType, infoName, infoType);
      case 18:
         return ANARI_FRAME_frameCompletionCallback_info(paramType, infoName, infoType);
      case 19:
         return ANARI_FRAME_frameCompletionCallbackUserData_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GROUP_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_surface_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of surface objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_volume_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of volume objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_VOLUME, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_light_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of light objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_GROUP_name_info(paramType, infoName, infoType);
      case 58:
         return ANARI_GROUP_surface_info(paramType, infoName, infoType);
      case 71:
         return ANARI_GROUP_volume_info(paramType, infoName, infoType);
      case 31:
         return ANARI_GROUP_light_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_INSTANCE_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to objects in the instance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_group_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "group object being instanced";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_INSTANCE_name_info(paramType, infoName, infoType);
      case 59:
         return ANARI_INSTANCE_transform_info(paramType, infoName, infoType);
      case 21:
         return ANARI_INSTANCE_group_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_WORLD_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_instance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of instance objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_INSTANCE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_surface_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced surface objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_volume_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced volume objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_light_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced light objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_WORLD_name_info(paramType, infoName, infoType);
      case 26:
         return ANARI_WORLD_instance_info(paramType, infoName, infoType);
      case 58:
         return ANARI_WORLD_surface_info(paramType, infoName, infoType);
      case 71:
         return ANARI_WORLD_volume_info(paramType, infoName, infoType);
      case 31:
         return ANARI_WORLD_light_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SURFACE_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_geometry_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "geometry object defining the surface geometry";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_material_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "material object defining the surface appearance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_SURFACE_name_info(paramType, infoName, infoType);
      case 20:
         return ANARI_SURFACE_geometry_info(paramType, infoName, infoType);
      case 32:
         return ANARI_SURFACE_material_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera position";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "main viewing direction";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera up direction";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera transform";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_imageRegion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "region mapped to the frame";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_apertureRadius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aperture radius";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_focusDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "focus distance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_stereoMode_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "stereo mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "left", "right", "sideBySide", "topBottom", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_interpupillaryDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.063500f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "interpupillary distance for stereo rendering";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_layout_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "equirectangular";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "pixel layout";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"equirectangular", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_CAMERA_omnidirectional_name_info(paramType, infoName, infoType);
      case 41:
         return ANARI_CAMERA_omnidirectional_position_info(paramType, infoName, infoType);
      case 12:
         return ANARI_CAMERA_omnidirectional_direction_info(paramType, infoName, infoType);
      case 60:
         return ANARI_CAMERA_omnidirectional_up_info(paramType, infoName, infoType);
      case 59:
         return ANARI_CAMERA_omnidirectional_transform_info(paramType, infoName, infoType);
      case 23:
         return ANARI_CAMERA_omnidirectional_imageRegion_info(paramType, infoName, infoType);
      case 0:
         return ANARI_CAMERA_omnidirectional_apertureRadius_info(paramType, infoName, infoType);
      case 16:
         return ANARI_CAMERA_omnidirectional_focusDistance_info(paramType, infoName, infoType);
      case 57:
         return ANARI_CAMERA_omnidirectional_stereoMode_info(paramType, infoName, infoType);
      case 28:
         return ANARI_CAMERA_omnidirectional_interpupillaryDistance_info(paramType, infoName, infoType);
      case 30:
         return ANARI_CAMERA_omnidirectional_layout_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera position";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "main viewing direction";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera up direction";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera transform";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_imageRegion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "region mapped to the frame";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_apertureRadius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aperture radius";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_focusDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "focus distance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_stereoMode_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "stereo mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "left", "right", "sideBySide", "topBottom", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_interpupillaryDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.063500f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "interpupillary distance for stereo rendering";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_aspect_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aspect ratio";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_CAMERA_orthographic_name_info(paramType, infoName, infoType);
      case 41:
         return ANARI_CAMERA_orthographic_position_info(paramType, infoName, infoType);
      case 12:
         return ANARI_CAMERA_orthographic_direction_info(paramType, infoName, infoType);
      case 60:
         return ANARI_CAMERA_orthographic_up_info(paramType, infoName, infoType);
      case 59:
         return ANARI_CAMERA_orthographic_transform_info(paramType, infoName, infoType);
      case 23:
         return ANARI_CAMERA_orthographic_imageRegion_info(paramType, infoName, infoType);
      case 0:
         return ANARI_CAMERA_orthographic_apertureRadius_info(paramType, infoName, infoType);
      case 16:
         return ANARI_CAMERA_orthographic_focusDistance_info(paramType, infoName, infoType);
      case 57:
         return ANARI_CAMERA_orthographic_stereoMode_info(paramType, infoName, infoType);
      case 28:
         return ANARI_CAMERA_orthographic_interpupillaryDistance_info(paramType, infoName, infoType);
      case 2:
         return ANARI_CAMERA_orthographic_aspect_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera position";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "main viewing direction";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera up direction";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera transform";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_imageRegion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "region mapped to the frame";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_apertureRadius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aperture radius";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_focusDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "focus distance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_stereoMode_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "stereo mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "left", "right", "sideBySide", "topBottom", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_interpupillaryDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.063500f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "interpupillary distance for stereo rendering";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_fovy_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.047198f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertical field of view in radians";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_aspect_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aspect ratio";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_CAMERA_perspective_name_info(paramType, infoName, infoType);
      case 41:
         return ANARI_CAMERA_perspective_position_info(paramType, infoName, infoType);
      case 12:
         return ANARI_CAMERA_perspective_direction_info(paramType, infoName, infoType);
      case 60:
         return ANARI_CAMERA_perspective_up_info(paramType, infoName, infoType);
      case 59:
         return ANARI_CAMERA_perspective_transform_info(paramType, infoName, infoType);
      case 23:
         return ANARI_CAMERA_perspective_imageRegion_info(paramType, infoName, infoType);
      case 0:
         return ANARI_CAMERA_perspective_apertureRadius_info(paramType, infoName, infoType);
      case 16:
         return ANARI_CAMERA_perspective_focusDistance_info(paramType, infoName, infoType);
      case 57:
         return ANARI_CAMERA_perspective_stereoMode_info(paramType, infoName, infoType);
      case 28:
         return ANARI_CAMERA_perspective_interpupillaryDistance_info(paramType, infoName, infoType);
      case 17:
         return ANARI_CAMERA_perspective_fovy_info(paramType, infoName, infoType);
      case 2:
         return ANARI_CAMERA_perspective_aspect_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_cap_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex cap type";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_caps_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global cap type";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "first", "second", "both", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 5;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_GEOMETRY_cone_name_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_cone_primitive_color_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_cone_primitive_attribute0_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_cone_primitive_attribute1_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_cone_primitive_attribute2_info(paramType, infoName, infoType);
      case 46:
         return ANARI_GEOMETRY_cone_primitive_attribute3_info(paramType, infoName, infoType);
      case 48:
         return ANARI_GEOMETRY_cone_primitive_id_info(paramType, infoName, infoType);
      case 69:
         return ANARI_GEOMETRY_cone_vertex_position_info(paramType, infoName, infoType);
      case 70:
         return ANARI_GEOMETRY_cone_vertex_radius_info(paramType, infoName, infoType);
      case 66:
         return ANARI_GEOMETRY_cone_vertex_cap_info(paramType, infoName, infoType);
      case 67:
         return ANARI_GEOMETRY_cone_vertex_color_info(paramType, infoName, infoType);
      case 62:
         return ANARI_GEOMETRY_cone_vertex_attribute0_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_cone_vertex_attribute1_info(paramType, infoName, infoType);
      case 64:
         return ANARI_GEOMETRY_cone_vertex_attribute2_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_cone_vertex_attribute3_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_cone_primitive_index_info(paramType, infoName, infoType);
      case 5:
         return ANARI_GEOMETRY_cone_caps_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global radius";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 6;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_GEOMETRY_curve_name_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_curve_primitive_color_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_curve_primitive_attribute0_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_curve_primitive_attribute1_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_curve_primitive_attribute2_info(paramType, infoName, infoType);
      case 46:
         return ANARI_GEOMETRY_curve_primitive_attribute3_info(paramType, infoName, infoType);
      case 48:
         return ANARI_GEOMETRY_curve_primitive_id_info(paramType, infoName, infoType);
      case 69:
         return ANARI_GEOMETRY_curve_vertex_position_info(paramType, infoName, infoType);
      case 70:
         return ANARI_GEOMETRY_curve_vertex_radius_info(paramType, infoName, infoType);
      case 67:
         return ANARI_GEOMETRY_curve_vertex_color_info(paramType, infoName, infoType);
      case 62:
         return ANARI_GEOMETRY_curve_vertex_attribute0_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_curve_vertex_attribute1_info(paramType, infoName, infoType);
      case 64:
         return ANARI_GEOMETRY_curve_vertex_attribute2_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_curve_vertex_attribute3_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_curve_primitive_index_info(paramType, infoName, infoType);
      case 51:
         return ANARI_GEOMETRY_curve_radius_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_cap_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "cylinder cap type";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT8, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC2, ANARI_UINT64_VEC2, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_primitive_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "cylinder radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global cylinder radius";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_caps_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global cylinder cap type";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "first", "second", "both", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 7;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_GEOMETRY_cylinder_name_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_cylinder_primitive_color_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_cylinder_primitive_attribute0_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_cylinder_primitive_attribute1_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_cylinder_primitive_attribute2_info(paramType, infoName, infoType);
      case 46:
         return ANARI_GEOMETRY_cylinder_primitive_attribute3_info(paramType, infoName, infoType);
      case 48:
         return ANARI_GEOMETRY_cylinder_primitive_id_info(paramType, infoName, infoType);
      case 69:
         return ANARI_GEOMETRY_cylinder_vertex_position_info(paramType, infoName, infoType);
      case 66:
         return ANARI_GEOMETRY_cylinder_vertex_cap_info(paramType, infoName, infoType);
      case 67:
         return ANARI_GEOMETRY_cylinder_vertex_color_info(paramType, infoName, infoType);
      case 62:
         return ANARI_GEOMETRY_cylinder_vertex_attribute0_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_cylinder_vertex_attribute1_info(paramType, infoName, infoType);
      case 64:
         return ANARI_GEOMETRY_cylinder_vertex_attribute2_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_cylinder_vertex_attribute3_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_cylinder_primitive_index_info(paramType, infoName, infoType);
      case 50:
         return ANARI_GEOMETRY_cylinder_primitive_radius_info(paramType, infoName, infoType);
      case 51:
         return ANARI_GEOMETRY_cylinder_radius_info(paramType, infoName, infoType);
      case 5:
         return ANARI_GEOMETRY_cylinder_caps_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_normal_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC4, ANARI_UINT64_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 8;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_GEOMETRY_quad_name_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_quad_primitive_color_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_quad_primitive_attribute0_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_quad_primitive_attribute1_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_quad_primitive_attribute2_info(paramType, infoName, infoType);
      case 46:
         return ANARI_GEOMETRY_quad_primitive_attribute3_info(paramType, infoName, infoType);
      case 48:
         return ANARI_GEOMETRY_quad_primitive_id_info(paramType, infoName, infoType);
      case 69:
         return ANARI_GEOMETRY_quad_vertex_position_info(paramType, infoName, infoType);
      case 68:
         return ANARI_GEOMETRY_quad_vertex_normal_info(paramType, infoName, infoType);
      case 67:
         return ANARI_GEOMETRY_quad_vertex_color_info(paramType, infoName, infoType);
      case 62:
         return ANARI_GEOMETRY_quad_vertex_attribute0_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_quad_vertex_attribute1_info(paramType, infoName, infoType);
      case 64:
         return ANARI_GEOMETRY_quad_vertex_attribute2_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_quad_vertex_attribute3_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_quad_primitive_index_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sphere position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sphere radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global sphere radius";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 9;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_GEOMETRY_sphere_name_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_sphere_primitive_color_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_sphere_primitive_attribute0_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_sphere_primitive_attribute1_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_sphere_primitive_attribute2_info(paramType, infoName, infoType);
      case 46:
         return ANARI_GEOMETRY_sphere_primitive_attribute3_info(paramType, infoName, infoType);
      case 48:
         return ANARI_GEOMETRY_sphere_primitive_id_info(paramType, infoName, infoType);
      case 69:
         return ANARI_GEOMETRY_sphere_vertex_position_info(paramType, infoName, infoType);
      case 70:
         return ANARI_GEOMETRY_sphere_vertex_radius_info(paramType, infoName, infoType);
      case 67:
         return ANARI_GEOMETRY_sphere_vertex_color_info(paramType, infoName, infoType);
      case 62:
         return ANARI_GEOMETRY_sphere_vertex_attribute0_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_sphere_vertex_attribute1_info(paramType, infoName, infoType);
      case 64:
         return ANARI_GEOMETRY_sphere_vertex_attribute2_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_sphere_vertex_attribute3_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_sphere_primitive_index_info(paramType, infoName, infoType);
      case 51:
         return ANARI_GEOMETRY_sphere_radius_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_normal_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC3, ANARI_UINT64_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 10;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_GEOMETRY_triangle_name_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_triangle_primitive_color_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_triangle_primitive_attribute0_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_triangle_primitive_attribute1_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_triangle_primitive_attribute2_info(paramType, infoName, infoType);
      case 46:
         return ANARI_GEOMETRY_triangle_primitive_attribute3_info(paramType, infoName, infoType);
      case 48:
         return ANARI_GEOMETRY_triangle_primitive_id_info(paramType, infoName, infoType);
      case 69:
         return ANARI_GEOMETRY_triangle_vertex_position_info(paramType, infoName, infoType);
      case 68:
         return ANARI_GEOMETRY_triangle_vertex_normal_info(paramType, infoName, infoType);
      case 67:
         return ANARI_GEOMETRY_triangle_vertex_color_info(paramType, infoName, infoType);
      case 62:
         return ANARI_GEOMETRY_triangle_vertex_attribute0_info(paramType, infoName, infoType);
      case 63:
         return ANARI_GEOMETRY_triangle_vertex_attribute1_info(paramType, infoName, infoType);
      case 64:
         return ANARI_GEOMETRY_triangle_vertex_attribute2_info(paramType, infoName, infoType);
      case 65:
         return ANARI_GEOMETRY_triangle_vertex_attribute3_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_triangle_primitive_index_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_DIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 11;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 2: // minimum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 3: // maximum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "color of the light";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_DIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 11;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_irradiance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "amount of light in W/m^2";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_DIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 11;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "emission direction of the light";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_DIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 11;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_LIGHT_directional_name_info(paramType, infoName, infoType);
      case 8:
         return ANARI_LIGHT_directional_color_info(paramType, infoName, infoType);
      case 29:
         return ANARI_LIGHT_directional_irradiance_info(paramType, infoName, infoType);
      case 12:
         return ANARI_LIGHT_directional_direction_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_point_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_POINT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 12;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 2: // minimum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 3: // maximum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "color of the light";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_POINT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 12;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "position of the light source";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_POINT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 12;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_intensity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light emitted in a direction in W/sr";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_POINT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 12;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_power_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light energy emitted in W";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_POINT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 12;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_LIGHT_point_name_info(paramType, infoName, infoType);
      case 8:
         return ANARI_LIGHT_point_color_info(paramType, infoName, infoType);
      case 41:
         return ANARI_LIGHT_point_position_info(paramType, infoName, infoType);
      case 27:
         return ANARI_LIGHT_point_intensity_info(paramType, infoName, infoType);
      case 42:
         return ANARI_LIGHT_point_power_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_SPOT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 2: // minimum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 3: // maximum
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "color of the light";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_SPOT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "position of the light source";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_SPOT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "the axis of the spot";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_SPOT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_openingAngle_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {3.141593f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "opening angle in radians";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_SPOT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_falloffAngle_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.100000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "falloff angle in radians";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_SPOT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_intensity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light emitted in a direction in W/sr";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_SPOT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_power_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "overall amount of light energy emitted in W";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_SPOT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 13;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_LIGHT_spot_name_info(paramType, infoName, infoType);
      case 8:
         return ANARI_LIGHT_spot_color_info(paramType, infoName, infoType);
      case 41:
         return ANARI_LIGHT_spot_position_info(paramType, infoName, infoType);
      case 12:
         return ANARI_LIGHT_spot_direction_info(paramType, infoName, infoType);
      case 37:
         return ANARI_LIGHT_spot_openingAngle_info(paramType, infoName, infoType);
      case 13:
         return ANARI_LIGHT_spot_falloffAngle_info(paramType, infoName, infoType);
      case 27:
         return ANARI_LIGHT_spot_intensity_info(paramType, infoName, infoType);
      case 42:
         return ANARI_LIGHT_spot_power_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 14;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.800000f, 0.800000f, 0.800000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "diffuse color";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 14;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_MATERIAL_matte_name_info(paramType, infoName, infoType);
      case 8:
         return ANARI_MATERIAL_matte_color_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_transparentMatte_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_TRANSPARENT_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_transparentMatte_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.800000f, 0.800000f, 0.800000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "diffuse color";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_TRANSPARENT_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_transparentMatte_opacity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "opacity";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_TRANSPARENT_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 15;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_transparentMatte_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_MATERIAL_transparentMatte_name_info(paramType, infoName, infoType);
      case 8:
         return ANARI_MATERIAL_transparentMatte_color_info(paramType, infoName, infoType);
      case 35:
         return ANARI_MATERIAL_transparentMatte_opacity_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE1D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_image_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array backing the sampler";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE1D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_inAttribute_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "input surface attribute (texture coordinate)";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE1D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_filter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "filter mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE1D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_wrapMode1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 1st dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE1D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_inTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the input attribute before sampling";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE1D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_outTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the sampled values";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE1D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 16;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_SAMPLER_image1D_name_info(paramType, infoName, infoType);
      case 22:
         return ANARI_SAMPLER_image1D_image_info(paramType, infoName, infoType);
      case 24:
         return ANARI_SAMPLER_image1D_inAttribute_info(paramType, infoName, infoType);
      case 15:
         return ANARI_SAMPLER_image1D_filter_info(paramType, infoName, infoType);
      case 73:
         return ANARI_SAMPLER_image1D_wrapMode1_info(paramType, infoName, infoType);
      case 25:
         return ANARI_SAMPLER_image1D_inTransform_info(paramType, infoName, infoType);
      case 39:
         return ANARI_SAMPLER_image1D_outTransform_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE2D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 17;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_image_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array backing the sampler";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE2D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 17;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_inAttribute_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "input surface attribute (texture coordinate)";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE2D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 17;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_filter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "filter mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE2D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 17;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_wrapMode1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 1st dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE2D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 17;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_wrapMode2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 2nd dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE2D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 17;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_inTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the input attribute before sampling";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE2D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 17;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_outTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the sampled values";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE2D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 17;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_SAMPLER_image2D_name_info(paramType, infoName, infoType);
      case 22:
         return ANARI_SAMPLER_image2D_image_info(paramType, infoName, infoType);
      case 24:
         return ANARI_SAMPLER_image2D_inAttribute_info(paramType, infoName, infoType);
      case 15:
         return ANARI_SAMPLER_image2D_filter_info(paramType, infoName, infoType);
      case 73:
         return ANARI_SAMPLER_image2D_wrapMode1_info(paramType, infoName, infoType);
      case 74:
         return ANARI_SAMPLER_image2D_wrapMode2_info(paramType, infoName, infoType);
      case 25:
         return ANARI_SAMPLER_image2D_inTransform_info(paramType, infoName, infoType);
      case 39:
         return ANARI_SAMPLER_image2D_outTransform_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE3D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 18;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_image_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array backing the sampler";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE3D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 18;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_inAttribute_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "input surface attribute (texture coordinate)";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE3D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 18;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_filter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "filter mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE3D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 18;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_wrapMode1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 1st dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE3D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 18;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_wrapMode2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 2nd dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE3D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 18;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_wrapMode3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "clampToEdge";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "wrap mode for the 3rd dimension";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"clampToEdge", "repeat", "mirrorRepeat", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE3D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 18;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_inTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the input attribute before sampling";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE3D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 18;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_outTransform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the sampled values";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE3D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 18;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_SAMPLER_image3D_name_info(paramType, infoName, infoType);
      case 22:
         return ANARI_SAMPLER_image3D_image_info(paramType, infoName, infoType);
      case 24:
         return ANARI_SAMPLER_image3D_inAttribute_info(paramType, infoName, infoType);
      case 15:
         return ANARI_SAMPLER_image3D_filter_info(paramType, infoName, infoType);
      case 73:
         return ANARI_SAMPLER_image3D_wrapMode1_info(paramType, infoName, infoType);
      case 74:
         return ANARI_SAMPLER_image3D_wrapMode2_info(paramType, infoName, infoType);
      case 75:
         return ANARI_SAMPLER_image3D_wrapMode3_info(paramType, infoName, infoType);
      case 25:
         return ANARI_SAMPLER_image3D_inTransform_info(paramType, infoName, infoType);
      case 39:
         return ANARI_SAMPLER_image3D_outTransform_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_PRIMITIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 19;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_array_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "backing array of the sampler";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_PRIMITIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 19;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_offset_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_UINT64 && infoType == ANARI_UINT64) {
            static const uint64_t default_value[1] = {UINT64_C(0)};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "offset added to primitiveId";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_PRIMITIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 19;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_SAMPLER_primitive_name_info(paramType, infoName, infoType);
      case 1:
         return ANARI_SAMPLER_primitive_array_info(paramType, infoName, infoType);
      case 34:
         return ANARI_SAMPLER_primitive_offset_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_TRANSFORM";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 20;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_inAttribute_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "attribute0";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "input surface attribute (texture coordinate)";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_TRANSFORM";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 20;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to the input attribute";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_TRANSFORM";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 20;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_SAMPLER_transform_name_info(paramType, infoName, infoType);
      case 24:
         return ANARI_SAMPLER_transform_inAttribute_info(paramType, infoName, infoType);
      case 59:
         return ANARI_SAMPLER_transform_transform_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 21;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_data_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of vertex centered scalar values";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT8, ANARI_INT16, ANARI_UINT16, ANARI_FLOAT32, ANARI_FLOAT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 21;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_origin_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "origin of the grid in object-space";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 21;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "size of the grid cells in object-space";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 21;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_filter_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "nearest";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "filter mode used to interpolate the grid";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"nearest", "linear", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 21;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_SPATIAL_FIELD_structuredRegular_name_info(paramType, infoName, infoType);
      case 10:
         return ANARI_SPATIAL_FIELD_structuredRegular_data_info(paramType, infoName, infoType);
      case 38:
         return ANARI_SPATIAL_FIELD_structuredRegular_origin_info(paramType, infoName, infoType);
      case 54:
         return ANARI_SPATIAL_FIELD_structuredRegular_spacing_info(paramType, infoName, infoType);
      case 15:
         return ANARI_SPATIAL_FIELD_structuredRegular_filter_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_VOLUME_SCIVIS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 22;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_field_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "spatial field used for the field values of the volume";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_VOLUME_SCIVIS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 22;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_valueRange_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX1 && infoType == ANARI_FLOAT32_BOX1) {
            static const float default_value[2] = {0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sampled values of field are clamped to this range";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_VOLUME_SCIVIS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 22;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array to map sampled and clamped field values to color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_VOLUME_SCIVIS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 22;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_color_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional array to position the elements of color values in valueRange";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_VOLUME_SCIVIS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 22;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_opacity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array to map sampled and clamped field values to opacity";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_VOLUME_SCIVIS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 22;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_opacity_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional array to position the elements of opacity values in valueRange";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_VOLUME_SCIVIS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 22;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_densityScale_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "makes volumes uniformly thinner or thicker";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_VOLUME_SCIVIS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 22;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 33:
         return ANARI_VOLUME_scivis_name_info(paramType, infoName, infoType);
      case 14:
         return ANARI_VOLUME_scivis_field_info(paramType, infoName, infoType);
      case 61:
         return ANARI_VOLUME_scivis_valueRange_info(paramType, infoName, infoType);
      case 8:
         return ANARI_VOLUME_scivis_color_info(paramType, infoName, infoType);
      case 9:
         return ANARI_VOLUME_scivis_color_position_info(paramType, infoName, infoType);
      case 35:
         return ANARI_VOLUME_scivis_opacity_info(paramType, infoName, infoType);
      case 36:
         return ANARI_VOLUME_scivis_opacity_position_info(paramType, infoName, infoType);
      case 11:
         return ANARI_VOLUME_scivis_densityScale_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 11:
         return ANARI_CAMERA_omnidirectional_param_info(paramName, paramType, infoName, infoType);
      case 12:
         return ANARI_CAMERA_orthographic_param_info(paramName, paramType, infoName, infoType);
      case 14:
         return ANARI_CAMERA_perspective_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 1:
         return ANARI_GEOMETRY_cone_param_info(paramName, paramType, infoName, infoType);
      case 2:
         return ANARI_GEOMETRY_curve_param_info(paramName, paramType, infoName, infoType);
      case 3:
         return ANARI_GEOMETRY_cylinder_param_info(paramName, paramType, infoName, infoType);
      case 17:
         return ANARI_GEOMETRY_quad_param_info(paramName, paramType, infoName, infoType);
      case 21:
         return ANARI_GEOMETRY_sphere_param_info(paramName, paramType, infoName, infoType);
      case 26:
         return ANARI_GEOMETRY_triangle_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 6:
         return ANARI_LIGHT_directional_param_info(paramName, paramType, infoName, infoType);
      case 15:
         return ANARI_LIGHT_point_param_info(paramName, paramType, infoName, infoType);
      case 22:
         return ANARI_LIGHT_spot_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 10:
         return ANARI_MATERIAL_matte_param_info(paramName, paramType, infoName, infoType);
      case 25:
         return ANARI_MATERIAL_transparentMatte_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 5:
         return ANARI_RENDERER_default_param_info(paramName, paramType, infoName, infoType);
      case 20:
         return ANARI_RENDERER_scivis_param_info(paramName, paramType, infoName, infoType);
      case 0:
         return ANARI_RENDERER_ao_param_info(paramName, paramType, infoName, infoType);
      case 13:
         return ANARI_RENDERER_pathtracer_param_info(paramName, paramType, infoName, infoType);
      case 4:
         return ANARI_RENDERER_debug_param_info(paramName, paramType, infoName, infoType);
      case 19:
         return ANARI_RENDERER_raycast_param_info(paramName, paramType, infoName, infoType);
      case 18:
         return ANARI_RENDERER_rayDir_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 7:
         return ANARI_SAMPLER_image1D_param_info(paramName, paramType, infoName, infoType);
      case 8:
         return ANARI_SAMPLER_image2D_param_info(paramName, paramType, infoName, infoType);
      case 9:
         return ANARI_SAMPLER_image3D_param_info(paramName, paramType, infoName, infoType);
      case 16:
         return ANARI_SAMPLER_primitive_param_info(paramName, paramType, infoName, infoType);
      case 24:
         return ANARI_SAMPLER_transform_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 23:
         return ANARI_SPATIAL_FIELD_structuredRegular_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_VOLUME_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 20:
         return ANARI_VOLUME_scivis_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_param_info_enum(ANARIDataType type, const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(type) {
      case ANARI_CAMERA:
         return ANARI_CAMERA_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_GEOMETRY:
         return ANARI_GEOMETRY_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_LIGHT:
         return ANARI_LIGHT_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_MATERIAL:
         return ANARI_MATERIAL_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_RENDERER:
         return ANARI_RENDERER_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_SAMPLER:
         return ANARI_SAMPLER_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_SPATIAL_FIELD:
         return ANARI_SPATIAL_FIELD_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_VOLUME:
         return ANARI_VOLUME_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_DEVICE:
         return ANARI_DEVICE_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY1D:
         return ANARI_ARRAY1D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY2D:
         return ANARI_ARRAY2D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY3D:
         return ANARI_ARRAY3D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_FRAME:
         return ANARI_FRAME_param_info(paramName, paramType, infoName, infoType);
      case ANARI_GROUP:
         return ANARI_GROUP_param_info(paramName, paramType, infoName, infoType);
      case ANARI_INSTANCE:
         return ANARI_INSTANCE_param_info(paramName, paramType, infoName, infoType);
      case ANARI_WORLD:
         return ANARI_WORLD_param_info(paramName, paramType, infoName, infoType);
      case ANARI_SURFACE:
         return ANARI_SURFACE_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_param_info(ANARIDataType type, const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoNameString, ANARIDataType infoType) {
   int infoName = info_hash(infoNameString);   return query_param_info_enum(type, subtype, paramName, paramType, infoName, infoType);}static const void * ANARI_RENDERER_default_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "default renderer";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"backgroundColor", ANARI_FLOAT32_VEC4},
               {"pixelSamples", ANARI_INT32},
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 0;
            return &value;
         } else {
            return nullptr;
         }
      case 8: // feature
         if(infoType == ANARI_STRING_LIST) {
            static const char *features[] = {
               "ANARI_example_device",
               "ANARI_CORE_OBJECTS",
               "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_LIGHT_DIRECTIONAL",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_LIGHT_SPOT",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_MATERIAL_TRANSPARENT_MATTE",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SAMPLER_IMAGE2D",
               "ANARI_KHR_SAMPLER_IMAGE3D",
               "ANARI_KHR_SAMPLER_PRIMITIVE",
               "ANARI_KHR_SAMPLER_TRANSFORM",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               "ANARI_KHR_VOLUME_SCIVIS",
               "ANARI_CORE_API",
               "ANARI_SPEC_ALL",
               "ANARI_KHR_FRAME_CONTINUATION",
               0
            };
            return features;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_scivis_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"backgroundColor", ANARI_FLOAT32_VEC4},
               {"pixelSamples", ANARI_INT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 0;
            return &value;
         } else {
            return nullptr;
         }
      case 8: // feature
         if(infoType == ANARI_STRING_LIST) {
            static const char *features[] = {
               "ANARI_example_device",
               "ANARI_CORE_OBJECTS",
               "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_LIGHT_DIRECTIONAL",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_LIGHT_SPOT",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_MATERIAL_TRANSPARENT_MATTE",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SAMPLER_IMAGE2D",
               "ANARI_KHR_SAMPLER_IMAGE3D",
               "ANARI_KHR_SAMPLER_PRIMITIVE",
               "ANARI_KHR_SAMPLER_TRANSFORM",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               "ANARI_KHR_VOLUME_SCIVIS",
               "ANARI_CORE_API",
               "ANARI_SPEC_ALL",
               "ANARI_KHR_FRAME_CONTINUATION",
               0
            };
            return features;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_ao_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"backgroundColor", ANARI_FLOAT32_VEC4},
               {"pixelSamples", ANARI_INT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 0;
            return &value;
         } else {
            return nullptr;
         }
      case 8: // feature
         if(infoType == ANARI_STRING_LIST) {
            static const char *features[] = {
               "ANARI_example_device",
               "ANARI_CORE_OBJECTS",
               "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_LIGHT_DIRECTIONAL",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_LIGHT_SPOT",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_MATERIAL_TRANSPARENT_MATTE",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SAMPLER_IMAGE2D",
               "ANARI_KHR_SAMPLER_IMAGE3D",
               "ANARI_KHR_SAMPLER_PRIMITIVE",
               "ANARI_KHR_SAMPLER_TRANSFORM",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               "ANARI_KHR_VOLUME_SCIVIS",
               "ANARI_CORE_API",
               "ANARI_SPEC_ALL",
               "ANARI_KHR_FRAME_CONTINUATION",
               0
            };
            return features;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_pathtracer_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"backgroundColor", ANARI_FLOAT32_VEC4},
               {"pixelSamples", ANARI_INT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 0;
            return &value;
         } else {
            return nullptr;
         }
      case 8: // feature
         if(infoType == ANARI_STRING_LIST) {
            static const char *features[] = {
               "ANARI_example_device",
               "ANARI_CORE_OBJECTS",
               "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_LIGHT_DIRECTIONAL",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_LIGHT_SPOT",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_MATERIAL_TRANSPARENT_MATTE",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SAMPLER_IMAGE2D",
               "ANARI_KHR_SAMPLER_IMAGE3D",
               "ANARI_KHR_SAMPLER_PRIMITIVE",
               "ANARI_KHR_SAMPLER_TRANSFORM",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               "ANARI_KHR_VOLUME_SCIVIS",
               "ANARI_CORE_API",
               "ANARI_SPEC_ALL",
               "ANARI_KHR_FRAME_CONTINUATION",
               0
            };
            return features;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_debug_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"backgroundColor", ANARI_FLOAT32_VEC4},
               {"pixelSamples", ANARI_INT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 0;
            return &value;
         } else {
            return nullptr;
         }
      case 8: // feature
         if(infoType == ANARI_STRING_LIST) {
            static const char *features[] = {
               "ANARI_example_device",
               "ANARI_CORE_OBJECTS",
               "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_LIGHT_DIRECTIONAL",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_LIGHT_SPOT",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_MATERIAL_TRANSPARENT_MATTE",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SAMPLER_IMAGE2D",
               "ANARI_KHR_SAMPLER_IMAGE3D",
               "ANARI_KHR_SAMPLER_PRIMITIVE",
               "ANARI_KHR_SAMPLER_TRANSFORM",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               "ANARI_KHR_VOLUME_SCIVIS",
               "ANARI_CORE_API",
               "ANARI_SPEC_ALL",
               "ANARI_KHR_FRAME_CONTINUATION",
               0
            };
            return features;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_raycast_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"backgroundColor", ANARI_FLOAT32_VEC4},
               {"pixelSamples", ANARI_INT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 0;
            return &value;
         } else {
            return nullptr;
         }
      case 8: // feature
         if(infoType == ANARI_STRING_LIST) {
            static const char *features[] = {
               "ANARI_example_device",
               "ANARI_CORE_OBJECTS",
               "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_LIGHT_DIRECTIONAL",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_LIGHT_SPOT",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_MATERIAL_TRANSPARENT_MATTE",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SAMPLER_IMAGE2D",
               "ANARI_KHR_SAMPLER_IMAGE3D",
               "ANARI_KHR_SAMPLER_PRIMITIVE",
               "ANARI_KHR_SAMPLER_TRANSFORM",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               "ANARI_KHR_VOLUME_SCIVIS",
               "ANARI_CORE_API",
               "ANARI_SPEC_ALL",
               "ANARI_KHR_FRAME_CONTINUATION",
               0
            };
            return features;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_rayDir_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"backgroundColor", ANARI_FLOAT32_VEC4},
               {"pixelSamples", ANARI_INT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "example_device";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 0;
            return &value;
         } else {
            return nullptr;
         }
      case 8: // feature
         if(infoType == ANARI_STRING_LIST) {
            static const char *features[] = {
               "ANARI_example_device",
               "ANARI_CORE_OBJECTS",
               "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_LIGHT_DIRECTIONAL",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_LIGHT_SPOT",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_MATERIAL_TRANSPARENT_MATTE",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SAMPLER_IMAGE2D",
               "ANARI_KHR_SAMPLER_IMAGE3D",
               "ANARI_KHR_SAMPLER_PRIMITIVE",
               "ANARI_KHR_SAMPLER_TRANSFORM",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               "ANARI_KHR_VOLUME_SCIVIS",
               "ANARI_CORE_API",
               "ANARI_SPEC_ALL",
               "ANARI_KHR_FRAME_CONTINUATION",
               0
            };
            return features;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "device object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"statusCallback", ANARI_STATUS_CALLBACK},
               {"statusCallbackUserData", ANARI_VOID_POINTER},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      case 8: // feature
         if(infoType == ANARI_STRING_LIST) {
            static const char *features[] = {
               "ANARI_example_device",
               "ANARI_CORE_OBJECTS",
               "ANARI_KHR_CAMERA_OMNIDIRECTIONAL",
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_CONE",
               "ANARI_KHR_GEOMETRY_CURVE",
               "ANARI_KHR_GEOMETRY_CYLINDER",
               "ANARI_KHR_GEOMETRY_QUAD",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_LIGHT_DIRECTIONAL",
               "ANARI_KHR_LIGHT_POINT",
               "ANARI_KHR_LIGHT_SPOT",
               "ANARI_KHR_MATERIAL_MATTE",
               "ANARI_KHR_MATERIAL_TRANSPARENT_MATTE",
               "ANARI_KHR_SAMPLER_IMAGE1D",
               "ANARI_KHR_SAMPLER_IMAGE2D",
               "ANARI_KHR_SAMPLER_IMAGE3D",
               "ANARI_KHR_SAMPLER_PRIMITIVE",
               "ANARI_KHR_SAMPLER_TRANSFORM",
               "ANARI_KHR_SPATIAL_FIELD_STRUCTURED_REGULAR",
               "ANARI_KHR_VOLUME_SCIVIS",
               "ANARI_CORE_API",
               "ANARI_SPEC_ALL",
               "ANARI_KHR_FRAME_CONTINUATION",
               0
            };
            return features;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY1D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "one dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY2D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "two dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY3D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "three dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "frame object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"world", ANARI_WORLD},
               {"renderer", ANARI_RENDERER},
               {"camera", ANARI_CAMERA},
               {"size", ANARI_UINT32_VEC2},
               {"channel.color", ANARI_DATA_TYPE},
               {"channel.depth", ANARI_DATA_TYPE},
               {"frameCompletionCallback", ANARI_FRAME_COMPLETION_CALLBACK},
               {"frameCompletionCallbackUserData", ANARI_VOID_POINTER},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      case 10: // channel
         if(infoType == ANARI_STRING_LIST) {
            static const char *channel[] = {
               "channel.color",
               "channel.depth",
               0
            };
            return channel;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "group object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"surface", ANARI_ARRAY1D},
               {"volume", ANARI_ARRAY1D},
               {"light", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "instance object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"transform", ANARI_FLOAT32_MAT4},
               {"group", ANARI_GROUP},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "world object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"instance", ANARI_ARRAY1D},
               {"surface", ANARI_ARRAY1D},
               {"volume", ANARI_ARRAY1D},
               {"light", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "surface object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"geometry", ANARI_GEOMETRY},
               {"material", ANARI_MATERIAL},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "CORE_OBJECTS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_omnidirectional_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "omnidirectional camera object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"transform", ANARI_FLOAT32_MAT4},
               {"imageRegion", ANARI_FLOAT32_BOX2},
               {"apertureRadius", ANARI_FLOAT32},
               {"focusDistance", ANARI_FLOAT32},
               {"stereoMode", ANARI_STRING},
               {"interpupillaryDistance", ANARI_FLOAT32},
               {"layout", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_OMNIDIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 2;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "orthographic camera object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"transform", ANARI_FLOAT32_MAT4},
               {"imageRegion", ANARI_FLOAT32_BOX2},
               {"apertureRadius", ANARI_FLOAT32},
               {"focusDistance", ANARI_FLOAT32},
               {"stereoMode", ANARI_STRING},
               {"interpupillaryDistance", ANARI_FLOAT32},
               {"aspect", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 3;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "perspective camera object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"transform", ANARI_FLOAT32_MAT4},
               {"imageRegion", ANARI_FLOAT32_BOX2},
               {"apertureRadius", ANARI_FLOAT32},
               {"focusDistance", ANARI_FLOAT32},
               {"stereoMode", ANARI_STRING},
               {"interpupillaryDistance", ANARI_FLOAT32},
               {"fovy", ANARI_FLOAT32},
               {"aspect", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 4;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cone_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "cone geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.radius", ANARI_ARRAY1D},
               {"vertex.cap", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"caps", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CONE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 5;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_curve_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "curve geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.radius", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"radius", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CURVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 6;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_cylinder_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "cylinder geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.cap", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"primitive.radius", ANARI_ARRAY1D},
               {"radius", ANARI_FLOAT32},
               {"caps", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_CYLINDER";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 7;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_quad_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "quad geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.normal", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_QUAD";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 8;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "sphere geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.radius", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"radius", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 9;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "triangle geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.normal", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 10;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_directional_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "directional light object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"irradiance", ANARI_FLOAT32},
               {"direction", ANARI_FLOAT32_VEC3},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_DIRECTIONAL";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 11;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_point_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "point light object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"position", ANARI_FLOAT32_VEC3},
               {"intensity", ANARI_FLOAT32},
               {"power", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_POINT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 12;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_LIGHT_spot_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "spot light object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"openingAngle", ANARI_FLOAT32},
               {"falloffAngle", ANARI_FLOAT32},
               {"intensity", ANARI_FLOAT32},
               {"power", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_LIGHT_SPOT";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 13;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "matte material object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"color", ANARI_SAMPLER},
               {"color", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 14;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_transparentMatte_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "transparent matte material object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"color", ANARI_SAMPLER},
               {"color", ANARI_STRING},
               {"opacity", ANARI_FLOAT32},
               {"opacity", ANARI_SAMPLER},
               {"opacity", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_TRANSPARENT_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 15;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image1D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "image1D object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"image", ANARI_ARRAY1D},
               {"inAttribute", ANARI_STRING},
               {"filter", ANARI_STRING},
               {"wrapMode1", ANARI_STRING},
               {"inTransform", ANARI_FLOAT32_MAT4},
               {"outTransform", ANARI_FLOAT32_MAT4},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE1D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 16;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image2D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "image2D object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"image", ANARI_ARRAY2D},
               {"inAttribute", ANARI_STRING},
               {"filter", ANARI_STRING},
               {"wrapMode1", ANARI_STRING},
               {"wrapMode2", ANARI_STRING},
               {"inTransform", ANARI_FLOAT32_MAT4},
               {"outTransform", ANARI_FLOAT32_MAT4},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE2D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 17;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_image3D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "image3D object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"image", ANARI_ARRAY3D},
               {"inAttribute", ANARI_STRING},
               {"filter", ANARI_STRING},
               {"wrapMode1", ANARI_STRING},
               {"wrapMode2", ANARI_STRING},
               {"wrapMode3", ANARI_STRING},
               {"inTransform", ANARI_FLOAT32_MAT4},
               {"outTransform", ANARI_FLOAT32_MAT4},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_IMAGE3D";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 18;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_primitive_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "primitive sampler object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"array", ANARI_ARRAY1D},
               {"offset", ANARI_UINT64},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_PRIMITIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 19;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SAMPLER_transform_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "transform sampler object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"inAttribute", ANARI_STRING},
               {"transform", ANARI_FLOAT32_MAT4},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SAMPLER_TRANSFORM";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 20;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_structuredRegular_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "structured regular spatial field object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"data", ANARI_ARRAY3D},
               {"origin", ANARI_FLOAT32_VEC3},
               {"spacing", ANARI_FLOAT32_VEC3},
               {"filter", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_SPATIAL_FIELD_STRUCTURED_REGULAR";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 21;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_VOLUME_scivis_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "scivis volume object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"field", ANARI_SPATIAL_FIELD},
               {"valueRange", ANARI_FLOAT32_BOX1},
               {"color", ANARI_ARRAY1D},
               {"color.position", ANARI_ARRAY1D},
               {"opacity", ANARI_ARRAY1D},
               {"opacity.position", ANARI_ARRAY1D},
               {"densityScale", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_VOLUME_SCIVIS";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 22;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 11:
         return ANARI_CAMERA_omnidirectional_info(infoName, infoType);
      case 12:
         return ANARI_CAMERA_orthographic_info(infoName, infoType);
      case 14:
         return ANARI_CAMERA_perspective_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 1:
         return ANARI_GEOMETRY_cone_info(infoName, infoType);
      case 2:
         return ANARI_GEOMETRY_curve_info(infoName, infoType);
      case 3:
         return ANARI_GEOMETRY_cylinder_info(infoName, infoType);
      case 17:
         return ANARI_GEOMETRY_quad_info(infoName, infoType);
      case 21:
         return ANARI_GEOMETRY_sphere_info(infoName, infoType);
      case 26:
         return ANARI_GEOMETRY_triangle_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_LIGHT_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 6:
         return ANARI_LIGHT_directional_info(infoName, infoType);
      case 15:
         return ANARI_LIGHT_point_info(infoName, infoType);
      case 22:
         return ANARI_LIGHT_spot_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 10:
         return ANARI_MATERIAL_matte_info(infoName, infoType);
      case 25:
         return ANARI_MATERIAL_transparentMatte_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 5:
         return ANARI_RENDERER_default_info(infoName, infoType);
      case 20:
         return ANARI_RENDERER_scivis_info(infoName, infoType);
      case 0:
         return ANARI_RENDERER_ao_info(infoName, infoType);
      case 13:
         return ANARI_RENDERER_pathtracer_info(infoName, infoType);
      case 4:
         return ANARI_RENDERER_debug_info(infoName, infoType);
      case 19:
         return ANARI_RENDERER_raycast_info(infoName, infoType);
      case 18:
         return ANARI_RENDERER_rayDir_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SAMPLER_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 7:
         return ANARI_SAMPLER_image1D_info(infoName, infoType);
      case 8:
         return ANARI_SAMPLER_image2D_info(infoName, infoType);
      case 9:
         return ANARI_SAMPLER_image3D_info(infoName, infoType);
      case 16:
         return ANARI_SAMPLER_primitive_info(infoName, infoType);
      case 24:
         return ANARI_SAMPLER_transform_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SPATIAL_FIELD_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 23:
         return ANARI_SPATIAL_FIELD_structuredRegular_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_VOLUME_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 20:
         return ANARI_VOLUME_scivis_info(infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_object_info_enum(ANARIDataType type, const char *subtype, int infoName, ANARIDataType infoType) {
   switch(type) {
      case ANARI_CAMERA:
         return ANARI_CAMERA_info(subtype, infoName, infoType);
      case ANARI_GEOMETRY:
         return ANARI_GEOMETRY_info(subtype, infoName, infoType);
      case ANARI_LIGHT:
         return ANARI_LIGHT_info(subtype, infoName, infoType);
      case ANARI_MATERIAL:
         return ANARI_MATERIAL_info(subtype, infoName, infoType);
      case ANARI_RENDERER:
         return ANARI_RENDERER_info(subtype, infoName, infoType);
      case ANARI_SAMPLER:
         return ANARI_SAMPLER_info(subtype, infoName, infoType);
      case ANARI_SPATIAL_FIELD:
         return ANARI_SPATIAL_FIELD_info(subtype, infoName, infoType);
      case ANARI_VOLUME:
         return ANARI_VOLUME_info(subtype, infoName, infoType);
      case ANARI_DEVICE:
         return ANARI_DEVICE_info(infoName, infoType);
      case ANARI_ARRAY1D:
         return ANARI_ARRAY1D_info(infoName, infoType);
      case ANARI_ARRAY2D:
         return ANARI_ARRAY2D_info(infoName, infoType);
      case ANARI_ARRAY3D:
         return ANARI_ARRAY3D_info(infoName, infoType);
      case ANARI_FRAME:
         return ANARI_FRAME_info(infoName, infoType);
      case ANARI_GROUP:
         return ANARI_GROUP_info(infoName, infoType);
      case ANARI_INSTANCE:
         return ANARI_INSTANCE_info(infoName, infoType);
      case ANARI_WORLD:
         return ANARI_WORLD_info(infoName, infoType);
      case ANARI_SURFACE:
         return ANARI_SURFACE_info(infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_object_info(ANARIDataType type, const char *subtype, const char *infoNameString, ANARIDataType infoType) {
   int infoName = info_hash(infoNameString);   return query_object_info_enum(type, subtype, infoName, infoType);}
}
}
