// Copyright 2021 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_debug_objects.py
// Don't make changes to this directly

#include "anari/ext/debug/DebugObject.h"
using namespace anari::debug_device;
namespace anari_sdk {
namespace tree {
class TreeDebugFactory : public anari::debug_device::ObjectFactory {
public:
anari::debug_device::DebugObjectBase* new_camera(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_geometry(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_light(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_material(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_renderer(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_sampler(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_spatial_field(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_volume(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_device(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_array1d(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_array2d(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_array3d(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_frame(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_group(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_instance(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_world(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_surface(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   void print_summary(anari::debug_device::DebugDevice *td) override;
   void use_feature(int feature);
};
namespace {
class device : public DebugObject<ANARI_DEVICE> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610006u,0x0u,0x0u,0x0u,0x0u,0x7574000au,0x6e6d0007u,0x66650008u,0x1000009u,0x80000000u,0x6261000bu,0x7574000cu,0x7675000du,0x7473000eu,0x4443000fu,0x62610010u,0x6d6c0011u,0x6d6c0012u,0x63620013u,0x62610014u,0x64630015u,0x6c6b0016u,0x56000017u,0x80000001u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7473006du,0x6665006eu,0x7372006fu,0x45440070u,0x62610071u,0x75740072u,0x62610073u,0x1000074u,0x80000002u};
      uint32_t cur = 0x746e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   device(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //statusCallback
            ANARIDataType statusCallback_types[] = {ANARI_STATUS_CALLBACK, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, statusCallback_types);
            return;
         }
         case 2: { //statusCallbackUserData
            ANARIDataType statusCallbackUserData_types[] = {ANARI_VOID_POINTER, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, statusCallbackUserData_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_DEVICE, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class array1d : public DebugObject<ANARI_ARRAY1D> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610005u,0x0u,0x0u,0x0u,0x66650009u,0x6e6d0006u,0x66650007u,0x1000008u,0x80000000u,0x6867000au,0x6a69000bu,0x706f000cu,0x6f6e000du,0x100000eu,0x80000001u};
      uint32_t cur = 0x736e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   array1d(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_ARRAY1D, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //region
            ANARIDataType region_types[] = {ANARI_UINT64_REGION1, ANARI_UNKNOWN};
            check_type(ANARI_ARRAY1D, "", paramname, paramtype, region_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_ARRAY1D, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class array2d : public DebugObject<ANARI_ARRAY2D> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   array2d(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_ARRAY2D, "", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_ARRAY2D, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class array3d : public DebugObject<ANARI_ARRAY3D> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   array3d(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_ARRAY3D, "", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_ARRAY3D, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class frame : public DebugObject<ANARI_FRAME> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x64630017u,0x0u,0x69610023u,0x0u,0x0u,0x7372005au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100ceu,0x0u,0x0u,0x0u,0x666500d2u,0x6a6900dau,0x0u,0x0u,0x626100deu,0x706f00e6u,0x64630018u,0x76750019u,0x6e6d001au,0x7675001bu,0x6d6c001cu,0x6261001du,0x7574001eu,0x6a69001fu,0x706f0020u,0x6f6e0021u,0x1000022u,0x8000000bu,0x6e6d002bu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610030u,0x6665002cu,0x7372002du,0x6261002eu,0x100002fu,0x80000003u,0x6f6e0031u,0x6f6e0032u,0x66650033u,0x6d6c0034u,0x2f2e0035u,0x6f610036u,0x6d6c0044u,0x0u,0x706f004au,0x6665004fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0054u,0x63620045u,0x66650046u,0x65640047u,0x706f0048u,0x1000049u,0x8000000au,0x6d6c004bu,0x706f004cu,0x7372004du,0x100004eu,0x80000005u,0x71700050u,0x75740051u,0x69680052u,0x1000053u,0x80000006u,0x73720055u,0x6e6d0056u,0x62610057u,0x6d6c0058u,0x1000059u,0x80000009u,0x6261005bu,0x6e6d005cu,0x6665005du,0x4443005eu,0x706f005fu,0x6e6d0060u,0x71700061u,0x6d6c0062u,0x66650063u,0x75740064u,0x6a690065u,0x706f0066u,0x6f6e0067u,0x44430068u,0x62610069u,0x6d6c006au,0x6d6c006bu,0x6362006cu,0x6261006du,0x6463006eu,0x6c6b006fu,0x56000070u,0x80000007u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x747300c6u,0x666500c7u,0x737200c8u,0x454400c9u,0x626100cau,0x757400cbu,0x626100ccu,0x10000cdu,0x80000008u,0x6e6d00cfu,0x666500d0u,0x10000d1u,0x80000000u,0x6f6e00d3u,0x656400d4u,0x666500d5u,0x737200d6u,0x666500d7u,0x737200d8u,0x10000d9u,0x80000002u,0x7b7a00dbu,0x666500dcu,0x10000ddu,0x80000004u,0x737200dfu,0x6a6900e0u,0x626100e1u,0x6f6e00e2u,0x646300e3u,0x666500e4u,0x10000e5u,0x8000000cu,0x737200e7u,0x6d6c00e8u,0x656400e9u,0x10000eau,0x80000001u};
      uint32_t cur = 0x78610000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   frame(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //world
            ANARIDataType world_types[] = {ANARI_WORLD, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, world_types);
            return;
         }
         case 2: { //renderer
            ANARIDataType renderer_types[] = {ANARI_RENDERER, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, renderer_types);
            return;
         }
         case 3: { //camera
            ANARIDataType camera_types[] = {ANARI_CAMERA, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, camera_types);
            return;
         }
         case 4: { //size
            ANARIDataType size_types[] = {ANARI_UINT32_VEC2, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, size_types);
            return;
         }
         case 5: { //channel.color
            ANARIDataType channel_color_types[] = {ANARI_DATA_TYPE, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, channel_color_types);
            return;
         }
         case 6: { //channel.depth
            ANARIDataType channel_depth_types[] = {ANARI_DATA_TYPE, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, channel_depth_types);
            return;
         }
         case 7: { //frameCompletionCallback
            ANARIDataType frameCompletionCallback_types[] = {ANARI_FRAME_COMPLETION_CALLBACK, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, frameCompletionCallback_types);
            return;
         }
         case 8: { //frameCompletionCallbackUserData
            ANARIDataType frameCompletionCallbackUserData_types[] = {ANARI_VOID_POINTER, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, frameCompletionCallbackUserData_types);
            return;
         }
         case 9: { //channel.normal
            ANARIDataType channel_normal_types[] = {ANARI_DATA_TYPE, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, channel_normal_types);
            return;
         }
         case 10: { //channel.albedo
            ANARIDataType channel_albedo_types[] = {ANARI_DATA_TYPE, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, channel_albedo_types);
            return;
         }
         case 11: { //accumulation
            ANARIDataType accumulation_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, accumulation_types);
            return;
         }
         case 12: { //variance
            ANARIDataType variance_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, variance_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_FRAME, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class group : public DebugObject<ANARI_GROUP> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6a69000bu,0x0u,0x62610010u,0x0u,0x0u,0x0u,0x0u,0x76750014u,0x0u,0x0u,0x706f001bu,0x6867000cu,0x6968000du,0x7574000eu,0x100000fu,0x80000003u,0x6e6d0011u,0x66650012u,0x1000013u,0x80000000u,0x73720015u,0x67660016u,0x62610017u,0x64630018u,0x66650019u,0x100001au,0x80000001u,0x6d6c001cu,0x7675001du,0x6e6d001eu,0x6665001fu,0x1000020u,0x80000002u};
      uint32_t cur = 0x776c0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   group(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //surface
            ANARIDataType surface_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, surface_types);
            return;
         }
         case 2: { //volume
            ANARIDataType volume_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, volume_types);
            return;
         }
         case 3: { //light
            ANARIDataType light_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, light_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GROUP, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class instance : public DebugObject<ANARI_INSTANCE> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x7372000eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0013u,0x6261003eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x73690042u,0x706f000fu,0x76750010u,0x71700011u,0x1000012u,0x80000002u,0x75740014u,0x6a690015u,0x706f0016u,0x6f6e0017u,0x2f2e0018u,0x75720019u,0x706f001cu,0x64630024u,0x73720029u,0x7574001du,0x6261001eu,0x7574001fu,0x6a690020u,0x706f0021u,0x6f6e0022u,0x1000023u,0x80000005u,0x62610025u,0x6d6c0026u,0x66650027u,0x1000028u,0x80000004u,0x6261002au,0x6f6e002bu,0x7473002cu,0x6d66002du,0x706f0034u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610038u,0x73720035u,0x6e6d0036u,0x1000037u,0x80000003u,0x75740039u,0x6a69003au,0x706f003bu,0x6f6e003cu,0x100003du,0x80000006u,0x6e6d003fu,0x66650040u,0x1000041u,0x80000000u,0x6e6d004cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261004fu,0x6665004du,0x100004eu,0x80000007u,0x6f6e0050u,0x74730051u,0x67660052u,0x706f0053u,0x73720054u,0x6e6d0055u,0x1000056u,0x80000001u};
      uint32_t cur = 0x75670000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   instance(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //transform
            ANARIDataType transform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, transform_types);
            return;
         }
         case 2: { //group
            ANARIDataType group_types[] = {ANARI_GROUP, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, group_types);
            return;
         }
         case 3: { //motion.transform
            ANARIDataType motion_transform_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, motion_transform_types);
            return;
         }
         case 4: { //motion.scale
            ANARIDataType motion_scale_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, motion_scale_types);
            return;
         }
         case 5: { //motion.rotation
            ANARIDataType motion_rotation_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, motion_rotation_types);
            return;
         }
         case 6: { //motion.translation
            ANARIDataType motion_translation_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, motion_translation_types);
            return;
         }
         case 7: { //time
            ANARIDataType time_types[] = {ANARI_FLOAT32_BOX1, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, time_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_INSTANCE, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class world : public DebugObject<ANARI_WORLD> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6f6e000eu,0x0u,0x0u,0x6a690016u,0x0u,0x6261001bu,0x0u,0x0u,0x0u,0x0u,0x7675001fu,0x0u,0x0u,0x706f0026u,0x7473000fu,0x75740010u,0x62610011u,0x6f6e0012u,0x64630013u,0x66650014u,0x1000015u,0x80000001u,0x68670017u,0x69680018u,0x75740019u,0x100001au,0x80000004u,0x6e6d001cu,0x6665001du,0x100001eu,0x80000000u,0x73720020u,0x67660021u,0x62610022u,0x64630023u,0x66650024u,0x1000025u,0x80000002u,0x6d6c0027u,0x76750028u,0x6e6d0029u,0x6665002au,0x100002bu,0x80000003u};
      uint32_t cur = 0x77690000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   world(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //instance
            ANARIDataType instance_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, instance_types);
            return;
         }
         case 2: { //surface
            ANARIDataType surface_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, surface_types);
            return;
         }
         case 3: { //volume
            ANARIDataType volume_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, volume_types);
            return;
         }
         case 4: { //light
            ANARIDataType light_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, light_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_WORLD, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class renderer_default : public DebugObject<ANARI_RENDERER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   renderer_default(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_RENDERER, "default", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_RENDERER, "default", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "default";
   }
};
class surface : public DebugObject<ANARI_SURFACE> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x66650008u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610010u,0x62610018u,0x706f0009u,0x6e6d000au,0x6665000bu,0x7574000cu,0x7372000du,0x7a79000eu,0x100000fu,0x80000001u,0x75740011u,0x66650012u,0x73720013u,0x6a690014u,0x62610015u,0x6d6c0016u,0x1000017u,0x80000002u,0x6e6d0019u,0x6665001au,0x100001bu,0x80000000u};
      uint32_t cur = 0x6f670000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   surface(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SURFACE, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //geometry
            ANARIDataType geometry_types[] = {ANARI_GEOMETRY, ANARI_UNKNOWN};
            check_type(ANARI_SURFACE, "", paramname, paramtype, geometry_types);
            return;
         }
         case 2: { //material
            ANARIDataType material_types[] = {ANARI_MATERIAL, ANARI_UNKNOWN};
            check_type(ANARI_SURFACE, "", paramname, paramtype, material_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SURFACE, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class camera_omnidirectional : public DebugObject<ANARI_CAMERA> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x71700015u,0x0u,0x0u,0x6a690023u,0x0u,0x706f002cu,0x0u,0x0u,0x6f6d0039u,0x0u,0x0u,0x6261005au,0x706f0060u,0x6261008bu,0x0u,0x706f008fu,0x0u,0x0u,0x75680097u,0x736900b3u,0x717000c8u,0x66650016u,0x73720017u,0x75740018u,0x76750019u,0x7372001au,0x6665001bu,0x5352001cu,0x6261001du,0x6564001eu,0x6a69001fu,0x76750020u,0x74730021u,0x1000022u,0x80000006u,0x73720024u,0x66650025u,0x64630026u,0x75740027u,0x6a690028u,0x706f0029u,0x6f6e002au,0x100002bu,0x80000002u,0x6463002du,0x7675002eu,0x7473002fu,0x45440030u,0x6a690031u,0x74730032u,0x75740033u,0x62610034u,0x6f6e0035u,0x64630036u,0x66650037u,0x1000038u,0x80000007u,0x6261003bu,0x75740045u,0x6867003cu,0x6665003du,0x5352003eu,0x6665003fu,0x68670040u,0x6a690041u,0x706f0042u,0x6f6e0043u,0x1000044u,0x80000005u,0x66650046u,0x73720047u,0x71700048u,0x76750049u,0x7170004au,0x6a69004bu,0x6d6c004cu,0x6d6c004du,0x6261004eu,0x7372004fu,0x7a790050u,0x45440051u,0x6a690052u,0x74730053u,0x75740054u,0x62610055u,0x6f6e0056u,0x64630057u,0x66650058u,0x1000059u,0x80000009u,0x7a79005bu,0x706f005cu,0x7675005du,0x7574005eu,0x100005fu,0x8000000au,0x75740061u,0x6a690062u,0x706f0063u,0x6f6e0064u,0x2f2e0065u,0x75720066u,0x706f0069u,0x64630071u,0x73720076u,0x7574006au,0x6261006bu,0x7574006cu,0x6a69006du,0x706f006eu,0x6f6e006fu,0x1000070u,0x8000000du,0x62610072u,0x6d6c0073u,0x66650074u,0x1000075u,0x8000000cu,0x62610077u,0x6f6e0078u,0x74730079u,0x6d66007au,0x706f0081u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610085u,0x73720082u,0x6e6d0083u,0x1000084u,0x8000000bu,0x75740086u,0x6a690087u,0x706f0088u,0x6f6e0089u,0x100008au,0x8000000eu,0x6e6d008cu,0x6665008du,0x100008eu,0x80000000u,0x74730090u,0x6a690091u,0x75740092u,0x6a690093u,0x706f0094u,0x6f6e0095u,0x1000096u,0x80000001u,0x767500a4u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666500aau,0x757400a5u,0x757400a6u,0x666500a7u,0x737200a8u,0x10000a9u,0x80000010u,0x737200abu,0x666500acu,0x706f00adu,0x4e4d00aeu,0x706f00afu,0x656400b0u,0x666500b1u,0x10000b2u,0x80000008u,0x6e6d00bdu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100c0u,0x666500beu,0x10000bfu,0x8000000fu,0x6f6e00c1u,0x747300c2u,0x676600c3u,0x706f00c4u,0x737200c5u,0x6e6d00c6u,0x10000c7u,0x80000004u,0x10000c9u,0x80000003u};
      uint32_t cur = 0x76610000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   camera_omnidirectional(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, name_types);
            return;
         }
         case 1: { //position
            ANARIDataType position_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, position_types);
            return;
         }
         case 2: { //direction
            ANARIDataType direction_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, direction_types);
            return;
         }
         case 3: { //up
            ANARIDataType up_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, up_types);
            return;
         }
         case 4: { //transform
            ANARIDataType transform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, transform_types);
            return;
         }
         case 5: { //imageRegion
            ANARIDataType imageRegion_types[] = {ANARI_FLOAT32_BOX2, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, imageRegion_types);
            return;
         }
         case 6: { //apertureRadius
            ANARIDataType apertureRadius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, apertureRadius_types);
            return;
         }
         case 7: { //focusDistance
            ANARIDataType focusDistance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, focusDistance_types);
            return;
         }
         case 8: { //stereoMode
            ANARIDataType stereoMode_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, stereoMode_types);
            return;
         }
         case 9: { //interpupillaryDistance
            ANARIDataType interpupillaryDistance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, interpupillaryDistance_types);
            return;
         }
         case 10: { //layout
            ANARIDataType layout_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, layout_types);
            return;
         }
         case 11: { //motion.transform
            ANARIDataType motion_transform_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, motion_transform_types);
            return;
         }
         case 12: { //motion.scale
            ANARIDataType motion_scale_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, motion_scale_types);
            return;
         }
         case 13: { //motion.rotation
            ANARIDataType motion_rotation_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, motion_rotation_types);
            return;
         }
         case 14: { //motion.translation
            ANARIDataType motion_translation_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, motion_translation_types);
            return;
         }
         case 15: { //time
            ANARIDataType time_types[] = {ANARI_FLOAT32_BOX1, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, time_types);
            return;
         }
         case 16: { //shutter
            ANARIDataType shutter_types[] = {ANARI_FLOAT32_BOX1, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "omnidirectional", paramname, paramtype, shutter_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_CAMERA, "omnidirectional", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "omnidirectional";
   }
};
class camera_orthographic : public DebugObject<ANARI_CAMERA> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x74700015u,0x0u,0x0u,0x6a69002bu,0x0u,0x70610034u,0x0u,0x66650051u,0x6f6d0057u,0x0u,0x0u,0x0u,0x706f0078u,0x666100a3u,0x0u,0x706f00aeu,0x0u,0x0u,0x756800b6u,0x736900d2u,0x717000e7u,0x66650019u,0x0u,0x0u,0x71700026u,0x7372001au,0x7574001bu,0x7675001cu,0x7372001du,0x6665001eu,0x5352001fu,0x62610020u,0x65640021u,0x6a690022u,0x76750023u,0x74730024u,0x1000025u,0x80000006u,0x66650027u,0x64630028u,0x75740029u,0x100002au,0x8000000bu,0x7372002cu,0x6665002du,0x6463002eu,0x7574002fu,0x6a690030u,0x706f0031u,0x6f6e0032u,0x1000033u,0x80000002u,0x73720043u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x64630045u,0x1000044u,0x8000000du,0x76750046u,0x74730047u,0x45440048u,0x6a690049u,0x7473004au,0x7574004bu,0x6261004cu,0x6f6e004du,0x6463004eu,0x6665004fu,0x1000050u,0x80000007u,0x6a690052u,0x68670053u,0x69680054u,0x75740055u,0x1000056u,0x8000000au,0x62610059u,0x75740063u,0x6867005au,0x6665005bu,0x5352005cu,0x6665005du,0x6867005eu,0x6a69005fu,0x706f0060u,0x6f6e0061u,0x1000062u,0x80000005u,0x66650064u,0x73720065u,0x71700066u,0x76750067u,0x71700068u,0x6a690069u,0x6d6c006au,0x6d6c006bu,0x6261006cu,0x7372006du,0x7a79006eu,0x4544006fu,0x6a690070u,0x74730071u,0x75740072u,0x62610073u,0x6f6e0074u,0x64630075u,0x66650076u,0x1000077u,0x80000009u,0x75740079u,0x6a69007au,0x706f007bu,0x6f6e007cu,0x2f2e007du,0x7572007eu,0x706f0081u,0x64630089u,0x7372008eu,0x75740082u,0x62610083u,0x75740084u,0x6a690085u,0x706f0086u,0x6f6e0087u,0x1000088u,0x80000010u,0x6261008au,0x6d6c008bu,0x6665008cu,0x100008du,0x8000000fu,0x6261008fu,0x6f6e0090u,0x74730091u,0x6d660092u,0x706f0099u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261009du,0x7372009au,0x6e6d009bu,0x100009cu,0x8000000eu,0x7574009eu,0x6a69009fu,0x706f00a0u,0x6f6e00a1u,0x10000a2u,0x80000011u,0x6e6d00a8u,0x0u,0x0u,0x0u,0x626100abu,0x666500a9u,0x10000aau,0x80000000u,0x737200acu,0x10000adu,0x8000000cu,0x747300afu,0x6a6900b0u,0x757400b1u,0x6a6900b2u,0x706f00b3u,0x6f6e00b4u,0x10000b5u,0x80000001u,0x767500c3u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666500c9u,0x757400c4u,0x757400c5u,0x666500c6u,0x737200c7u,0x10000c8u,0x80000013u,0x737200cau,0x666500cbu,0x706f00ccu,0x4e4d00cdu,0x706f00ceu,0x656400cfu,0x666500d0u,0x10000d1u,0x80000008u,0x6e6d00dcu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100dfu,0x666500ddu,0x10000deu,0x80000012u,0x6f6e00e0u,0x747300e1u,0x676600e2u,0x706f00e3u,0x737200e4u,0x6e6d00e5u,0x10000e6u,0x80000004u,0x10000e8u,0x80000003u};
      uint32_t cur = 0x76610000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   camera_orthographic(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, name_types);
            return;
         }
         case 1: { //position
            ANARIDataType position_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, position_types);
            return;
         }
         case 2: { //direction
            ANARIDataType direction_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, direction_types);
            return;
         }
         case 3: { //up
            ANARIDataType up_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, up_types);
            return;
         }
         case 4: { //transform
            ANARIDataType transform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, transform_types);
            return;
         }
         case 5: { //imageRegion
            ANARIDataType imageRegion_types[] = {ANARI_FLOAT32_BOX2, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, imageRegion_types);
            return;
         }
         case 6: { //apertureRadius
            ANARIDataType apertureRadius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, apertureRadius_types);
            return;
         }
         case 7: { //focusDistance
            ANARIDataType focusDistance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, focusDistance_types);
            return;
         }
         case 8: { //stereoMode
            ANARIDataType stereoMode_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, stereoMode_types);
            return;
         }
         case 9: { //interpupillaryDistance
            ANARIDataType interpupillaryDistance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, interpupillaryDistance_types);
            return;
         }
         case 10: { //height
            ANARIDataType height_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, height_types);
            return;
         }
         case 11: { //aspect
            ANARIDataType aspect_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, aspect_types);
            return;
         }
         case 12: { //near
            ANARIDataType near_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, near_types);
            return;
         }
         case 13: { //far
            ANARIDataType far_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, far_types);
            return;
         }
         case 14: { //motion.transform
            ANARIDataType motion_transform_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, motion_transform_types);
            return;
         }
         case 15: { //motion.scale
            ANARIDataType motion_scale_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, motion_scale_types);
            return;
         }
         case 16: { //motion.rotation
            ANARIDataType motion_rotation_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, motion_rotation_types);
            return;
         }
         case 17: { //motion.translation
            ANARIDataType motion_translation_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, motion_translation_types);
            return;
         }
         case 18: { //time
            ANARIDataType time_types[] = {ANARI_FLOAT32_BOX1, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, time_types);
            return;
         }
         case 19: { //shutter
            ANARIDataType shutter_types[] = {ANARI_FLOAT32_BOX1, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, shutter_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_CAMERA, "orthographic", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "orthographic";
   }
};
class camera_perspective : public DebugObject<ANARI_CAMERA> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x74700015u,0x0u,0x0u,0x6a69002bu,0x0u,0x70610034u,0x0u,0x0u,0x6f6d0066u,0x0u,0x0u,0x0u,0x706f0087u,0x666100b2u,0x0u,0x706f00bdu,0x0u,0x0u,0x756800c5u,0x736900e1u,0x717000f6u,0x66650019u,0x0u,0x0u,0x71700026u,0x7372001au,0x7574001bu,0x7675001cu,0x7372001du,0x6665001eu,0x5352001fu,0x62610020u,0x65640021u,0x6a690022u,0x76750023u,0x74730024u,0x1000025u,0x80000006u,0x66650027u,0x64630028u,0x75740029u,0x100002au,0x8000000bu,0x7372002cu,0x6665002du,0x6463002eu,0x7574002fu,0x6a690030u,0x706f0031u,0x6f6e0032u,0x1000033u,0x80000002u,0x73720043u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x77630045u,0x1000044u,0x8000000du,0x76750059u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7a790064u,0x7473005au,0x4544005bu,0x6a69005cu,0x7473005du,0x7574005eu,0x6261005fu,0x6f6e0060u,0x64630061u,0x66650062u,0x1000063u,0x80000007u,0x1000065u,0x8000000au,0x62610068u,0x75740072u,0x68670069u,0x6665006au,0x5352006bu,0x6665006cu,0x6867006du,0x6a69006eu,0x706f006fu,0x6f6e0070u,0x1000071u,0x80000005u,0x66650073u,0x73720074u,0x71700075u,0x76750076u,0x71700077u,0x6a690078u,0x6d6c0079u,0x6d6c007au,0x6261007bu,0x7372007cu,0x7a79007du,0x4544007eu,0x6a69007fu,0x74730080u,0x75740081u,0x62610082u,0x6f6e0083u,0x64630084u,0x66650085u,0x1000086u,0x80000009u,0x75740088u,0x6a690089u,0x706f008au,0x6f6e008bu,0x2f2e008cu,0x7572008du,0x706f0090u,0x64630098u,0x7372009du,0x75740091u,0x62610092u,0x75740093u,0x6a690094u,0x706f0095u,0x6f6e0096u,0x1000097u,0x80000010u,0x62610099u,0x6d6c009au,0x6665009bu,0x100009cu,0x8000000fu,0x6261009eu,0x6f6e009fu,0x747300a0u,0x6d6600a1u,0x706f00a8u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100acu,0x737200a9u,0x6e6d00aau,0x10000abu,0x8000000eu,0x757400adu,0x6a6900aeu,0x706f00afu,0x6f6e00b0u,0x10000b1u,0x80000011u,0x6e6d00b7u,0x0u,0x0u,0x0u,0x626100bau,0x666500b8u,0x10000b9u,0x80000000u,0x737200bbu,0x10000bcu,0x8000000cu,0x747300beu,0x6a6900bfu,0x757400c0u,0x6a6900c1u,0x706f00c2u,0x6f6e00c3u,0x10000c4u,0x80000001u,0x767500d2u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666500d8u,0x757400d3u,0x757400d4u,0x666500d5u,0x737200d6u,0x10000d7u,0x80000013u,0x737200d9u,0x666500dau,0x706f00dbu,0x4e4d00dcu,0x706f00ddu,0x656400deu,0x666500dfu,0x10000e0u,0x80000008u,0x6e6d00ebu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100eeu,0x666500ecu,0x10000edu,0x80000012u,0x6f6e00efu,0x747300f0u,0x676600f1u,0x706f00f2u,0x737200f3u,0x6e6d00f4u,0x10000f5u,0x80000004u,0x10000f7u,0x80000003u};
      uint32_t cur = 0x76610000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   camera_perspective(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, name_types);
            return;
         }
         case 1: { //position
            ANARIDataType position_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, position_types);
            return;
         }
         case 2: { //direction
            ANARIDataType direction_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, direction_types);
            return;
         }
         case 3: { //up
            ANARIDataType up_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, up_types);
            return;
         }
         case 4: { //transform
            ANARIDataType transform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, transform_types);
            return;
         }
         case 5: { //imageRegion
            ANARIDataType imageRegion_types[] = {ANARI_FLOAT32_BOX2, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, imageRegion_types);
            return;
         }
         case 6: { //apertureRadius
            ANARIDataType apertureRadius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, apertureRadius_types);
            return;
         }
         case 7: { //focusDistance
            ANARIDataType focusDistance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, focusDistance_types);
            return;
         }
         case 8: { //stereoMode
            ANARIDataType stereoMode_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, stereoMode_types);
            return;
         }
         case 9: { //interpupillaryDistance
            ANARIDataType interpupillaryDistance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, interpupillaryDistance_types);
            return;
         }
         case 10: { //fovy
            ANARIDataType fovy_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, fovy_types);
            return;
         }
         case 11: { //aspect
            ANARIDataType aspect_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, aspect_types);
            return;
         }
         case 12: { //near
            ANARIDataType near_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, near_types);
            return;
         }
         case 13: { //far
            ANARIDataType far_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, far_types);
            return;
         }
         case 14: { //motion.transform
            ANARIDataType motion_transform_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, motion_transform_types);
            return;
         }
         case 15: { //motion.scale
            ANARIDataType motion_scale_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, motion_scale_types);
            return;
         }
         case 16: { //motion.rotation
            ANARIDataType motion_rotation_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, motion_rotation_types);
            return;
         }
         case 17: { //motion.translation
            ANARIDataType motion_translation_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, motion_translation_types);
            return;
         }
         case 18: { //time
            ANARIDataType time_types[] = {ANARI_FLOAT32_BOX1, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, time_types);
            return;
         }
         case 19: { //shutter
            ANARIDataType shutter_types[] = {ANARI_FLOAT32_BOX1, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, shutter_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_CAMERA, "perspective", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "perspective";
   }
};
class geometry_cone : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610014u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610018u,0x0u,0x7372001cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x66650053u,0x71700015u,0x74730016u,0x1000017u,0x80000010u,0x6e6d0019u,0x6665001au,0x100001bu,0x80000000u,0x6a69001du,0x6e6d001eu,0x6a69001fu,0x75740020u,0x6a690021u,0x77760022u,0x66650023u,0x2f2e0024u,0x6a610025u,0x7574002eu,0x0u,0x706f003eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640043u,0x7574002fu,0x73720030u,0x6a690031u,0x63620032u,0x76750033u,0x75740034u,0x66650035u,0x34300036u,0x100003au,0x100003bu,0x100003cu,0x100003du,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c003fu,0x706f0040u,0x73720041u,0x1000042u,0x80000001u,0x100004eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6564004fu,0x80000006u,0x66650050u,0x79780051u,0x1000052u,0x8000000fu,0x73720054u,0x75740055u,0x66650056u,0x79780057u,0x2f2e0058u,0x73610059u,0x7574006bu,0x0u,0x7061007bu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0090u,0x0u,0x62610098u,0x7574006cu,0x7372006du,0x6a69006eu,0x6362006fu,0x76750070u,0x75740071u,0x66650072u,0x34300073u,0x1000077u,0x1000078u,0x1000079u,0x100007au,0x8000000bu,0x8000000cu,0x8000000du,0x8000000eu,0x7170008au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c008cu,0x100008bu,0x80000009u,0x706f008du,0x7372008eu,0x100008fu,0x8000000au,0x74730091u,0x6a690092u,0x75740093u,0x6a690094u,0x706f0095u,0x6f6e0096u,0x1000097u,0x80000007u,0x65640099u,0x6a69009au,0x7675009bu,0x7473009cu,0x100009du,0x80000008u};
      uint32_t cur = 0x77630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_cone(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.radius
            ANARIDataType vertex_radius_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_radius_types);
            return;
         }
         case 9: { //vertex.cap
            ANARIDataType vertex_cap_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_cap_types);
            return;
         }
         case 10: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_color_types);
            return;
         }
         case 11: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 12: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 13: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 14: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 15: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, primitive_index_types);
            return;
         }
         case 16: { //caps
            ANARIDataType caps_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cone", paramname, paramtype, caps_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "cone", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "cone";
   }
};
class geometry_curve : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610009u,0x0u,0x7372000du,0x0u,0x62610044u,0x0u,0x0u,0x0u,0x6665004au,0x6e6d000au,0x6665000bu,0x100000cu,0x80000000u,0x6a69000eu,0x6e6d000fu,0x6a690010u,0x75740011u,0x6a690012u,0x77760013u,0x66650014u,0x2f2e0015u,0x6a610016u,0x7574001fu,0x0u,0x706f002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640034u,0x75740020u,0x73720021u,0x6a690022u,0x63620023u,0x76750024u,0x75740025u,0x66650026u,0x34300027u,0x100002bu,0x100002cu,0x100002du,0x100002eu,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0030u,0x706f0031u,0x73720032u,0x1000033u,0x80000001u,0x100003fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640040u,0x80000006u,0x66650041u,0x79780042u,0x1000043u,0x8000000eu,0x65640045u,0x6a690046u,0x76750047u,0x74730048u,0x1000049u,0x8000000fu,0x7372004bu,0x7574004cu,0x6665004du,0x7978004eu,0x2f2e004fu,0x73610050u,0x75740062u,0x0u,0x706f0072u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0077u,0x0u,0x6261007fu,0x75740063u,0x73720064u,0x6a690065u,0x63620066u,0x76750067u,0x75740068u,0x66650069u,0x3430006au,0x100006eu,0x100006fu,0x1000070u,0x1000071u,0x8000000au,0x8000000bu,0x8000000cu,0x8000000du,0x6d6c0073u,0x706f0074u,0x73720075u,0x1000076u,0x80000009u,0x74730078u,0x6a690079u,0x7574007au,0x6a69007bu,0x706f007cu,0x6f6e007du,0x100007eu,0x80000007u,0x65640080u,0x6a690081u,0x76750082u,0x74730083u,0x1000084u,0x80000008u};
      uint32_t cur = 0x776e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_curve(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.radius
            ANARIDataType vertex_radius_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_radius_types);
            return;
         }
         case 9: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_color_types);
            return;
         }
         case 10: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 11: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 12: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 13: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 14: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, primitive_index_types);
            return;
         }
         case 15: { //radius
            ANARIDataType radius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "curve", paramname, paramtype, radius_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "curve", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "curve";
   }
};
class geometry_cylinder : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610014u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610018u,0x0u,0x7372001cu,0x0u,0x62610062u,0x0u,0x0u,0x0u,0x66650068u,0x71700015u,0x74730016u,0x1000017u,0x80000011u,0x6e6d0019u,0x6665001au,0x100001bu,0x80000000u,0x6a69001du,0x6e6d001eu,0x6a69001fu,0x75740020u,0x6a690021u,0x77760022u,0x66650023u,0x2f2e0024u,0x73610025u,0x75740037u,0x0u,0x706f0047u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f64004cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261005cu,0x75740038u,0x73720039u,0x6a69003au,0x6362003bu,0x7675003cu,0x7574003du,0x6665003eu,0x3430003fu,0x1000043u,0x1000044u,0x1000045u,0x1000046u,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0048u,0x706f0049u,0x7372004au,0x100004bu,0x80000001u,0x1000057u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640058u,0x80000006u,0x66650059u,0x7978005au,0x100005bu,0x8000000eu,0x6564005du,0x6a69005eu,0x7675005fu,0x74730060u,0x1000061u,0x8000000fu,0x65640063u,0x6a690064u,0x76750065u,0x74730066u,0x1000067u,0x80000010u,0x73720069u,0x7574006au,0x6665006bu,0x7978006cu,0x2f2e006du,0x7161006eu,0x7574007eu,0x0u,0x7061008eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f00a3u,0x7574007fu,0x73720080u,0x6a690081u,0x63620082u,0x76750083u,0x75740084u,0x66650085u,0x34300086u,0x100008au,0x100008bu,0x100008cu,0x100008du,0x8000000au,0x8000000bu,0x8000000cu,0x8000000du,0x7170009du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c009fu,0x100009eu,0x80000008u,0x706f00a0u,0x737200a1u,0x10000a2u,0x80000009u,0x747300a4u,0x6a6900a5u,0x757400a6u,0x6a6900a7u,0x706f00a8u,0x6f6e00a9u,0x10000aau,0x80000007u};
      uint32_t cur = 0x77630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_cylinder(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.cap
            ANARIDataType vertex_cap_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_cap_types);
            return;
         }
         case 9: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_color_types);
            return;
         }
         case 10: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 11: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 12: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 13: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 14: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_index_types);
            return;
         }
         case 15: { //primitive.radius
            ANARIDataType primitive_radius_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, primitive_radius_types);
            return;
         }
         case 16: { //radius
            ANARIDataType radius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, radius_types);
            return;
         }
         case 17: { //caps
            ANARIDataType caps_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "cylinder", paramname, paramtype, caps_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "cylinder", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "cylinder";
   }
};
class geometry_quad : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610009u,0x0u,0x7372000du,0x0u,0x0u,0x0u,0x0u,0x0u,0x66650044u,0x6e6d000au,0x6665000bu,0x100000cu,0x80000000u,0x6a69000eu,0x6e6d000fu,0x6a690010u,0x75740011u,0x6a690012u,0x77760013u,0x66650014u,0x2f2e0015u,0x6a610016u,0x7574001fu,0x0u,0x706f002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640034u,0x75740020u,0x73720021u,0x6a690022u,0x63620023u,0x76750024u,0x75740025u,0x66650026u,0x34300027u,0x100002bu,0x100002cu,0x100002du,0x100002eu,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0030u,0x706f0031u,0x73720032u,0x1000033u,0x80000001u,0x100003fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640040u,0x80000006u,0x66650041u,0x79780042u,0x1000043u,0x8000000fu,0x73720045u,0x75740046u,0x66650047u,0x79780048u,0x2f2e0049u,0x7561004au,0x7574005eu,0x0u,0x706f006eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0073u,0x0u,0x706f0079u,0x0u,0x0u,0x0u,0x62610081u,0x7574005fu,0x73720060u,0x6a690061u,0x63620062u,0x76750063u,0x75740064u,0x66650065u,0x34300066u,0x100006au,0x100006bu,0x100006cu,0x100006du,0x8000000bu,0x8000000cu,0x8000000du,0x8000000eu,0x6d6c006fu,0x706f0070u,0x73720071u,0x1000072u,0x8000000au,0x73720074u,0x6e6d0075u,0x62610076u,0x6d6c0077u,0x1000078u,0x80000008u,0x7473007au,0x6a69007bu,0x7574007cu,0x6a69007du,0x706f007eu,0x6f6e007fu,0x1000080u,0x80000007u,0x6f6e0082u,0x68670083u,0x66650084u,0x6f6e0085u,0x75740086u,0x1000087u,0x80000009u};
      uint32_t cur = 0x776e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_quad(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.normal
            ANARIDataType vertex_normal_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_normal_types);
            return;
         }
         case 9: { //vertex.tangent
            ANARIDataType vertex_tangent_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_tangent_types);
            return;
         }
         case 10: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_color_types);
            return;
         }
         case 11: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 12: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 13: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 14: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 15: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "quad", paramname, paramtype, primitive_index_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "quad", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "quad";
   }
};
class geometry_sphere : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610009u,0x0u,0x7372000du,0x0u,0x62610044u,0x0u,0x0u,0x0u,0x6665004au,0x6e6d000au,0x6665000bu,0x100000cu,0x80000000u,0x6a69000eu,0x6e6d000fu,0x6a690010u,0x75740011u,0x6a690012u,0x77760013u,0x66650014u,0x2f2e0015u,0x6a610016u,0x7574001fu,0x0u,0x706f002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640034u,0x75740020u,0x73720021u,0x6a690022u,0x63620023u,0x76750024u,0x75740025u,0x66650026u,0x34300027u,0x100002bu,0x100002cu,0x100002du,0x100002eu,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0030u,0x706f0031u,0x73720032u,0x1000033u,0x80000001u,0x100003fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640040u,0x80000006u,0x66650041u,0x79780042u,0x1000043u,0x8000000eu,0x65640045u,0x6a690046u,0x76750047u,0x74730048u,0x1000049u,0x8000000fu,0x7372004bu,0x7574004cu,0x6665004du,0x7978004eu,0x2f2e004fu,0x73610050u,0x75740062u,0x0u,0x706f0072u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0077u,0x0u,0x6261007fu,0x75740063u,0x73720064u,0x6a690065u,0x63620066u,0x76750067u,0x75740068u,0x66650069u,0x3430006au,0x100006eu,0x100006fu,0x1000070u,0x1000071u,0x8000000au,0x8000000bu,0x8000000cu,0x8000000du,0x6d6c0073u,0x706f0074u,0x73720075u,0x1000076u,0x80000009u,0x74730078u,0x6a690079u,0x7574007au,0x6a69007bu,0x706f007cu,0x6f6e007du,0x100007eu,0x80000007u,0x65640080u,0x6a690081u,0x76750082u,0x74730083u,0x1000084u,0x80000008u};
      uint32_t cur = 0x776e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_sphere(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.radius
            ANARIDataType vertex_radius_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_radius_types);
            return;
         }
         case 9: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_color_types);
            return;
         }
         case 10: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 11: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 12: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 13: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 14: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, primitive_index_types);
            return;
         }
         case 15: { //radius
            ANARIDataType radius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "sphere", paramname, paramtype, radius_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "sphere", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "sphere";
   }
};
class geometry_triangle : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610009u,0x0u,0x7372000du,0x0u,0x0u,0x0u,0x0u,0x0u,0x66650044u,0x6e6d000au,0x6665000bu,0x100000cu,0x80000000u,0x6a69000eu,0x6e6d000fu,0x6a690010u,0x75740011u,0x6a690012u,0x77760013u,0x66650014u,0x2f2e0015u,0x6a610016u,0x7574001fu,0x0u,0x706f002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640034u,0x75740020u,0x73720021u,0x6a690022u,0x63620023u,0x76750024u,0x75740025u,0x66650026u,0x34300027u,0x100002bu,0x100002cu,0x100002du,0x100002eu,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0030u,0x706f0031u,0x73720032u,0x1000033u,0x80000001u,0x100003fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640040u,0x80000006u,0x66650041u,0x79780042u,0x1000043u,0x8000000fu,0x73720045u,0x75740046u,0x66650047u,0x79780048u,0x2f2e0049u,0x7561004au,0x7574005eu,0x0u,0x706f006eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0073u,0x0u,0x706f0079u,0x0u,0x0u,0x0u,0x62610081u,0x7574005fu,0x73720060u,0x6a690061u,0x63620062u,0x76750063u,0x75740064u,0x66650065u,0x34300066u,0x100006au,0x100006bu,0x100006cu,0x100006du,0x8000000bu,0x8000000cu,0x8000000du,0x8000000eu,0x6d6c006fu,0x706f0070u,0x73720071u,0x1000072u,0x8000000au,0x73720074u,0x6e6d0075u,0x62610076u,0x6d6c0077u,0x1000078u,0x80000008u,0x7473007au,0x6a69007bu,0x7574007cu,0x6a69007du,0x706f007eu,0x6f6e007fu,0x1000080u,0x80000007u,0x6f6e0082u,0x68670083u,0x66650084u,0x6f6e0085u,0x75740086u,0x1000087u,0x80000009u};
      uint32_t cur = 0x776e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_triangle(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.normal
            ANARIDataType vertex_normal_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_normal_types);
            return;
         }
         case 9: { //vertex.tangent
            ANARIDataType vertex_tangent_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_tangent_types);
            return;
         }
         case 10: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_color_types);
            return;
         }
         case 11: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 12: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 13: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 14: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 15: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_index_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "triangle", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "triangle";
   }
};
class light_directional : public DebugObject<ANARI_LIGHT> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6f6e0016u,0x0u,0x706f0025u,0x6a69002au,0x0u,0x0u,0x0u,0x0u,0x73720033u,0x0u,0x0u,0x0u,0x0u,0x6261003du,0x0u,0x0u,0x0u,0x62610041u,0x0u,0x0u,0x0u,0x6a690049u,0x68670017u,0x76750018u,0x6d6c0019u,0x6261001au,0x7372001bu,0x4544001cu,0x6a69001du,0x6261001eu,0x6e6d001fu,0x66650020u,0x75740021u,0x66650022u,0x73720023u,0x1000024u,0x80000004u,0x6d6c0026u,0x706f0027u,0x73720028u,0x1000029u,0x80000001u,0x7372002bu,0x6665002cu,0x6463002du,0x7574002eu,0x6a69002fu,0x706f0030u,0x6f6e0031u,0x1000032u,0x80000003u,0x73720034u,0x62610035u,0x65640036u,0x6a690037u,0x62610038u,0x6f6e0039u,0x6463003au,0x6665003bu,0x100003cu,0x80000002u,0x6e6d003eu,0x6665003fu,0x1000040u,0x80000000u,0x65640042u,0x6a690043u,0x62610044u,0x6f6e0045u,0x64630046u,0x66650047u,0x1000048u,0x80000005u,0x7473004au,0x6a69004bu,0x6362004cu,0x6d6c004du,0x6665004eu,0x100004fu,0x80000006u};
      uint32_t cur = 0x77610000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   light_directional(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "directional", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "directional", paramname, paramtype, color_types);
            return;
         }
         case 2: { //irradiance
            ANARIDataType irradiance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "directional", paramname, paramtype, irradiance_types);
            return;
         }
         case 3: { //direction
            ANARIDataType direction_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "directional", paramname, paramtype, direction_types);
            return;
         }
         case 4: { //angularDiameter
            ANARIDataType angularDiameter_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "directional", paramname, paramtype, angularDiameter_types);
            return;
         }
         case 5: { //radiance
            ANARIDataType radiance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "directional", paramname, paramtype, radiance_types);
            return;
         }
         case 6: { //visible
            ANARIDataType visible_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "directional", paramname, paramtype, visible_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_LIGHT, "directional", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "directional";
   }
};
class light_point : public DebugObject<ANARI_LIGHT> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x706f0014u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f6e0019u,0x0u,0x0u,0x0u,0x0u,0x62610022u,0x0u,0x706f0026u,0x0u,0x62610035u,0x0u,0x0u,0x0u,0x6a690053u,0x6d6c0015u,0x706f0016u,0x73720017u,0x1000018u,0x80000001u,0x7574001au,0x6665001bu,0x6f6e001cu,0x7473001du,0x6a69001eu,0x7574001fu,0x7a790020u,0x1000021u,0x80000003u,0x6e6d0023u,0x66650024u,0x1000025u,0x80000000u,0x78730027u,0x6a69002cu,0x0u,0x0u,0x0u,0x66650032u,0x7574002du,0x6a69002eu,0x706f002fu,0x6f6e0030u,0x1000031u,0x80000002u,0x73720033u,0x1000034u,0x80000004u,0x65640036u,0x6a690037u,0x76610038u,0x6f6e004du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x74730051u,0x6463004eu,0x6665004fu,0x1000050u,0x80000006u,0x1000052u,0x80000005u,0x74730054u,0x6a690055u,0x63620056u,0x6d6c0057u,0x66650058u,0x1000059u,0x80000007u};
      uint32_t cur = 0x77630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   light_point(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "point", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "point", paramname, paramtype, color_types);
            return;
         }
         case 2: { //position
            ANARIDataType position_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "point", paramname, paramtype, position_types);
            return;
         }
         case 3: { //intensity
            ANARIDataType intensity_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "point", paramname, paramtype, intensity_types);
            return;
         }
         case 4: { //power
            ANARIDataType power_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "point", paramname, paramtype, power_types);
            return;
         }
         case 5: { //radius
            ANARIDataType radius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "point", paramname, paramtype, radius_types);
            return;
         }
         case 6: { //radiance
            ANARIDataType radiance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "point", paramname, paramtype, radiance_types);
            return;
         }
         case 7: { //visible
            ANARIDataType visible_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "point", paramname, paramtype, visible_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_LIGHT, "point", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "point";
   }
};
class light_spot : public DebugObject<ANARI_LIGHT> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x706f000eu,0x6a690013u,0x0u,0x6261001cu,0x0u,0x0u,0x6f6e0028u,0x0u,0x0u,0x0u,0x0u,0x62610031u,0x71700035u,0x706f0041u,0x6d6c000fu,0x706f0010u,0x73720011u,0x1000012u,0x80000001u,0x73720014u,0x66650015u,0x64630016u,0x75740017u,0x6a690018u,0x706f0019u,0x6f6e001au,0x100001bu,0x80000003u,0x6d6c001du,0x6d6c001eu,0x706f001fu,0x67660020u,0x67660021u,0x42410022u,0x6f6e0023u,0x68670024u,0x6d6c0025u,0x66650026u,0x1000027u,0x80000005u,0x75740029u,0x6665002au,0x6f6e002bu,0x7473002cu,0x6a69002du,0x7574002eu,0x7a79002fu,0x1000030u,0x80000006u,0x6e6d0032u,0x66650033u,0x1000034u,0x80000000u,0x66650036u,0x6f6e0037u,0x6a690038u,0x6f6e0039u,0x6867003au,0x4241003bu,0x6f6e003cu,0x6867003du,0x6d6c003eu,0x6665003fu,0x1000040u,0x80000004u,0x78730042u,0x6a690047u,0x0u,0x0u,0x0u,0x6665004du,0x75740048u,0x6a690049u,0x706f004au,0x6f6e004bu,0x100004cu,0x80000002u,0x7372004eu,0x100004fu,0x80000007u};
      uint32_t cur = 0x71630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   light_spot(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "spot", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "spot", paramname, paramtype, color_types);
            return;
         }
         case 2: { //position
            ANARIDataType position_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "spot", paramname, paramtype, position_types);
            return;
         }
         case 3: { //direction
            ANARIDataType direction_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "spot", paramname, paramtype, direction_types);
            return;
         }
         case 4: { //openingAngle
            ANARIDataType openingAngle_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "spot", paramname, paramtype, openingAngle_types);
            return;
         }
         case 5: { //falloffAngle
            ANARIDataType falloffAngle_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "spot", paramname, paramtype, falloffAngle_types);
            return;
         }
         case 6: { //intensity
            ANARIDataType intensity_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "spot", paramname, paramtype, intensity_types);
            return;
         }
         case 7: { //power
            ANARIDataType power_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "spot", paramname, paramtype, power_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_LIGHT, "spot", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "spot";
   }
};
class material_matte : public DebugObject<ANARI_MATERIAL> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6d6c000fu,0x0u,0x706f0028u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261002du,0x71700031u,0x71700010u,0x69680011u,0x62610012u,0x4e430013u,0x7675001eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0024u,0x7574001fu,0x706f0020u,0x67660021u,0x67660022u,0x1000023u,0x80000004u,0x65640025u,0x66650026u,0x1000027u,0x80000003u,0x6d6c0029u,0x706f002au,0x7372002bu,0x100002cu,0x80000001u,0x6e6d002eu,0x6665002fu,0x1000030u,0x80000000u,0x62610032u,0x64630033u,0x6a690034u,0x75740035u,0x7a790036u,0x1000037u,0x80000002u};
      uint32_t cur = 0x70610000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   material_matte(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3,ANARI_SAMPLER,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, color_types);
            return;
         }
         case 2: { //opacity
            ANARIDataType opacity_types[] = {ANARI_FLOAT32,ANARI_SAMPLER,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, opacity_types);
            return;
         }
         case 3: { //alphaMode
            ANARIDataType alphaMode_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, alphaMode_types);
            return;
         }
         case 4: { //alphaCutoff
            ANARIDataType alphaCutoff_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, alphaCutoff_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_MATERIAL, "matte", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "matte";
   }
};
class material_transparentMatte : public DebugObject<ANARI_MATERIAL> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6d6c000fu,0x0u,0x706f0028u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261002du,0x71700031u,0x71700010u,0x69680011u,0x62610012u,0x4e430013u,0x7675001eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0024u,0x7574001fu,0x706f0020u,0x67660021u,0x67660022u,0x1000023u,0x80000004u,0x65640025u,0x66650026u,0x1000027u,0x80000003u,0x6d6c0029u,0x706f002au,0x7372002bu,0x100002cu,0x80000001u,0x6e6d002eu,0x6665002fu,0x1000030u,0x80000000u,0x62610032u,0x64630033u,0x6a690034u,0x75740035u,0x7a790036u,0x1000037u,0x80000002u};
      uint32_t cur = 0x70610000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   material_transparentMatte(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3,ANARI_SAMPLER,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, color_types);
            return;
         }
         case 2: { //opacity
            ANARIDataType opacity_types[] = {ANARI_FLOAT32,ANARI_SAMPLER,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, opacity_types);
            return;
         }
         case 3: { //alphaMode
            ANARIDataType alphaMode_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, alphaMode_types);
            return;
         }
         case 4: { //alphaCutoff
            ANARIDataType alphaCutoff_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, alphaCutoff_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_MATERIAL, "transparentMatte", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "transparentMatte";
   }
};
class sampler_image1D : public DebugObject<ANARI_SAMPLER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6a690012u,0x0u,0x0u,0x6f6d0018u,0x0u,0x0u,0x0u,0x0u,0x62610044u,0x76750048u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720054u,0x6d6c0013u,0x75740014u,0x66650015u,0x73720016u,0x1000017u,0x80000003u,0x6261001au,0x5541001eu,0x6867001bu,0x6665001cu,0x100001du,0x80000001u,0x75740032u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372003bu,0x75740033u,0x73720034u,0x6a690035u,0x63620036u,0x76750037u,0x75740038u,0x66650039u,0x100003au,0x80000002u,0x6261003cu,0x6f6e003du,0x7473003eu,0x6766003fu,0x706f0040u,0x73720041u,0x6e6d0042u,0x1000043u,0x80000005u,0x6e6d0045u,0x66650046u,0x1000047u,0x80000000u,0x75740049u,0x5554004au,0x7372004bu,0x6261004cu,0x6f6e004du,0x7473004eu,0x6766004fu,0x706f0050u,0x73720051u,0x6e6d0052u,0x1000053u,0x80000006u,0x62610055u,0x71700056u,0x4e4d0057u,0x706f0058u,0x65640059u,0x6665005au,0x3231005bu,0x100005cu,0x80000004u};
      uint32_t cur = 0x78660000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   sampler_image1D(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, name_types);
            return;
         }
         case 1: { //image
            ANARIDataType image_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, image_types);
            return;
         }
         case 2: { //inAttribute
            ANARIDataType inAttribute_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, inAttribute_types);
            return;
         }
         case 3: { //filter
            ANARIDataType filter_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, filter_types);
            return;
         }
         case 4: { //wrapMode1
            ANARIDataType wrapMode1_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, wrapMode1_types);
            return;
         }
         case 5: { //inTransform
            ANARIDataType inTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, inTransform_types);
            return;
         }
         case 6: { //outTransform
            ANARIDataType outTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image1D", paramname, paramtype, outTransform_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SAMPLER, "image1D", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "image1D";
   }
};
class sampler_image2D : public DebugObject<ANARI_SAMPLER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6a690012u,0x0u,0x0u,0x6f6d0018u,0x0u,0x0u,0x0u,0x0u,0x62610044u,0x76750048u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720054u,0x6d6c0013u,0x75740014u,0x66650015u,0x73720016u,0x1000017u,0x80000003u,0x6261001au,0x5541001eu,0x6867001bu,0x6665001cu,0x100001du,0x80000001u,0x75740032u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372003bu,0x75740033u,0x73720034u,0x6a690035u,0x63620036u,0x76750037u,0x75740038u,0x66650039u,0x100003au,0x80000002u,0x6261003cu,0x6f6e003du,0x7473003eu,0x6766003fu,0x706f0040u,0x73720041u,0x6e6d0042u,0x1000043u,0x80000006u,0x6e6d0045u,0x66650046u,0x1000047u,0x80000000u,0x75740049u,0x5554004au,0x7372004bu,0x6261004cu,0x6f6e004du,0x7473004eu,0x6766004fu,0x706f0050u,0x73720051u,0x6e6d0052u,0x1000053u,0x80000007u,0x62610055u,0x71700056u,0x4e4d0057u,0x706f0058u,0x65640059u,0x6665005au,0x3331005bu,0x100005du,0x100005eu,0x80000004u,0x80000005u};
      uint32_t cur = 0x78660000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   sampler_image2D(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, name_types);
            return;
         }
         case 1: { //image
            ANARIDataType image_types[] = {ANARI_ARRAY2D, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, image_types);
            return;
         }
         case 2: { //inAttribute
            ANARIDataType inAttribute_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, inAttribute_types);
            return;
         }
         case 3: { //filter
            ANARIDataType filter_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, filter_types);
            return;
         }
         case 4: { //wrapMode1
            ANARIDataType wrapMode1_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, wrapMode1_types);
            return;
         }
         case 5: { //wrapMode2
            ANARIDataType wrapMode2_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, wrapMode2_types);
            return;
         }
         case 6: { //inTransform
            ANARIDataType inTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, inTransform_types);
            return;
         }
         case 7: { //outTransform
            ANARIDataType outTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image2D", paramname, paramtype, outTransform_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SAMPLER, "image2D", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "image2D";
   }
};
class sampler_image3D : public DebugObject<ANARI_SAMPLER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6a690012u,0x0u,0x0u,0x6f6d0018u,0x0u,0x0u,0x0u,0x0u,0x62610044u,0x76750048u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720054u,0x6d6c0013u,0x75740014u,0x66650015u,0x73720016u,0x1000017u,0x80000003u,0x6261001au,0x5541001eu,0x6867001bu,0x6665001cu,0x100001du,0x80000001u,0x75740032u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372003bu,0x75740033u,0x73720034u,0x6a690035u,0x63620036u,0x76750037u,0x75740038u,0x66650039u,0x100003au,0x80000002u,0x6261003cu,0x6f6e003du,0x7473003eu,0x6766003fu,0x706f0040u,0x73720041u,0x6e6d0042u,0x1000043u,0x80000007u,0x6e6d0045u,0x66650046u,0x1000047u,0x80000000u,0x75740049u,0x5554004au,0x7372004bu,0x6261004cu,0x6f6e004du,0x7473004eu,0x6766004fu,0x706f0050u,0x73720051u,0x6e6d0052u,0x1000053u,0x80000008u,0x62610055u,0x71700056u,0x4e4d0057u,0x706f0058u,0x65640059u,0x6665005au,0x3431005bu,0x100005eu,0x100005fu,0x1000060u,0x80000004u,0x80000005u,0x80000006u};
      uint32_t cur = 0x78660000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   sampler_image3D(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, name_types);
            return;
         }
         case 1: { //image
            ANARIDataType image_types[] = {ANARI_ARRAY3D, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, image_types);
            return;
         }
         case 2: { //inAttribute
            ANARIDataType inAttribute_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, inAttribute_types);
            return;
         }
         case 3: { //filter
            ANARIDataType filter_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, filter_types);
            return;
         }
         case 4: { //wrapMode1
            ANARIDataType wrapMode1_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, wrapMode1_types);
            return;
         }
         case 5: { //wrapMode2
            ANARIDataType wrapMode2_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, wrapMode2_types);
            return;
         }
         case 6: { //wrapMode3
            ANARIDataType wrapMode3_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, wrapMode3_types);
            return;
         }
         case 7: { //inTransform
            ANARIDataType inTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, inTransform_types);
            return;
         }
         case 8: { //outTransform
            ANARIDataType outTransform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "image3D", paramname, paramtype, outTransform_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SAMPLER, "image3D", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "image3D";
   }
};
class sampler_primitive : public DebugObject<ANARI_SAMPLER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x7372000fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610014u,0x67660018u,0x73720010u,0x62610011u,0x7a790012u,0x1000013u,0x80000001u,0x6e6d0015u,0x66650016u,0x1000017u,0x80000000u,0x67660019u,0x7473001au,0x6665001bu,0x7574001cu,0x100001du,0x80000002u};
      uint32_t cur = 0x70610000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   sampler_primitive(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "primitive", paramname, paramtype, name_types);
            return;
         }
         case 1: { //array
            ANARIDataType array_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "primitive", paramname, paramtype, array_types);
            return;
         }
         case 2: { //offset
            ANARIDataType offset_types[] = {ANARI_UINT64, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "primitive", paramname, paramtype, offset_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SAMPLER, "primitive", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "primitive";
   }
};
class sampler_transform : public DebugObject<ANARI_SAMPLER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6f6e000cu,0x0u,0x0u,0x0u,0x0u,0x62610017u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372001bu,0x4241000du,0x7574000eu,0x7574000fu,0x73720010u,0x6a690011u,0x63620012u,0x76750013u,0x75740014u,0x66650015u,0x1000016u,0x80000001u,0x6e6d0018u,0x66650019u,0x100001au,0x80000000u,0x6261001cu,0x6f6e001du,0x7473001eu,0x6766001fu,0x706f0020u,0x73720021u,0x6e6d0022u,0x1000023u,0x80000002u};
      uint32_t cur = 0x75690000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   sampler_transform(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "transform", paramname, paramtype, name_types);
            return;
         }
         case 1: { //inAttribute
            ANARIDataType inAttribute_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "transform", paramname, paramtype, inAttribute_types);
            return;
         }
         case 2: { //transform
            ANARIDataType transform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_SAMPLER, "transform", paramname, paramtype, transform_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SAMPLER, "transform", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "transform";
   }
};
class spatial_field_structuredRegular : public DebugObject<ANARI_SPATIAL_FIELD> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610010u,0x0u,0x6a690014u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261001au,0x7372001eu,0x0u,0x0u,0x0u,0x71700024u,0x75740011u,0x62610012u,0x1000013u,0x80000001u,0x6d6c0015u,0x75740016u,0x66650017u,0x73720018u,0x1000019u,0x80000004u,0x6e6d001bu,0x6665001cu,0x100001du,0x80000000u,0x6a69001fu,0x68670020u,0x6a690021u,0x6f6e0022u,0x1000023u,0x80000002u,0x62610025u,0x64630026u,0x6a690027u,0x6f6e0028u,0x68670029u,0x100002au,0x80000003u};
      uint32_t cur = 0x74640000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   spatial_field_structuredRegular(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, name_types);
            return;
         }
         case 1: { //data
            ANARIDataType data_types[] = {ANARI_ARRAY3D, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, data_types);
            return;
         }
         case 2: { //origin
            ANARIDataType origin_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, origin_types);
            return;
         }
         case 3: { //spacing
            ANARIDataType spacing_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, spacing_types);
            return;
         }
         case 4: { //filter
            ANARIDataType filter_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype, filter_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SPATIAL_FIELD, "structuredRegular", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "structuredRegular";
   }
};
class volume_scivis : public DebugObject<ANARI_VOLUME> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x706f0014u,0x66650050u,0x0u,0x6a69005cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610061u,0x71700065u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626100a3u,0x6d6c0015u,0x706f0016u,0x73720017u,0x2f000018u,0x80000003u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x71700047u,0x706f0048u,0x74730049u,0x6a69004au,0x7574004bu,0x6a69004cu,0x706f004du,0x6f6e004eu,0x100004fu,0x80000004u,0x6f6e0051u,0x74730052u,0x6a690053u,0x75740054u,0x7a790055u,0x54530056u,0x64630057u,0x62610058u,0x6d6c0059u,0x6665005au,0x100005bu,0x80000007u,0x6665005du,0x6d6c005eu,0x6564005fu,0x1000060u,0x80000001u,0x6e6d0062u,0x66650063u,0x1000064u,0x80000000u,0x62610066u,0x64630067u,0x6a690068u,0x75740069u,0x7a79006au,0x2f00006bu,0x80000005u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7170009au,0x706f009bu,0x7473009cu,0x6a69009du,0x7574009eu,0x6a69009fu,0x706f00a0u,0x6f6e00a1u,0x10000a2u,0x80000006u,0x6d6c00a4u,0x767500a5u,0x666500a6u,0x535200a7u,0x626100a8u,0x6f6e00a9u,0x686700aau,0x666500abu,0x10000acu,0x80000002u};
      uint32_t cur = 0x77630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   volume_scivis(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, name_types);
            return;
         }
         case 1: { //field
            ANARIDataType field_types[] = {ANARI_SPATIAL_FIELD, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, field_types);
            return;
         }
         case 2: { //valueRange
            ANARIDataType valueRange_types[] = {ANARI_FLOAT32_BOX1, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, valueRange_types);
            return;
         }
         case 3: { //color
            ANARIDataType color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, color_types);
            return;
         }
         case 4: { //color.position
            ANARIDataType color_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, color_position_types);
            return;
         }
         case 5: { //opacity
            ANARIDataType opacity_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, opacity_types);
            return;
         }
         case 6: { //opacity.position
            ANARIDataType opacity_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, opacity_position_types);
            return;
         }
         case 7: { //densityScale
            ANARIDataType densityScale_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_VOLUME, "scivis", paramname, paramtype, densityScale_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_VOLUME, "scivis", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "scivis";
   }
};
class light_ring : public DebugObject<ANARI_LIGHT> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x70300014u,0x6a690059u,0x0u,0x62610062u,0x0u,0x0u,0x6f6e006eu,0x0u,0x0u,0x0u,0x0u,0x626100d6u,0x717000dau,0x706f00e6u,0x0u,0x626100f5u,0x0u,0x0u,0x0u,0x6a690113u,0x1000054u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c0055u,0x8000000cu,0x706f0056u,0x73720057u,0x1000058u,0x80000001u,0x7372005au,0x6665005bu,0x6463005cu,0x7574005du,0x6a69005eu,0x706f005fu,0x6f6e0060u,0x1000061u,0x80000003u,0x6d6c0063u,0x6d6c0064u,0x706f0065u,0x67660066u,0x67660067u,0x42410068u,0x6f6e0069u,0x6867006au,0x6d6c006bu,0x6665006cu,0x100006du,0x80000005u,0x756e006fu,0x66650076u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6665007fu,0x73720077u,0x53520078u,0x62610079u,0x6564007au,0x6a69007bu,0x7675007cu,0x7473007du,0x100007eu,0x80000009u,0x6f6e0080u,0x74730081u,0x6a690082u,0x75740083u,0x7a790084u,0x45000085u,0x80000006u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a6900cau,0x747300cbu,0x757400ccu,0x737200cdu,0x6a6900ceu,0x636200cfu,0x767500d0u,0x757400d1u,0x6a6900d2u,0x706f00d3u,0x6f6e00d4u,0x10000d5u,0x8000000bu,0x6e6d00d7u,0x666500d8u,0x10000d9u,0x80000000u,0x666500dbu,0x6f6e00dcu,0x6a6900ddu,0x6f6e00deu,0x686700dfu,0x424100e0u,0x6f6e00e1u,0x686700e2u,0x6d6c00e3u,0x666500e4u,0x10000e5u,0x80000004u,0x787300e7u,0x6a6900ecu,0x0u,0x0u,0x0u,0x666500f2u,0x757400edu,0x6a6900eeu,0x706f00efu,0x6f6e00f0u,0x10000f1u,0x80000002u,0x737200f3u,0x10000f4u,0x80000007u,0x656400f6u,0x6a6900f7u,0x766100f8u,0x6f6e010du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x74730111u,0x6463010eu,0x6665010fu,0x1000110u,0x8000000au,0x1000112u,0x80000008u,0x74730114u,0x6a690115u,0x63620116u,0x6d6c0117u,0x66650118u,0x1000119u,0x8000000du};
      uint32_t cur = 0x77630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   light_ring(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, color_types);
            return;
         }
         case 2: { //position
            ANARIDataType position_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, position_types);
            return;
         }
         case 3: { //direction
            ANARIDataType direction_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, direction_types);
            return;
         }
         case 4: { //openingAngle
            ANARIDataType openingAngle_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, openingAngle_types);
            return;
         }
         case 5: { //falloffAngle
            ANARIDataType falloffAngle_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, falloffAngle_types);
            return;
         }
         case 6: { //intensity
            ANARIDataType intensity_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, intensity_types);
            return;
         }
         case 7: { //power
            ANARIDataType power_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, power_types);
            return;
         }
         case 8: { //radius
            ANARIDataType radius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, radius_types);
            return;
         }
         case 9: { //innerRadius
            ANARIDataType innerRadius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, innerRadius_types);
            return;
         }
         case 10: { //radiance
            ANARIDataType radiance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, radiance_types);
            return;
         }
         case 11: { //intensityDistribution
            ANARIDataType intensityDistribution_types[] = {ANARI_ARRAY1D,ANARI_ARRAY2D, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, intensityDistribution_types);
            return;
         }
         case 12: { //c0
            ANARIDataType c0_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, c0_types);
            return;
         }
         case 13: { //visible
            ANARIDataType visible_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "ring", paramname, paramtype, visible_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_LIGHT, "ring", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "ring";
   }
};
class light_quad : public DebugObject<ANARI_LIGHT> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x706f0014u,0x0u,0x65640019u,0x0u,0x0u,0x0u,0x6f6e0020u,0x0u,0x0u,0x0u,0x0u,0x62610079u,0x0u,0x706f007du,0x0u,0x6261008cu,0x6a690094u,0x0u,0x0u,0x6a690098u,0x6d6c0015u,0x706f0016u,0x73720017u,0x1000018u,0x80000001u,0x6867001au,0x6665001bu,0x3331001cu,0x100001eu,0x100001fu,0x80000003u,0x80000004u,0x75740021u,0x66650022u,0x6f6e0023u,0x74730024u,0x6a690025u,0x75740026u,0x7a790027u,0x45000028u,0x80000005u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a69006du,0x7473006eu,0x7574006fu,0x73720070u,0x6a690071u,0x63620072u,0x76750073u,0x75740074u,0x6a690075u,0x706f0076u,0x6f6e0077u,0x1000078u,0x80000009u,0x6e6d007au,0x6665007bu,0x100007cu,0x80000000u,0x7873007eu,0x6a690083u,0x0u,0x0u,0x0u,0x66650089u,0x75740084u,0x6a690085u,0x706f0086u,0x6f6e0087u,0x1000088u,0x80000002u,0x7372008au,0x100008bu,0x80000006u,0x6564008du,0x6a69008eu,0x6261008fu,0x6f6e0090u,0x64630091u,0x66650092u,0x1000093u,0x80000007u,0x65640095u,0x66650096u,0x1000097u,0x80000008u,0x74730099u,0x6a69009au,0x6362009bu,0x6d6c009cu,0x6665009du,0x100009eu,0x8000000au};
      uint32_t cur = 0x77630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   light_quad(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, color_types);
            return;
         }
         case 2: { //position
            ANARIDataType position_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, position_types);
            return;
         }
         case 3: { //edge1
            ANARIDataType edge1_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, edge1_types);
            return;
         }
         case 4: { //edge2
            ANARIDataType edge2_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, edge2_types);
            return;
         }
         case 5: { //intensity
            ANARIDataType intensity_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, intensity_types);
            return;
         }
         case 6: { //power
            ANARIDataType power_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, power_types);
            return;
         }
         case 7: { //radiance
            ANARIDataType radiance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, radiance_types);
            return;
         }
         case 8: { //side
            ANARIDataType side_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, side_types);
            return;
         }
         case 9: { //intensityDistribution
            ANARIDataType intensityDistribution_types[] = {ANARI_ARRAY1D,ANARI_ARRAY2D, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, intensityDistribution_types);
            return;
         }
         case 10: { //visible
            ANARIDataType visible_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "quad", paramname, paramtype, visible_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_LIGHT, "quad", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "quad";
   }
};
class light_hdri : public DebugObject<ANARI_LIGHT> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x706f0014u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610019u,0x0u,0x6261001fu,0x0u,0x0u,0x0u,0x62610023u,0x6463002bu,0x0u,0x71700030u,0x6a690032u,0x6d6c0015u,0x706f0016u,0x73720017u,0x1000018u,0x80000001u,0x7a79001au,0x706f001bu,0x7675001cu,0x7574001du,0x100001eu,0x80000004u,0x6e6d0020u,0x66650021u,0x1000022u,0x80000000u,0x65640024u,0x6a690025u,0x62610026u,0x6f6e0027u,0x64630028u,0x66650029u,0x100002au,0x80000003u,0x6261002cu,0x6d6c002du,0x6665002eu,0x100002fu,0x80000005u,0x1000031u,0x80000002u,0x74730033u,0x6a690034u,0x63620035u,0x6d6c0036u,0x66650037u,0x1000038u,0x80000006u};
      uint32_t cur = 0x77630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   light_hdri(DebugDevice *td, TreeDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "hdri", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "hdri", paramname, paramtype, color_types);
            return;
         }
         case 2: { //up
            ANARIDataType up_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "hdri", paramname, paramtype, up_types);
            return;
         }
         case 3: { //radiance
            ANARIDataType radiance_types[] = {ANARI_ARRAY2D, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "hdri", paramname, paramtype, radiance_types);
            return;
         }
         case 4: { //layout
            ANARIDataType layout_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "hdri", paramname, paramtype, layout_types);
            return;
         }
         case 5: { //scale
            ANARIDataType scale_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "hdri", paramname, paramtype, scale_types);
            return;
         }
         case 6: { //visible
            ANARIDataType visible_types[] = {ANARI_BOOL, ANARI_UNKNOWN};
            check_type(ANARI_LIGHT, "hdri", paramname, paramtype, visible_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_LIGHT, "hdri", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "hdri";
   }
};
}
static int camera_object_hash(const char *str) {
   static const uint32_t table[] = {0x736d0002u,0x66650021u,0x6f6e0008u,0x0u,0x0u,0x0u,0x0u,0x75740016u,0x6a690009u,0x6564000au,0x6a69000bu,0x7372000cu,0x6665000du,0x6463000eu,0x7574000fu,0x6a690010u,0x706f0011u,0x6f6e0012u,0x62610013u,0x6d6c0014u,0x1000015u,0x80000000u,0x69680017u,0x706f0018u,0x68670019u,0x7372001au,0x6261001bu,0x7170001cu,0x6968001du,0x6a69001eu,0x6463001fu,0x1000020u,0x80000001u,0x73720022u,0x74730023u,0x71700024u,0x66650025u,0x64630026u,0x75740027u,0x6a690028u,0x77760029u,0x6665002au,0x100002bu,0x80000002u};
   uint32_t cur = 0x716f0000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* TreeDebugFactory::new_camera(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = camera_object_hash(name);
   switch(idx) {
      case 0:
         return new camera_omnidirectional(td, this, wh, h);
      case 1:
         return new camera_orthographic(td, this, wh, h);
      case 2:
         return new camera_perspective(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_CAMERA, name);
         return new SubtypedDebugObject<ANARI_CAMERA>(td, wh, h, name);
   }
}
static int geometry_object_hash(const char *str) {
   static const uint32_t table[] = {0x7a6f0012u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7675002bu,0x0u,0x7170002fu,0x73720035u,0x6f6e001du,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720020u,0x0u,0x0u,0x0u,0x6d6c0024u,0x6665001eu,0x100001fu,0x80000000u,0x77760021u,0x66650022u,0x1000023u,0x80000001u,0x6a690025u,0x6f6e0026u,0x65640027u,0x66650028u,0x73720029u,0x100002au,0x80000002u,0x6261002cu,0x6564002du,0x100002eu,0x80000003u,0x69680030u,0x66650031u,0x73720032u,0x66650033u,0x1000034u,0x80000004u,0x6a690036u,0x62610037u,0x6f6e0038u,0x68670039u,0x6d6c003au,0x6665003bu,0x100003cu,0x80000005u};
   uint32_t cur = 0x75630000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* TreeDebugFactory::new_geometry(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = geometry_object_hash(name);
   switch(idx) {
      case 0:
         return new geometry_cone(td, this, wh, h);
      case 1:
         return new geometry_curve(td, this, wh, h);
      case 2:
         return new geometry_cylinder(td, this, wh, h);
      case 3:
         return new geometry_quad(td, this, wh, h);
      case 4:
         return new geometry_sphere(td, this, wh, h);
      case 5:
         return new geometry_triangle(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_GEOMETRY, name);
         return new SubtypedDebugObject<ANARI_GEOMETRY>(td, wh, h, name);
   }
}
static int light_object_hash(const char *str) {
   static const uint32_t table[] = {0x6a690010u,0x0u,0x0u,0x0u,0x6564001bu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f001fu,0x76750024u,0x6a690028u,0x7170002cu,0x73720011u,0x66650012u,0x64630013u,0x75740014u,0x6a690015u,0x706f0016u,0x6f6e0017u,0x62610018u,0x6d6c0019u,0x100001au,0x80000000u,0x7372001cu,0x6a69001du,0x100001eu,0x80000001u,0x6a690020u,0x6f6e0021u,0x75740022u,0x1000023u,0x80000002u,0x62610025u,0x65640026u,0x1000027u,0x80000003u,0x6f6e0029u,0x6867002au,0x100002bu,0x80000004u,0x706f002du,0x7574002eu,0x100002fu,0x80000005u};
   uint32_t cur = 0x74640000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* TreeDebugFactory::new_light(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = light_object_hash(name);
   switch(idx) {
      case 0:
         return new light_directional(td, this, wh, h);
      case 1:
         return new light_hdri(td, this, wh, h);
      case 2:
         return new light_point(td, this, wh, h);
      case 3:
         return new light_quad(td, this, wh, h);
      case 4:
         return new light_ring(td, this, wh, h);
      case 5:
         return new light_spot(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_LIGHT, name);
         return new SubtypedDebugObject<ANARI_LIGHT>(td, wh, h, name);
   }
}
static int material_object_hash(const char *str) {
   static const uint32_t table[] = {0x62610008u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372000du,0x75740009u,0x7574000au,0x6665000bu,0x100000cu,0x80000000u,0x6261000eu,0x6f6e000fu,0x74730010u,0x71700011u,0x62610012u,0x73720013u,0x66650014u,0x6f6e0015u,0x75740016u,0x4e4d0017u,0x62610018u,0x75740019u,0x7574001au,0x6665001bu,0x100001cu,0x80000001u};
   uint32_t cur = 0x756d0000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* TreeDebugFactory::new_material(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = material_object_hash(name);
   switch(idx) {
      case 0:
         return new material_matte(td, this, wh, h);
      case 1:
         return new material_transparentMatte(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_MATERIAL, name);
         return new SubtypedDebugObject<ANARI_MATERIAL>(td, wh, h, name);
   }
}
static int renderer_object_hash(const char *str) {
   static const uint32_t table[] = {0x66650001u,0x67660002u,0x62610003u,0x76750004u,0x6d6c0005u,0x75740006u,0x1000007u,0x80000000u};
   uint32_t cur = 0x65640000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* TreeDebugFactory::new_renderer(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = renderer_object_hash(name);
   switch(idx) {
      case 0:
         return new renderer_default(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_RENDERER, name);
         return new SubtypedDebugObject<ANARI_RENDERER>(td, wh, h, name);
   }
}
static int sampler_object_hash(const char *str) {
   static const uint32_t table[] = {0x6e6d000cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720019u,0x0u,0x0u,0x0u,0x73720022u,0x6261000du,0x6867000eu,0x6665000fu,0x34310010u,0x45440013u,0x45440015u,0x45440017u,0x1000014u,0x80000000u,0x1000016u,0x80000001u,0x1000018u,0x80000002u,0x6a69001au,0x6e6d001bu,0x6a69001cu,0x7574001du,0x6a69001eu,0x7776001fu,0x66650020u,0x1000021u,0x80000003u,0x62610023u,0x6f6e0024u,0x74730025u,0x67660026u,0x706f0027u,0x73720028u,0x6e6d0029u,0x100002au,0x80000004u};
   uint32_t cur = 0x75690000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* TreeDebugFactory::new_sampler(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = sampler_object_hash(name);
   switch(idx) {
      case 0:
         return new sampler_image1D(td, this, wh, h);
      case 1:
         return new sampler_image2D(td, this, wh, h);
      case 2:
         return new sampler_image3D(td, this, wh, h);
      case 3:
         return new sampler_primitive(td, this, wh, h);
      case 4:
         return new sampler_transform(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_SAMPLER, name);
         return new SubtypedDebugObject<ANARI_SAMPLER>(td, wh, h, name);
   }
}
static int spatial_field_object_hash(const char *str) {
   static const uint32_t table[] = {0x75740001u,0x73720002u,0x76750003u,0x64630004u,0x75740005u,0x76750006u,0x73720007u,0x66650008u,0x65640009u,0x5352000au,0x6665000bu,0x6867000cu,0x7675000du,0x6d6c000eu,0x6261000fu,0x73720010u,0x1000011u,0x80000000u};
   uint32_t cur = 0x74730000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* TreeDebugFactory::new_spatial_field(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = spatial_field_object_hash(name);
   switch(idx) {
      case 0:
         return new spatial_field_structuredRegular(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_SPATIAL_FIELD, name);
         return new SubtypedDebugObject<ANARI_SPATIAL_FIELD>(td, wh, h, name);
   }
}
static int volume_object_hash(const char *str) {
   static const uint32_t table[] = {0x64630001u,0x6a690002u,0x77760003u,0x6a690004u,0x74730005u,0x1000006u,0x80000000u};
   uint32_t cur = 0x74730000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* TreeDebugFactory::new_volume(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = volume_object_hash(name);
   switch(idx) {
      case 0:
         return new volume_scivis(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_VOLUME, name);
         return new SubtypedDebugObject<ANARI_VOLUME>(td, wh, h, name);
   }
}
DebugObjectBase* TreeDebugFactory::new_array1d(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new array1d(td, this, wh, h);
}
DebugObjectBase* TreeDebugFactory::new_array2d(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new array2d(td, this, wh, h);
}
DebugObjectBase* TreeDebugFactory::new_array3d(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new array3d(td, this, wh, h);
}
DebugObjectBase* TreeDebugFactory::new_device(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new device(td, this, wh, h);
}
DebugObjectBase* TreeDebugFactory::new_frame(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new frame(td, this, wh, h);
}
DebugObjectBase* TreeDebugFactory::new_group(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new group(td, this, wh, h);
}
DebugObjectBase* TreeDebugFactory::new_instance(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new instance(td, this, wh, h);
}
DebugObjectBase* TreeDebugFactory::new_surface(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new surface(td, this, wh, h);
}
DebugObjectBase* TreeDebugFactory::new_world(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new world(td, this, wh, h);
}
void TreeDebugFactory::print_summary(DebugDevice *td) {
   (void)td;
}
anari::debug_device::ObjectFactory* getDebugFactory() {
   static TreeDebugFactory f;
   return &f;
}
}
}
