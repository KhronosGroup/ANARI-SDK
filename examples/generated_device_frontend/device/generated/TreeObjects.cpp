// Copyright 2021 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_device_frontend.py
// Don't make changes to this directly

#include <stdint.h>
#include "TreeObjects.h"
namespace anari_sdk{
namespace tree{
static int param_hash(const char *str) {
   static const uint32_t table[] = {0x74630017u,0x0u,0x7030005cu,0x6a6100e2u,0x65640106u,0x7361010du,0x736501cdu,0x0u,0x736d01e6u,0x0u,0x0u,0x6a610313u,0x70610325u,0x70610365u,0x7666037cu,0x736f03ecu,0x0u,0x66610443u,0x76630477u,0x73690531u,0x71700546u,0x70610548u,0x736f05c7u,0x64630028u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x63620033u,0x0u,0x68670038u,0x0u,0x66650046u,0x0u,0x73720053u,0x71700057u,0x76750029u,0x6e6d002au,0x7675002bu,0x6d6c002cu,0x6261002du,0x7574002eu,0x6a69002fu,0x706f0030u,0x6f6e0031u,0x1000032u,0x80000000u,0x66650034u,0x65640035u,0x706f0036u,0x1000037u,0x80000001u,0x76750039u,0x6d6c003au,0x6261003bu,0x7372003cu,0x4544003du,0x6a69003eu,0x6261003fu,0x6e6d0040u,0x66650041u,0x75740042u,0x66650043u,0x73720044u,0x1000045u,0x80000002u,0x73720047u,0x75740048u,0x76750049u,0x7372004au,0x6665004bu,0x5352004cu,0x6261004du,0x6564004eu,0x6a69004fu,0x76750050u,0x74730051u,0x1000052u,0x80000003u,0x62610054u,0x7a790055u,0x1000056u,0x80000004u,0x66650058u,0x64630059u,0x7574005au,0x100005bu,0x80000005u,0x100009cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x716d009du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c00a7u,0x80000006u,0x666500a1u,0x0u,0x0u,0x747300a5u,0x737200a2u,0x626100a3u,0x10000a4u,0x80000007u,0x10000a6u,0x80000008u,0x706f00a8u,0x737200a9u,0x2f0000aau,0x80000009u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x717000d9u,0x706f00dau,0x747300dbu,0x6a6900dcu,0x757400ddu,0x6a6900deu,0x706f00dfu,0x6f6e00e0u,0x10000e1u,0x8000000au,0x757400ebu,0x0u,0x0u,0x0u,0x716e00eeu,0x0u,0x0u,0x0u,0x737200feu,0x626100ecu,0x10000edu,0x8000000bu,0x747300f1u,0x0u,0x757400fbu,0x6a6900f2u,0x757400f3u,0x7a7900f4u,0x545300f5u,0x646300f6u,0x626100f7u,0x6d6c00f8u,0x666500f9u,0x10000fau,0x8000000cu,0x696800fcu,0x10000fdu,0x8000000du,0x666500ffu,0x64630100u,0x75740101u,0x6a690102u,0x706f0103u,0x6f6e0104u,0x1000105u,0x8000000eu,0x68670107u,0x66650108u,0x33310109u,0x100010bu,0x100010cu,0x8000000fu,0x80000010u,0x6d6c011fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d65012au,0x0u,0x0u,0x0u,0x0u,0x0u,0x77630139u,0x0u,0x0u,0x6261015au,0x6d6c0120u,0x706f0121u,0x67660122u,0x67660123u,0x42410124u,0x6f6e0125u,0x68670126u,0x6d6c0127u,0x66650128u,0x1000129u,0x80000011u,0x6d6c0132u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x75740135u,0x65640133u,0x1000134u,0x80000012u,0x66650136u,0x73720137u,0x1000138u,0x80000013u,0x7675014du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7a790158u,0x7473014eu,0x4544014fu,0x6a690150u,0x74730151u,0x75740152u,0x62610153u,0x6f6e0154u,0x64630155u,0x66650156u,0x1000157u,0x80000014u,0x1000159u,0x80000015u,0x6e6d015bu,0x6665015cu,0x4443015du,0x706f015eu,0x6e6d015fu,0x71700160u,0x6d6c0161u,0x66650162u,0x75740163u,0x6a690164u,0x706f0165u,0x6f6e0166u,0x44430167u,0x62610168u,0x6d6c0169u,0x6d6c016au,0x6362016bu,0x6261016cu,0x6463016du,0x6c6b016eu,0x5600016fu,0x80000016u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x747301c5u,0x666501c6u,0x737201c7u,0x454401c8u,0x626101c9u,0x757401cau,0x626101cbu,0x10001ccu,0x80000017u,0x706f01dbu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f01e2u,0x6e6d01dcu,0x666501ddu,0x757401deu,0x737201dfu,0x7a7901e0u,0x10001e1u,0x80000018u,0x767501e3u,0x717001e4u,0x10001e5u,0x80000019u,0x626101ecu,0x75410248u,0x0u,0x0u,0x0u,0x7372030au,0x686701edu,0x666501eeu,0x530001efu,0x8000001au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x66650242u,0x68670243u,0x6a690244u,0x706f0245u,0x6f6e0246u,0x1000247u,0x8000001bu,0x7574027cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720285u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6665028eu,0x0u,0x0u,0x0u,0x0u,0x75740297u,0x6665029du,0x7574027du,0x7372027eu,0x6a69027fu,0x63620280u,0x76750281u,0x75740282u,0x66650283u,0x1000284u,0x8000001cu,0x62610286u,0x6f6e0287u,0x74730288u,0x67660289u,0x706f028au,0x7372028bu,0x6e6d028cu,0x100028du,0x8000001du,0x7372028fu,0x53520290u,0x62610291u,0x65640292u,0x6a690293u,0x76750294u,0x74730295u,0x1000296u,0x8000001eu,0x62610298u,0x6f6e0299u,0x6463029au,0x6665029bu,0x100029cu,0x8000001fu,0x736e029eu,0x747302a3u,0x0u,0x0u,0x0u,0x717002f8u,0x6a6902a4u,0x757402a5u,0x7a7902a6u,0x450002a7u,0x80000020u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a6902ecu,0x747302edu,0x757402eeu,0x737202efu,0x6a6902f0u,0x636202f1u,0x767502f2u,0x757402f3u,0x6a6902f4u,0x706f02f5u,0x6f6e02f6u,0x10002f7u,0x80000021u,0x767502f9u,0x717002fau,0x6a6902fbu,0x6d6c02fcu,0x6d6c02fdu,0x626102feu,0x737202ffu,0x7a790300u,0x45440301u,0x6a690302u,0x74730303u,0x75740304u,0x62610305u,0x6f6e0306u,0x64630307u,0x66650308u,0x1000309u,0x80000022u,0x6261030bu,0x6564030cu,0x6a69030du,0x6261030eu,0x6f6e030fu,0x64630310u,0x66650311u,0x1000312u,0x80000023u,0x7a79031cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x68670321u,0x706f031du,0x7675031eu,0x7574031fu,0x1000320u,0x80000024u,0x69680322u,0x75740323u,0x1000324u,0x80000025u,0x75740334u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7574033bu,0x66650335u,0x73720336u,0x6a690337u,0x62610338u,0x6d6c0339u,0x100033au,0x80000026u,0x6a69033cu,0x706f033du,0x6f6e033eu,0x2f2e033fu,0x75720340u,0x706f0343u,0x6463034bu,0x73720350u,0x75740344u,0x62610345u,0x75740346u,0x6a690347u,0x706f0348u,0x6f6e0349u,0x100034au,0x80000027u,0x6261034cu,0x6d6c034du,0x6665034eu,0x100034fu,0x80000028u,0x62610351u,0x6f6e0352u,0x74730353u,0x6d660354u,0x706f035bu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261035fu,0x7372035cu,0x6e6d035du,0x100035eu,0x80000029u,0x75740360u,0x6a690361u,0x706f0362u,0x6f6e0363u,0x1000364u,0x8000002au,0x6e6d0374u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720377u,0x66650375u,0x1000376u,0x8000002bu,0x6e6d0378u,0x62610379u,0x6d6c037au,0x100037bu,0x8000002cu,0x6766038cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x66610391u,0x0u,0x6a6903dcu,0x0u,0x0u,0x757403e1u,0x7473038du,0x6665038eu,0x7574038fu,0x1000390u,0x8000002du,0x64630396u,0x0u,0x0u,0x0u,0x6f6e03d2u,0x6a690397u,0x75740398u,0x7a790399u,0x2f00039au,0x8000002eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x717003c9u,0x706f03cau,0x747303cbu,0x6a6903ccu,0x757403cdu,0x6a6903ceu,0x706f03cfu,0x6f6e03d0u,0x10003d1u,0x8000002fu,0x6a6903d3u,0x6f6e03d4u,0x686703d5u,0x424103d6u,0x6f6e03d7u,0x686703d8u,0x6d6c03d9u,0x666503dau,0x10003dbu,0x80000030u,0x686703ddu,0x6a6903deu,0x6f6e03dfu,0x10003e0u,0x80000031u,0x555403e2u,0x737203e3u,0x626103e4u,0x6f6e03e5u,0x747303e6u,0x676603e7u,0x706f03e8u,0x737203e9u,0x6e6d03eau,0x10003ebu,0x80000032u,0x787303f0u,0x0u,0x0u,0x6a6903feu,0x6a6903f5u,0x0u,0x0u,0x0u,0x666503fbu,0x757403f6u,0x6a6903f7u,0x706f03f8u,0x6f6e03f9u,0x10003fau,0x80000033u,0x737203fcu,0x10003fdu,0x80000034u,0x6e6d03ffu,0x6a690400u,0x75740401u,0x6a690402u,0x77760403u,0x66650404u,0x2f2e0405u,0x73610406u,0x75740418u,0x0u,0x706f0428u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f64042du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261043du,0x75740419u,0x7372041au,0x6a69041bu,0x6362041cu,0x7675041du,0x7574041eu,0x6665041fu,0x34300420u,0x1000424u,0x1000425u,0x1000426u,0x1000427u,0x80000035u,0x80000036u,0x80000037u,0x80000038u,0x6d6c0429u,0x706f042au,0x7372042bu,0x100042cu,0x80000039u,0x1000438u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640439u,0x8000003au,0x6665043au,0x7978043bu,0x100043cu,0x8000003bu,0x6564043eu,0x6a69043fu,0x76750440u,0x74730441u,0x1000442u,0x8000003cu,0x65640448u,0x0u,0x0u,0x0u,0x6f670465u,0x6a690449u,0x7661044au,0x6f6e045fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x74730463u,0x64630460u,0x66650461u,0x1000462u,0x8000003du,0x1000464u,0x8000003eu,0x6a69046du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640471u,0x706f046eu,0x6f6e046fu,0x1000470u,0x8000003fu,0x66650472u,0x73720473u,0x66650474u,0x73720475u,0x1000476u,0x80000040u,0x6261048au,0x0u,0x0u,0x0u,0x0u,0x7675048eu,0x7b640494u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x626104afu,0x0u,0x0u,0x0u,0x666104b5u,0x7372052bu,0x6d6c048bu,0x6665048cu,0x100048du,0x80000041u,0x7574048fu,0x75740490u,0x66650491u,0x73720492u,0x1000493u,0x80000042u,0x666504abu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666504adu,0x10004acu,0x80000043u,0x10004aeu,0x80000044u,0x646304b0u,0x6a6904b1u,0x6f6e04b2u,0x686704b3u,0x10004b4u,0x80000045u,0x757404bau,0x0u,0x0u,0x0u,0x73720523u,0x767504bbu,0x747304bcu,0x444304bdu,0x626104beu,0x6d6c04bfu,0x6d6c04c0u,0x636204c1u,0x626104c2u,0x646304c3u,0x6c6b04c4u,0x560004c5u,0x80000046u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7473051bu,0x6665051cu,0x7372051du,0x4544051eu,0x6261051fu,0x75740520u,0x62610521u,0x1000522u,0x80000047u,0x66650524u,0x706f0525u,0x4e4d0526u,0x706f0527u,0x65640528u,0x66650529u,0x100052au,0x80000048u,0x6766052cu,0x6261052du,0x6463052eu,0x6665052fu,0x1000530u,0x80000049u,0x6e6d053bu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6261053eu,0x6665053cu,0x100053du,0x8000004au,0x6f6e053fu,0x74730540u,0x67660541u,0x706f0542u,0x73720543u,0x6e6d0544u,0x1000545u,0x8000004bu,0x1000547u,0x8000004cu,0x736c0557u,0x0u,0x0u,0x0u,0x7372056cu,0x0u,0x0u,0x0u,0x747305bcu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c05c2u,0x7675055eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a690566u,0x6665055fu,0x53520560u,0x62610561u,0x6f6e0562u,0x68670563u,0x66650564u,0x1000565u,0x8000004du,0x62610567u,0x6f6e0568u,0x64630569u,0x6665056au,0x100056bu,0x8000004eu,0x7574056du,0x6665056eu,0x7978056fu,0x2f2e0570u,0x73610571u,0x75740583u,0x0u,0x70610593u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f05a8u,0x0u,0x706f05aeu,0x0u,0x626105b6u,0x75740584u,0x73720585u,0x6a690586u,0x63620587u,0x76750588u,0x75740589u,0x6665058au,0x3430058bu,0x100058fu,0x1000590u,0x1000591u,0x1000592u,0x8000004fu,0x80000050u,0x80000051u,0x80000052u,0x717005a2u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c05a4u,0x10005a3u,0x80000053u,0x706f05a5u,0x737205a6u,0x10005a7u,0x80000054u,0x737205a9u,0x6e6d05aau,0x626105abu,0x6d6c05acu,0x10005adu,0x80000055u,0x747305afu,0x6a6905b0u,0x757405b1u,0x6a6905b2u,0x706f05b3u,0x6f6e05b4u,0x10005b5u,0x80000056u,0x656405b7u,0x6a6905b8u,0x767505b9u,0x747305bau,0x10005bbu,0x80000057u,0x6a6905bdu,0x636205beu,0x6d6c05bfu,0x666505c0u,0x10005c1u,0x80000058u,0x767505c3u,0x6e6d05c4u,0x666505c5u,0x10005c6u,0x80000059u,0x737205cbu,0x0u,0x0u,0x626105cfu,0x6d6c05ccu,0x656405cdu,0x10005ceu,0x8000005au,0x717005d0u,0x4e4d05d1u,0x706f05d2u,0x656405d3u,0x666505d4u,0x343105d5u,0x10005d8u,0x10005d9u,0x10005dau,0x8000005bu,0x8000005cu,0x8000005du};
   uint32_t cur = 0x78610000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
Device::Device(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Device::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 70: //statusCallback
         return statusCallback.set(device, object, type, mem);
      case 71: //statusCallbackUserData
         return statusCallbackUserData.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Device::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 70: //statusCallback
         statusCallback.unset(device, object);
         return;
      case 71: //statusCallbackUserData
         statusCallbackUserData.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Device::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return statusCallback;
      case 2: return statusCallbackUserData;
      default: return empty;
   }
}
ParameterBase& Device::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 70: return statusCallback;
      case 71: return statusCallbackUserData;
      default: return empty;
   }
}
const char ** Device::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "statusCallback",
      "statusCallbackUserData",
      nullptr
   };
   return paramnames;
}
size_t Device::paramCount() const {
   return 3;
}

Array1D::Array1D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Array1D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 63: //region
         return region.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Array1D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 63: //region
         region.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Array1D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return region;
      default: return empty;
   }
}
ParameterBase& Array1D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 63: return region;
      default: return empty;
   }
}
const char ** Array1D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "region",
      nullptr
   };
   return paramnames;
}
size_t Array1D::paramCount() const {
   return 2;
}

Array2D::Array2D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Array2D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Array2D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Array2D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      default: return empty;
   }
}
ParameterBase& Array2D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      default: return empty;
   }
}
const char ** Array2D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      nullptr
   };
   return paramnames;
}
size_t Array2D::paramCount() const {
   return 1;
}

Array3D::Array3D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Array3D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Array3D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Array3D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      default: return empty;
   }
}
ParameterBase& Array3D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      default: return empty;
   }
}
const char ** Array3D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      nullptr
   };
   return paramnames;
}
size_t Array3D::paramCount() const {
   return 1;
}

Frame::Frame(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      int32_t value[] = {INT32_C(0)};
      accumulation.set(device, object, ANARI_BOOL, value);
   }
   {
      int32_t value[] = {INT32_C(0)};
      variance.set(device, object, ANARI_BOOL, value);
   }
}
bool Frame::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 90: //world
         return world.set(device, object, type, mem);
      case 64: //renderer
         return renderer.set(device, object, type, mem);
      case 7: //camera
         return camera.set(device, object, type, mem);
      case 68: //size
         return size.set(device, object, type, mem);
      case 9: //color
         return color.set(device, object, type, mem);
      case 13: //depth
         return depth.set(device, object, type, mem);
      case 22: //frameCompletionCallback
         return frameCompletionCallback.set(device, object, type, mem);
      case 23: //frameCompletionCallbackUserData
         return frameCompletionCallbackUserData.set(device, object, type, mem);
      case 44: //normal
         return normal.set(device, object, type, mem);
      case 1: //albedo
         return albedo.set(device, object, type, mem);
      case 0: //accumulation
         return accumulation.set(device, object, type, mem);
      case 78: //variance
         return variance.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Frame::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 90: //world
         world.unset(device, object);
         return;
      case 64: //renderer
         renderer.unset(device, object);
         return;
      case 7: //camera
         camera.unset(device, object);
         return;
      case 68: //size
         size.unset(device, object);
         return;
      case 9: //color
         color.unset(device, object);
         return;
      case 13: //depth
         depth.unset(device, object);
         return;
      case 22: //frameCompletionCallback
         frameCompletionCallback.unset(device, object);
         return;
      case 23: //frameCompletionCallbackUserData
         frameCompletionCallbackUserData.unset(device, object);
         return;
      case 44: //normal
         normal.unset(device, object);
         return;
      case 1: //albedo
         albedo.unset(device, object);
         return;
      case 0: //accumulation
         {
            int32_t value[] = {INT32_C(0)};
            accumulation.set(device, object, ANARI_BOOL, value);
         }
         return;
      case 78: //variance
         {
            int32_t value[] = {INT32_C(0)};
            variance.set(device, object, ANARI_BOOL, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Frame::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return world;
      case 2: return renderer;
      case 3: return camera;
      case 4: return size;
      case 5: return color;
      case 6: return depth;
      case 7: return frameCompletionCallback;
      case 8: return frameCompletionCallbackUserData;
      case 9: return normal;
      case 10: return albedo;
      case 11: return accumulation;
      case 12: return variance;
      default: return empty;
   }
}
ParameterBase& Frame::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 90: return world;
      case 64: return renderer;
      case 7: return camera;
      case 68: return size;
      case 9: return color;
      case 13: return depth;
      case 22: return frameCompletionCallback;
      case 23: return frameCompletionCallbackUserData;
      case 44: return normal;
      case 1: return albedo;
      case 0: return accumulation;
      case 78: return variance;
      default: return empty;
   }
}
const char ** Frame::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "world",
      "renderer",
      "camera",
      "size",
      "color",
      "depth",
      "frameCompletionCallback",
      "frameCompletionCallbackUserData",
      "normal",
      "albedo",
      "accumulation",
      "variance",
      nullptr
   };
   return paramnames;
}
size_t Frame::paramCount() const {
   return 13;
}

Group::Group(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Group::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 73: //surface
         return surface.set(device, object, type, mem);
      case 89: //volume
         return volume.set(device, object, type, mem);
      case 37: //light
         return light.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Group::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 73: //surface
         surface.unset(device, object);
         return;
      case 89: //volume
         volume.unset(device, object);
         return;
      case 37: //light
         light.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Group::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return surface;
      case 2: return volume;
      case 3: return light;
      default: return empty;
   }
}
ParameterBase& Group::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 73: return surface;
      case 89: return volume;
      case 37: return light;
      default: return empty;
   }
}
const char ** Group::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "surface",
      "volume",
      "light",
      nullptr
   };
   return paramnames;
}
size_t Group::paramCount() const {
   return 4;
}

Instance::Instance(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      transform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {0.000000f, 1.000000f};
      time.set(device, object, ANARI_FLOAT32_BOX1, value);
   }
}
bool Instance::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 75: //transform
         return transform.set(device, object, type, mem);
      case 25: //group
         return group.set(device, object, type, mem);
      case 41: //motion.transform
         return motion_transform.set(device, object, type, mem);
      case 40: //motion.scale
         return motion_scale.set(device, object, type, mem);
      case 39: //motion.rotation
         return motion_rotation.set(device, object, type, mem);
      case 42: //motion.translation
         return motion_translation.set(device, object, type, mem);
      case 74: //time
         return time.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Instance::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 75: //transform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            transform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 25: //group
         group.unset(device, object);
         return;
      case 41: //motion.transform
         motion_transform.unset(device, object);
         return;
      case 40: //motion.scale
         motion_scale.unset(device, object);
         return;
      case 39: //motion.rotation
         motion_rotation.unset(device, object);
         return;
      case 42: //motion.translation
         motion_translation.unset(device, object);
         return;
      case 74: //time
         {
            float value[] = {0.000000f, 1.000000f};
            time.set(device, object, ANARI_FLOAT32_BOX1, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Instance::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return transform;
      case 2: return group;
      case 3: return motion_transform;
      case 4: return motion_scale;
      case 5: return motion_rotation;
      case 6: return motion_translation;
      case 7: return time;
      default: return empty;
   }
}
ParameterBase& Instance::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 75: return transform;
      case 25: return group;
      case 41: return motion_transform;
      case 40: return motion_scale;
      case 39: return motion_rotation;
      case 42: return motion_translation;
      case 74: return time;
      default: return empty;
   }
}
const char ** Instance::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "transform",
      "group",
      "motion.transform",
      "motion.scale",
      "motion.rotation",
      "motion.translation",
      "time",
      nullptr
   };
   return paramnames;
}
size_t Instance::paramCount() const {
   return 8;
}

World::World(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool World::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 31: //instance
         return instance.set(device, object, type, mem);
      case 73: //surface
         return surface.set(device, object, type, mem);
      case 89: //volume
         return volume.set(device, object, type, mem);
      case 37: //light
         return light.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void World::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 31: //instance
         instance.unset(device, object);
         return;
      case 73: //surface
         surface.unset(device, object);
         return;
      case 89: //volume
         volume.unset(device, object);
         return;
      case 37: //light
         light.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& World::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return instance;
      case 2: return surface;
      case 3: return volume;
      case 4: return light;
      default: return empty;
   }
}
ParameterBase& World::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 31: return instance;
      case 73: return surface;
      case 89: return volume;
      case 37: return light;
      default: return empty;
   }
}
const char ** World::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "instance",
      "surface",
      "volume",
      "light",
      nullptr
   };
   return paramnames;
}
size_t World::paramCount() const {
   return 5;
}

RendererDefault::RendererDefault(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool RendererDefault::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void RendererDefault::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& RendererDefault::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      default: return empty;
   }
}
ParameterBase& RendererDefault::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      default: return empty;
   }
}
const char ** RendererDefault::paramNames() const {
   static const char *paramnames[] = {
      "name",
      nullptr
   };
   return paramnames;
}
size_t RendererDefault::paramCount() const {
   return 1;
}

Surface::Surface(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool Surface::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 24: //geometry
         return geometry.set(device, object, type, mem);
      case 38: //material
         return material.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Surface::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 24: //geometry
         geometry.unset(device, object);
         return;
      case 38: //material
         material.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Surface::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return geometry;
      case 2: return material;
      default: return empty;
   }
}
ParameterBase& Surface::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 24: return geometry;
      case 38: return material;
      default: return empty;
   }
}
const char ** Surface::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "geometry",
      "material",
      nullptr
   };
   return paramnames;
}
size_t Surface::paramCount() const {
   return 3;
}

CameraOmnidirectional::CameraOmnidirectional(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, -1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 1.000000f, 0.000000f};
      up.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f};
      transform.set(device, object, ANARI_FLOAT32_MAT3x4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
      imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
   }
   {
      float value[] = {0.000000f};
      apertureRadius.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      focusDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "none";
      stereoMode.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {0.063500f};
      interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "equirectangular";
      layout.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {0.000000f, 1.000000f};
      time.set(device, object, ANARI_FLOAT32_BOX1, value);
   }
   {
      float value[] = {0.500000f, 0.500000f};
      shutter.set(device, object, ANARI_FLOAT32_BOX1, value);
   }
}
bool CameraOmnidirectional::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 51: //position
         return position.set(device, object, type, mem);
      case 14: //direction
         return direction.set(device, object, type, mem);
      case 76: //up
         return up.set(device, object, type, mem);
      case 75: //transform
         return transform.set(device, object, type, mem);
      case 27: //imageRegion
         return imageRegion.set(device, object, type, mem);
      case 3: //apertureRadius
         return apertureRadius.set(device, object, type, mem);
      case 20: //focusDistance
         return focusDistance.set(device, object, type, mem);
      case 72: //stereoMode
         return stereoMode.set(device, object, type, mem);
      case 34: //interpupillaryDistance
         return interpupillaryDistance.set(device, object, type, mem);
      case 36: //layout
         return layout.set(device, object, type, mem);
      case 41: //motion.transform
         return motion_transform.set(device, object, type, mem);
      case 40: //motion.scale
         return motion_scale.set(device, object, type, mem);
      case 39: //motion.rotation
         return motion_rotation.set(device, object, type, mem);
      case 42: //motion.translation
         return motion_translation.set(device, object, type, mem);
      case 74: //time
         return time.set(device, object, type, mem);
      case 66: //shutter
         return shutter.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void CameraOmnidirectional::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 51: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 14: //direction
         {
            float value[] = {0.000000f, 0.000000f, -1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 76: //up
         {
            float value[] = {0.000000f, 1.000000f, 0.000000f};
            up.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 75: //transform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f};
            transform.set(device, object, ANARI_FLOAT32_MAT3x4, value);
         }
         return;
      case 27: //imageRegion
         {
            float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
         }
         return;
      case 3: //apertureRadius
         {
            float value[] = {0.000000f};
            apertureRadius.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 20: //focusDistance
         {
            float value[] = {1.000000f};
            focusDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 72: //stereoMode
         {
            const char *value = "none";
            stereoMode.set(device, object, ANARI_STRING, value);
         }
         return;
      case 34: //interpupillaryDistance
         {
            float value[] = {0.063500f};
            interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 36: //layout
         {
            const char *value = "equirectangular";
            layout.set(device, object, ANARI_STRING, value);
         }
         return;
      case 41: //motion.transform
         motion_transform.unset(device, object);
         return;
      case 40: //motion.scale
         motion_scale.unset(device, object);
         return;
      case 39: //motion.rotation
         motion_rotation.unset(device, object);
         return;
      case 42: //motion.translation
         motion_translation.unset(device, object);
         return;
      case 74: //time
         {
            float value[] = {0.000000f, 1.000000f};
            time.set(device, object, ANARI_FLOAT32_BOX1, value);
         }
         return;
      case 66: //shutter
         {
            float value[] = {0.500000f, 0.500000f};
            shutter.set(device, object, ANARI_FLOAT32_BOX1, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& CameraOmnidirectional::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return position;
      case 2: return direction;
      case 3: return up;
      case 4: return transform;
      case 5: return imageRegion;
      case 6: return apertureRadius;
      case 7: return focusDistance;
      case 8: return stereoMode;
      case 9: return interpupillaryDistance;
      case 10: return layout;
      case 11: return motion_transform;
      case 12: return motion_scale;
      case 13: return motion_rotation;
      case 14: return motion_translation;
      case 15: return time;
      case 16: return shutter;
      default: return empty;
   }
}
ParameterBase& CameraOmnidirectional::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 51: return position;
      case 14: return direction;
      case 76: return up;
      case 75: return transform;
      case 27: return imageRegion;
      case 3: return apertureRadius;
      case 20: return focusDistance;
      case 72: return stereoMode;
      case 34: return interpupillaryDistance;
      case 36: return layout;
      case 41: return motion_transform;
      case 40: return motion_scale;
      case 39: return motion_rotation;
      case 42: return motion_translation;
      case 74: return time;
      case 66: return shutter;
      default: return empty;
   }
}
const char ** CameraOmnidirectional::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "position",
      "direction",
      "up",
      "transform",
      "imageRegion",
      "apertureRadius",
      "focusDistance",
      "stereoMode",
      "interpupillaryDistance",
      "layout",
      "motion.transform",
      "motion.scale",
      "motion.rotation",
      "motion.translation",
      "time",
      "shutter",
      nullptr
   };
   return paramnames;
}
size_t CameraOmnidirectional::paramCount() const {
   return 17;
}

CameraOrthographic::CameraOrthographic(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, -1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 1.000000f, 0.000000f};
      up.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f};
      transform.set(device, object, ANARI_FLOAT32_MAT3x4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
      imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
   }
   {
      float value[] = {0.000000f};
      apertureRadius.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      focusDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "none";
      stereoMode.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {0.063500f};
      interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      aspect.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f, 1.000000f};
      time.set(device, object, ANARI_FLOAT32_BOX1, value);
   }
   {
      float value[] = {0.500000f, 0.500000f};
      shutter.set(device, object, ANARI_FLOAT32_BOX1, value);
   }
}
bool CameraOrthographic::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 51: //position
         return position.set(device, object, type, mem);
      case 14: //direction
         return direction.set(device, object, type, mem);
      case 76: //up
         return up.set(device, object, type, mem);
      case 75: //transform
         return transform.set(device, object, type, mem);
      case 27: //imageRegion
         return imageRegion.set(device, object, type, mem);
      case 3: //apertureRadius
         return apertureRadius.set(device, object, type, mem);
      case 20: //focusDistance
         return focusDistance.set(device, object, type, mem);
      case 72: //stereoMode
         return stereoMode.set(device, object, type, mem);
      case 34: //interpupillaryDistance
         return interpupillaryDistance.set(device, object, type, mem);
      case 5: //aspect
         return aspect.set(device, object, type, mem);
      case 41: //motion.transform
         return motion_transform.set(device, object, type, mem);
      case 40: //motion.scale
         return motion_scale.set(device, object, type, mem);
      case 39: //motion.rotation
         return motion_rotation.set(device, object, type, mem);
      case 42: //motion.translation
         return motion_translation.set(device, object, type, mem);
      case 74: //time
         return time.set(device, object, type, mem);
      case 66: //shutter
         return shutter.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void CameraOrthographic::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 51: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 14: //direction
         {
            float value[] = {0.000000f, 0.000000f, -1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 76: //up
         {
            float value[] = {0.000000f, 1.000000f, 0.000000f};
            up.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 75: //transform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f};
            transform.set(device, object, ANARI_FLOAT32_MAT3x4, value);
         }
         return;
      case 27: //imageRegion
         {
            float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
         }
         return;
      case 3: //apertureRadius
         {
            float value[] = {0.000000f};
            apertureRadius.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 20: //focusDistance
         {
            float value[] = {1.000000f};
            focusDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 72: //stereoMode
         {
            const char *value = "none";
            stereoMode.set(device, object, ANARI_STRING, value);
         }
         return;
      case 34: //interpupillaryDistance
         {
            float value[] = {0.063500f};
            interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 5: //aspect
         {
            float value[] = {1.000000f};
            aspect.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 41: //motion.transform
         motion_transform.unset(device, object);
         return;
      case 40: //motion.scale
         motion_scale.unset(device, object);
         return;
      case 39: //motion.rotation
         motion_rotation.unset(device, object);
         return;
      case 42: //motion.translation
         motion_translation.unset(device, object);
         return;
      case 74: //time
         {
            float value[] = {0.000000f, 1.000000f};
            time.set(device, object, ANARI_FLOAT32_BOX1, value);
         }
         return;
      case 66: //shutter
         {
            float value[] = {0.500000f, 0.500000f};
            shutter.set(device, object, ANARI_FLOAT32_BOX1, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& CameraOrthographic::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return position;
      case 2: return direction;
      case 3: return up;
      case 4: return transform;
      case 5: return imageRegion;
      case 6: return apertureRadius;
      case 7: return focusDistance;
      case 8: return stereoMode;
      case 9: return interpupillaryDistance;
      case 10: return aspect;
      case 11: return motion_transform;
      case 12: return motion_scale;
      case 13: return motion_rotation;
      case 14: return motion_translation;
      case 15: return time;
      case 16: return shutter;
      default: return empty;
   }
}
ParameterBase& CameraOrthographic::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 51: return position;
      case 14: return direction;
      case 76: return up;
      case 75: return transform;
      case 27: return imageRegion;
      case 3: return apertureRadius;
      case 20: return focusDistance;
      case 72: return stereoMode;
      case 34: return interpupillaryDistance;
      case 5: return aspect;
      case 41: return motion_transform;
      case 40: return motion_scale;
      case 39: return motion_rotation;
      case 42: return motion_translation;
      case 74: return time;
      case 66: return shutter;
      default: return empty;
   }
}
const char ** CameraOrthographic::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "position",
      "direction",
      "up",
      "transform",
      "imageRegion",
      "apertureRadius",
      "focusDistance",
      "stereoMode",
      "interpupillaryDistance",
      "aspect",
      "motion.transform",
      "motion.scale",
      "motion.rotation",
      "motion.translation",
      "time",
      "shutter",
      nullptr
   };
   return paramnames;
}
size_t CameraOrthographic::paramCount() const {
   return 17;
}

CameraPerspective::CameraPerspective(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, -1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 1.000000f, 0.000000f};
      up.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f};
      transform.set(device, object, ANARI_FLOAT32_MAT3x4, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
      imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
   }
   {
      float value[] = {0.000000f};
      apertureRadius.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      focusDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "none";
      stereoMode.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {0.063500f};
      interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.047198f};
      fovy.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      aspect.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f, 1.000000f};
      time.set(device, object, ANARI_FLOAT32_BOX1, value);
   }
   {
      float value[] = {0.500000f, 0.500000f};
      shutter.set(device, object, ANARI_FLOAT32_BOX1, value);
   }
}
bool CameraPerspective::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 51: //position
         return position.set(device, object, type, mem);
      case 14: //direction
         return direction.set(device, object, type, mem);
      case 76: //up
         return up.set(device, object, type, mem);
      case 75: //transform
         return transform.set(device, object, type, mem);
      case 27: //imageRegion
         return imageRegion.set(device, object, type, mem);
      case 3: //apertureRadius
         return apertureRadius.set(device, object, type, mem);
      case 20: //focusDistance
         return focusDistance.set(device, object, type, mem);
      case 72: //stereoMode
         return stereoMode.set(device, object, type, mem);
      case 34: //interpupillaryDistance
         return interpupillaryDistance.set(device, object, type, mem);
      case 21: //fovy
         return fovy.set(device, object, type, mem);
      case 5: //aspect
         return aspect.set(device, object, type, mem);
      case 41: //motion.transform
         return motion_transform.set(device, object, type, mem);
      case 40: //motion.scale
         return motion_scale.set(device, object, type, mem);
      case 39: //motion.rotation
         return motion_rotation.set(device, object, type, mem);
      case 42: //motion.translation
         return motion_translation.set(device, object, type, mem);
      case 74: //time
         return time.set(device, object, type, mem);
      case 66: //shutter
         return shutter.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void CameraPerspective::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 51: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 14: //direction
         {
            float value[] = {0.000000f, 0.000000f, -1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 76: //up
         {
            float value[] = {0.000000f, 1.000000f, 0.000000f};
            up.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 75: //transform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f};
            transform.set(device, object, ANARI_FLOAT32_MAT3x4, value);
         }
         return;
      case 27: //imageRegion
         {
            float value[] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            imageRegion.set(device, object, ANARI_FLOAT32_BOX2, value);
         }
         return;
      case 3: //apertureRadius
         {
            float value[] = {0.000000f};
            apertureRadius.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 20: //focusDistance
         {
            float value[] = {1.000000f};
            focusDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 72: //stereoMode
         {
            const char *value = "none";
            stereoMode.set(device, object, ANARI_STRING, value);
         }
         return;
      case 34: //interpupillaryDistance
         {
            float value[] = {0.063500f};
            interpupillaryDistance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 21: //fovy
         {
            float value[] = {1.047198f};
            fovy.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 5: //aspect
         {
            float value[] = {1.000000f};
            aspect.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 41: //motion.transform
         motion_transform.unset(device, object);
         return;
      case 40: //motion.scale
         motion_scale.unset(device, object);
         return;
      case 39: //motion.rotation
         motion_rotation.unset(device, object);
         return;
      case 42: //motion.translation
         motion_translation.unset(device, object);
         return;
      case 74: //time
         {
            float value[] = {0.000000f, 1.000000f};
            time.set(device, object, ANARI_FLOAT32_BOX1, value);
         }
         return;
      case 66: //shutter
         {
            float value[] = {0.500000f, 0.500000f};
            shutter.set(device, object, ANARI_FLOAT32_BOX1, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& CameraPerspective::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return position;
      case 2: return direction;
      case 3: return up;
      case 4: return transform;
      case 5: return imageRegion;
      case 6: return apertureRadius;
      case 7: return focusDistance;
      case 8: return stereoMode;
      case 9: return interpupillaryDistance;
      case 10: return fovy;
      case 11: return aspect;
      case 12: return motion_transform;
      case 13: return motion_scale;
      case 14: return motion_rotation;
      case 15: return motion_translation;
      case 16: return time;
      case 17: return shutter;
      default: return empty;
   }
}
ParameterBase& CameraPerspective::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 51: return position;
      case 14: return direction;
      case 76: return up;
      case 75: return transform;
      case 27: return imageRegion;
      case 3: return apertureRadius;
      case 20: return focusDistance;
      case 72: return stereoMode;
      case 34: return interpupillaryDistance;
      case 21: return fovy;
      case 5: return aspect;
      case 41: return motion_transform;
      case 40: return motion_scale;
      case 39: return motion_rotation;
      case 42: return motion_translation;
      case 74: return time;
      case 66: return shutter;
      default: return empty;
   }
}
const char ** CameraPerspective::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "position",
      "direction",
      "up",
      "transform",
      "imageRegion",
      "apertureRadius",
      "focusDistance",
      "stereoMode",
      "interpupillaryDistance",
      "fovy",
      "aspect",
      "motion.transform",
      "motion.scale",
      "motion.rotation",
      "motion.translation",
      "time",
      "shutter",
      nullptr
   };
   return paramnames;
}
size_t CameraPerspective::paramCount() const {
   return 18;
}

GeometryCone::GeometryCone(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "none";
      caps.set(device, object, ANARI_STRING, value);
   }
}
bool GeometryCone::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 57: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 53: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 54: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 55: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 56: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 58: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 86: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 87: //vertex.radius
         return vertex_radius.set(device, object, type, mem);
      case 83: //vertex.cap
         return vertex_cap.set(device, object, type, mem);
      case 84: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 79: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 80: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 81: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 82: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 59: //primitive.index
         return primitive_index.set(device, object, type, mem);
      case 8: //caps
         return caps.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometryCone::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 57: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 53: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 54: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 55: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 56: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 58: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 86: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 87: //vertex.radius
         vertex_radius.unset(device, object);
         return;
      case 83: //vertex.cap
         vertex_cap.unset(device, object);
         return;
      case 84: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 79: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 80: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 81: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 82: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 59: //primitive.index
         primitive_index.unset(device, object);
         return;
      case 8: //caps
         {
            const char *value = "none";
            caps.set(device, object, ANARI_STRING, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometryCone::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_radius;
      case 9: return vertex_cap;
      case 10: return vertex_color;
      case 11: return vertex_attribute0;
      case 12: return vertex_attribute1;
      case 13: return vertex_attribute2;
      case 14: return vertex_attribute3;
      case 15: return primitive_index;
      case 16: return caps;
      default: return empty;
   }
}
ParameterBase& GeometryCone::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 57: return primitive_color;
      case 53: return primitive_attribute0;
      case 54: return primitive_attribute1;
      case 55: return primitive_attribute2;
      case 56: return primitive_attribute3;
      case 58: return primitive_id;
      case 86: return vertex_position;
      case 87: return vertex_radius;
      case 83: return vertex_cap;
      case 84: return vertex_color;
      case 79: return vertex_attribute0;
      case 80: return vertex_attribute1;
      case 81: return vertex_attribute2;
      case 82: return vertex_attribute3;
      case 59: return primitive_index;
      case 8: return caps;
      default: return empty;
   }
}
const char ** GeometryCone::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.radius",
      "vertex.cap",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      "caps",
      nullptr
   };
   return paramnames;
}
size_t GeometryCone::paramCount() const {
   return 17;
}

GeometryCurve::GeometryCurve(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool GeometryCurve::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 57: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 53: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 54: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 55: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 56: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 58: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 86: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 87: //vertex.radius
         return vertex_radius.set(device, object, type, mem);
      case 84: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 79: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 80: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 81: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 82: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 59: //primitive.index
         return primitive_index.set(device, object, type, mem);
      case 62: //radius
         return radius.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometryCurve::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 57: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 53: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 54: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 55: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 56: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 58: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 86: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 87: //vertex.radius
         vertex_radius.unset(device, object);
         return;
      case 84: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 79: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 80: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 81: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 82: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 59: //primitive.index
         primitive_index.unset(device, object);
         return;
      case 62: //radius
         radius.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometryCurve::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_radius;
      case 9: return vertex_color;
      case 10: return vertex_attribute0;
      case 11: return vertex_attribute1;
      case 12: return vertex_attribute2;
      case 13: return vertex_attribute3;
      case 14: return primitive_index;
      case 15: return radius;
      default: return empty;
   }
}
ParameterBase& GeometryCurve::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 57: return primitive_color;
      case 53: return primitive_attribute0;
      case 54: return primitive_attribute1;
      case 55: return primitive_attribute2;
      case 56: return primitive_attribute3;
      case 58: return primitive_id;
      case 86: return vertex_position;
      case 87: return vertex_radius;
      case 84: return vertex_color;
      case 79: return vertex_attribute0;
      case 80: return vertex_attribute1;
      case 81: return vertex_attribute2;
      case 82: return vertex_attribute3;
      case 59: return primitive_index;
      case 62: return radius;
      default: return empty;
   }
}
const char ** GeometryCurve::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.radius",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      "radius",
      nullptr
   };
   return paramnames;
}
size_t GeometryCurve::paramCount() const {
   return 16;
}

GeometryCylinder::GeometryCylinder(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "none";
      caps.set(device, object, ANARI_STRING, value);
   }
}
bool GeometryCylinder::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 57: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 53: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 54: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 55: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 56: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 58: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 86: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 83: //vertex.cap
         return vertex_cap.set(device, object, type, mem);
      case 84: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 79: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 80: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 81: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 82: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 59: //primitive.index
         return primitive_index.set(device, object, type, mem);
      case 60: //primitive.radius
         return primitive_radius.set(device, object, type, mem);
      case 62: //radius
         return radius.set(device, object, type, mem);
      case 8: //caps
         return caps.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometryCylinder::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 57: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 53: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 54: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 55: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 56: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 58: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 86: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 83: //vertex.cap
         vertex_cap.unset(device, object);
         return;
      case 84: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 79: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 80: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 81: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 82: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 59: //primitive.index
         primitive_index.unset(device, object);
         return;
      case 60: //primitive.radius
         primitive_radius.unset(device, object);
         return;
      case 62: //radius
         radius.unset(device, object);
         return;
      case 8: //caps
         {
            const char *value = "none";
            caps.set(device, object, ANARI_STRING, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometryCylinder::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_cap;
      case 9: return vertex_color;
      case 10: return vertex_attribute0;
      case 11: return vertex_attribute1;
      case 12: return vertex_attribute2;
      case 13: return vertex_attribute3;
      case 14: return primitive_index;
      case 15: return primitive_radius;
      case 16: return radius;
      case 17: return caps;
      default: return empty;
   }
}
ParameterBase& GeometryCylinder::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 57: return primitive_color;
      case 53: return primitive_attribute0;
      case 54: return primitive_attribute1;
      case 55: return primitive_attribute2;
      case 56: return primitive_attribute3;
      case 58: return primitive_id;
      case 86: return vertex_position;
      case 83: return vertex_cap;
      case 84: return vertex_color;
      case 79: return vertex_attribute0;
      case 80: return vertex_attribute1;
      case 81: return vertex_attribute2;
      case 82: return vertex_attribute3;
      case 59: return primitive_index;
      case 60: return primitive_radius;
      case 62: return radius;
      case 8: return caps;
      default: return empty;
   }
}
const char ** GeometryCylinder::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.cap",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      "primitive.radius",
      "radius",
      "caps",
      nullptr
   };
   return paramnames;
}
size_t GeometryCylinder::paramCount() const {
   return 18;
}

GeometryQuad::GeometryQuad(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool GeometryQuad::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 57: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 53: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 54: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 55: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 56: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 58: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 86: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 85: //vertex.normal
         return vertex_normal.set(device, object, type, mem);
      case 84: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 79: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 80: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 81: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 82: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 59: //primitive.index
         return primitive_index.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometryQuad::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 57: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 53: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 54: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 55: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 56: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 58: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 86: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 85: //vertex.normal
         vertex_normal.unset(device, object);
         return;
      case 84: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 79: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 80: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 81: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 82: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 59: //primitive.index
         primitive_index.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometryQuad::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_normal;
      case 9: return vertex_color;
      case 10: return vertex_attribute0;
      case 11: return vertex_attribute1;
      case 12: return vertex_attribute2;
      case 13: return vertex_attribute3;
      case 14: return primitive_index;
      default: return empty;
   }
}
ParameterBase& GeometryQuad::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 57: return primitive_color;
      case 53: return primitive_attribute0;
      case 54: return primitive_attribute1;
      case 55: return primitive_attribute2;
      case 56: return primitive_attribute3;
      case 58: return primitive_id;
      case 86: return vertex_position;
      case 85: return vertex_normal;
      case 84: return vertex_color;
      case 79: return vertex_attribute0;
      case 80: return vertex_attribute1;
      case 81: return vertex_attribute2;
      case 82: return vertex_attribute3;
      case 59: return primitive_index;
      default: return empty;
   }
}
const char ** GeometryQuad::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.normal",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      nullptr
   };
   return paramnames;
}
size_t GeometryQuad::paramCount() const {
   return 15;
}

GeometrySphere::GeometrySphere(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool GeometrySphere::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 57: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 53: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 54: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 55: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 56: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 58: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 86: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 87: //vertex.radius
         return vertex_radius.set(device, object, type, mem);
      case 84: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 79: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 80: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 81: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 82: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 59: //primitive.index
         return primitive_index.set(device, object, type, mem);
      case 62: //radius
         return radius.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometrySphere::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 57: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 53: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 54: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 55: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 56: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 58: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 86: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 87: //vertex.radius
         vertex_radius.unset(device, object);
         return;
      case 84: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 79: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 80: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 81: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 82: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 59: //primitive.index
         primitive_index.unset(device, object);
         return;
      case 62: //radius
         radius.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometrySphere::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_radius;
      case 9: return vertex_color;
      case 10: return vertex_attribute0;
      case 11: return vertex_attribute1;
      case 12: return vertex_attribute2;
      case 13: return vertex_attribute3;
      case 14: return primitive_index;
      case 15: return radius;
      default: return empty;
   }
}
ParameterBase& GeometrySphere::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 57: return primitive_color;
      case 53: return primitive_attribute0;
      case 54: return primitive_attribute1;
      case 55: return primitive_attribute2;
      case 56: return primitive_attribute3;
      case 58: return primitive_id;
      case 86: return vertex_position;
      case 87: return vertex_radius;
      case 84: return vertex_color;
      case 79: return vertex_attribute0;
      case 80: return vertex_attribute1;
      case 81: return vertex_attribute2;
      case 82: return vertex_attribute3;
      case 59: return primitive_index;
      case 62: return radius;
      default: return empty;
   }
}
const char ** GeometrySphere::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.radius",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      "radius",
      nullptr
   };
   return paramnames;
}
size_t GeometrySphere::paramCount() const {
   return 16;
}

GeometryTriangle::GeometryTriangle(ANARIDevice device, ANARIObject o) : device(device), object(o) {
}
bool GeometryTriangle::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 57: //primitive.color
         return primitive_color.set(device, object, type, mem);
      case 53: //primitive.attribute0
         return primitive_attribute0.set(device, object, type, mem);
      case 54: //primitive.attribute1
         return primitive_attribute1.set(device, object, type, mem);
      case 55: //primitive.attribute2
         return primitive_attribute2.set(device, object, type, mem);
      case 56: //primitive.attribute3
         return primitive_attribute3.set(device, object, type, mem);
      case 58: //primitive.id
         return primitive_id.set(device, object, type, mem);
      case 86: //vertex.position
         return vertex_position.set(device, object, type, mem);
      case 85: //vertex.normal
         return vertex_normal.set(device, object, type, mem);
      case 84: //vertex.color
         return vertex_color.set(device, object, type, mem);
      case 79: //vertex.attribute0
         return vertex_attribute0.set(device, object, type, mem);
      case 80: //vertex.attribute1
         return vertex_attribute1.set(device, object, type, mem);
      case 81: //vertex.attribute2
         return vertex_attribute2.set(device, object, type, mem);
      case 82: //vertex.attribute3
         return vertex_attribute3.set(device, object, type, mem);
      case 59: //primitive.index
         return primitive_index.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void GeometryTriangle::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 57: //primitive.color
         primitive_color.unset(device, object);
         return;
      case 53: //primitive.attribute0
         primitive_attribute0.unset(device, object);
         return;
      case 54: //primitive.attribute1
         primitive_attribute1.unset(device, object);
         return;
      case 55: //primitive.attribute2
         primitive_attribute2.unset(device, object);
         return;
      case 56: //primitive.attribute3
         primitive_attribute3.unset(device, object);
         return;
      case 58: //primitive.id
         primitive_id.unset(device, object);
         return;
      case 86: //vertex.position
         vertex_position.unset(device, object);
         return;
      case 85: //vertex.normal
         vertex_normal.unset(device, object);
         return;
      case 84: //vertex.color
         vertex_color.unset(device, object);
         return;
      case 79: //vertex.attribute0
         vertex_attribute0.unset(device, object);
         return;
      case 80: //vertex.attribute1
         vertex_attribute1.unset(device, object);
         return;
      case 81: //vertex.attribute2
         vertex_attribute2.unset(device, object);
         return;
      case 82: //vertex.attribute3
         vertex_attribute3.unset(device, object);
         return;
      case 59: //primitive.index
         primitive_index.unset(device, object);
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& GeometryTriangle::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return primitive_color;
      case 2: return primitive_attribute0;
      case 3: return primitive_attribute1;
      case 4: return primitive_attribute2;
      case 5: return primitive_attribute3;
      case 6: return primitive_id;
      case 7: return vertex_position;
      case 8: return vertex_normal;
      case 9: return vertex_color;
      case 10: return vertex_attribute0;
      case 11: return vertex_attribute1;
      case 12: return vertex_attribute2;
      case 13: return vertex_attribute3;
      case 14: return primitive_index;
      default: return empty;
   }
}
ParameterBase& GeometryTriangle::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 57: return primitive_color;
      case 53: return primitive_attribute0;
      case 54: return primitive_attribute1;
      case 55: return primitive_attribute2;
      case 56: return primitive_attribute3;
      case 58: return primitive_id;
      case 86: return vertex_position;
      case 85: return vertex_normal;
      case 84: return vertex_color;
      case 79: return vertex_attribute0;
      case 80: return vertex_attribute1;
      case 81: return vertex_attribute2;
      case 82: return vertex_attribute3;
      case 59: return primitive_index;
      default: return empty;
   }
}
const char ** GeometryTriangle::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "primitive.color",
      "primitive.attribute0",
      "primitive.attribute1",
      "primitive.attribute2",
      "primitive.attribute3",
      "primitive.id",
      "vertex.position",
      "vertex.normal",
      "vertex.color",
      "vertex.attribute0",
      "vertex.attribute1",
      "vertex.attribute2",
      "vertex.attribute3",
      "primitive.index",
      nullptr
   };
   return paramnames;
}
size_t GeometryTriangle::paramCount() const {
   return 15;
}

LightDirectional::LightDirectional(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f};
      irradiance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f};
      angularDiameter.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      radiance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      int32_t value[] = {INT32_C(1)};
      visible.set(device, object, ANARI_BOOL, value);
   }
}
bool LightDirectional::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 9: //color
         return color.set(device, object, type, mem);
      case 35: //irradiance
         return irradiance.set(device, object, type, mem);
      case 14: //direction
         return direction.set(device, object, type, mem);
      case 2: //angularDiameter
         return angularDiameter.set(device, object, type, mem);
      case 61: //radiance
         return radiance.set(device, object, type, mem);
      case 88: //visible
         return visible.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void LightDirectional::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 9: //color
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 35: //irradiance
         {
            float value[] = {1.000000f};
            irradiance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 14: //direction
         {
            float value[] = {0.000000f, 0.000000f, 1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 2: //angularDiameter
         {
            float value[] = {0.000000f};
            angularDiameter.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 61: //radiance
         {
            float value[] = {1.000000f};
            radiance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 88: //visible
         {
            int32_t value[] = {INT32_C(1)};
            visible.set(device, object, ANARI_BOOL, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& LightDirectional::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return irradiance;
      case 3: return direction;
      case 4: return angularDiameter;
      case 5: return radiance;
      case 6: return visible;
      default: return empty;
   }
}
ParameterBase& LightDirectional::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 9: return color;
      case 35: return irradiance;
      case 14: return direction;
      case 2: return angularDiameter;
      case 61: return radiance;
      case 88: return visible;
      default: return empty;
   }
}
const char ** LightDirectional::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "irradiance",
      "direction",
      "angularDiameter",
      "radiance",
      "visible",
      nullptr
   };
   return paramnames;
}
size_t LightDirectional::paramCount() const {
   return 7;
}

LightPoint::LightPoint(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f};
      intensity.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      power.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f};
      radius.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      radiance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      int32_t value[] = {INT32_C(1)};
      visible.set(device, object, ANARI_BOOL, value);
   }
}
bool LightPoint::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 9: //color
         return color.set(device, object, type, mem);
      case 51: //position
         return position.set(device, object, type, mem);
      case 32: //intensity
         return intensity.set(device, object, type, mem);
      case 52: //power
         return power.set(device, object, type, mem);
      case 62: //radius
         return radius.set(device, object, type, mem);
      case 61: //radiance
         return radiance.set(device, object, type, mem);
      case 88: //visible
         return visible.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void LightPoint::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 9: //color
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 51: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 32: //intensity
         {
            float value[] = {1.000000f};
            intensity.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 52: //power
         {
            float value[] = {1.000000f};
            power.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 62: //radius
         {
            float value[] = {0.000000f};
            radius.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 61: //radiance
         {
            float value[] = {1.000000f};
            radiance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 88: //visible
         {
            int32_t value[] = {INT32_C(1)};
            visible.set(device, object, ANARI_BOOL, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& LightPoint::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return position;
      case 3: return intensity;
      case 4: return power;
      case 5: return radius;
      case 6: return radiance;
      case 7: return visible;
      default: return empty;
   }
}
ParameterBase& LightPoint::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 9: return color;
      case 51: return position;
      case 32: return intensity;
      case 52: return power;
      case 62: return radius;
      case 61: return radiance;
      case 88: return visible;
      default: return empty;
   }
}
const char ** LightPoint::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "position",
      "intensity",
      "power",
      "radius",
      "radiance",
      "visible",
      nullptr
   };
   return paramnames;
}
size_t LightPoint::paramCount() const {
   return 8;
}

LightSpot::LightSpot(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, -1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {3.141593f};
      openingAngle.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.100000f};
      falloffAngle.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      intensity.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      power.set(device, object, ANARI_FLOAT32, value);
   }
}
bool LightSpot::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 9: //color
         return color.set(device, object, type, mem);
      case 51: //position
         return position.set(device, object, type, mem);
      case 14: //direction
         return direction.set(device, object, type, mem);
      case 48: //openingAngle
         return openingAngle.set(device, object, type, mem);
      case 17: //falloffAngle
         return falloffAngle.set(device, object, type, mem);
      case 32: //intensity
         return intensity.set(device, object, type, mem);
      case 52: //power
         return power.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void LightSpot::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 9: //color
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 51: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 14: //direction
         {
            float value[] = {0.000000f, 0.000000f, -1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 48: //openingAngle
         {
            float value[] = {3.141593f};
            openingAngle.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 17: //falloffAngle
         {
            float value[] = {0.100000f};
            falloffAngle.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 32: //intensity
         {
            float value[] = {1.000000f};
            intensity.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 52: //power
         {
            float value[] = {1.000000f};
            power.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& LightSpot::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return position;
      case 3: return direction;
      case 4: return openingAngle;
      case 5: return falloffAngle;
      case 6: return intensity;
      case 7: return power;
      default: return empty;
   }
}
ParameterBase& LightSpot::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 9: return color;
      case 51: return position;
      case 14: return direction;
      case 48: return openingAngle;
      case 17: return falloffAngle;
      case 32: return intensity;
      case 52: return power;
      default: return empty;
   }
}
const char ** LightSpot::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "position",
      "direction",
      "openingAngle",
      "falloffAngle",
      "intensity",
      "power",
      nullptr
   };
   return paramnames;
}
size_t LightSpot::paramCount() const {
   return 8;
}

MaterialMatte::MaterialMatte(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.800000f, 0.800000f, 0.800000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
}
bool MaterialMatte::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 9: //color
         return color.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void MaterialMatte::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 9: //color
         {
            float value[] = {0.800000f, 0.800000f, 0.800000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& MaterialMatte::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      default: return empty;
   }
}
ParameterBase& MaterialMatte::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 9: return color;
      default: return empty;
   }
}
const char ** MaterialMatte::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      nullptr
   };
   return paramnames;
}
size_t MaterialMatte::paramCount() const {
   return 2;
}

MaterialTransparentMatte::MaterialTransparentMatte(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.800000f, 0.800000f, 0.800000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f};
      opacity.set(device, object, ANARI_FLOAT32, value);
   }
}
bool MaterialTransparentMatte::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 9: //color
         return color.set(device, object, type, mem);
      case 46: //opacity
         return opacity.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void MaterialTransparentMatte::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 9: //color
         {
            float value[] = {0.800000f, 0.800000f, 0.800000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 46: //opacity
         {
            float value[] = {1.000000f};
            opacity.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& MaterialTransparentMatte::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return opacity;
      default: return empty;
   }
}
ParameterBase& MaterialTransparentMatte::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 9: return color;
      case 46: return opacity;
      default: return empty;
   }
}
const char ** MaterialTransparentMatte::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "opacity",
      nullptr
   };
   return paramnames;
}
size_t MaterialTransparentMatte::paramCount() const {
   return 3;
}

SamplerImage1D::SamplerImage1D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "attribute0";
      inAttribute.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "nearest";
      filter.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode1.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
}
bool SamplerImage1D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 26: //image
         return image.set(device, object, type, mem);
      case 28: //inAttribute
         return inAttribute.set(device, object, type, mem);
      case 19: //filter
         return filter.set(device, object, type, mem);
      case 91: //wrapMode1
         return wrapMode1.set(device, object, type, mem);
      case 29: //inTransform
         return inTransform.set(device, object, type, mem);
      case 50: //outTransform
         return outTransform.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void SamplerImage1D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 26: //image
         image.unset(device, object);
         return;
      case 28: //inAttribute
         {
            const char *value = "attribute0";
            inAttribute.set(device, object, ANARI_STRING, value);
         }
         return;
      case 19: //filter
         {
            const char *value = "nearest";
            filter.set(device, object, ANARI_STRING, value);
         }
         return;
      case 91: //wrapMode1
         {
            const char *value = "clampToEdge";
            wrapMode1.set(device, object, ANARI_STRING, value);
         }
         return;
      case 29: //inTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 50: //outTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& SamplerImage1D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return image;
      case 2: return inAttribute;
      case 3: return filter;
      case 4: return wrapMode1;
      case 5: return inTransform;
      case 6: return outTransform;
      default: return empty;
   }
}
ParameterBase& SamplerImage1D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 26: return image;
      case 28: return inAttribute;
      case 19: return filter;
      case 91: return wrapMode1;
      case 29: return inTransform;
      case 50: return outTransform;
      default: return empty;
   }
}
const char ** SamplerImage1D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "image",
      "inAttribute",
      "filter",
      "wrapMode1",
      "inTransform",
      "outTransform",
      nullptr
   };
   return paramnames;
}
size_t SamplerImage1D::paramCount() const {
   return 7;
}

SamplerImage2D::SamplerImage2D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "attribute0";
      inAttribute.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "nearest";
      filter.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode1.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode2.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
}
bool SamplerImage2D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 26: //image
         return image.set(device, object, type, mem);
      case 28: //inAttribute
         return inAttribute.set(device, object, type, mem);
      case 19: //filter
         return filter.set(device, object, type, mem);
      case 91: //wrapMode1
         return wrapMode1.set(device, object, type, mem);
      case 92: //wrapMode2
         return wrapMode2.set(device, object, type, mem);
      case 29: //inTransform
         return inTransform.set(device, object, type, mem);
      case 50: //outTransform
         return outTransform.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void SamplerImage2D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 26: //image
         image.unset(device, object);
         return;
      case 28: //inAttribute
         {
            const char *value = "attribute0";
            inAttribute.set(device, object, ANARI_STRING, value);
         }
         return;
      case 19: //filter
         {
            const char *value = "nearest";
            filter.set(device, object, ANARI_STRING, value);
         }
         return;
      case 91: //wrapMode1
         {
            const char *value = "clampToEdge";
            wrapMode1.set(device, object, ANARI_STRING, value);
         }
         return;
      case 92: //wrapMode2
         {
            const char *value = "clampToEdge";
            wrapMode2.set(device, object, ANARI_STRING, value);
         }
         return;
      case 29: //inTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 50: //outTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& SamplerImage2D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return image;
      case 2: return inAttribute;
      case 3: return filter;
      case 4: return wrapMode1;
      case 5: return wrapMode2;
      case 6: return inTransform;
      case 7: return outTransform;
      default: return empty;
   }
}
ParameterBase& SamplerImage2D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 26: return image;
      case 28: return inAttribute;
      case 19: return filter;
      case 91: return wrapMode1;
      case 92: return wrapMode2;
      case 29: return inTransform;
      case 50: return outTransform;
      default: return empty;
   }
}
const char ** SamplerImage2D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "image",
      "inAttribute",
      "filter",
      "wrapMode1",
      "wrapMode2",
      "inTransform",
      "outTransform",
      nullptr
   };
   return paramnames;
}
size_t SamplerImage2D::paramCount() const {
   return 8;
}

SamplerImage3D::SamplerImage3D(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "attribute0";
      inAttribute.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "nearest";
      filter.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode1.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode2.set(device, object, ANARI_STRING, value);
   }
   {
      const char *value = "clampToEdge";
      wrapMode3.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
}
bool SamplerImage3D::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 26: //image
         return image.set(device, object, type, mem);
      case 28: //inAttribute
         return inAttribute.set(device, object, type, mem);
      case 19: //filter
         return filter.set(device, object, type, mem);
      case 91: //wrapMode1
         return wrapMode1.set(device, object, type, mem);
      case 92: //wrapMode2
         return wrapMode2.set(device, object, type, mem);
      case 93: //wrapMode3
         return wrapMode3.set(device, object, type, mem);
      case 29: //inTransform
         return inTransform.set(device, object, type, mem);
      case 50: //outTransform
         return outTransform.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void SamplerImage3D::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 26: //image
         image.unset(device, object);
         return;
      case 28: //inAttribute
         {
            const char *value = "attribute0";
            inAttribute.set(device, object, ANARI_STRING, value);
         }
         return;
      case 19: //filter
         {
            const char *value = "nearest";
            filter.set(device, object, ANARI_STRING, value);
         }
         return;
      case 91: //wrapMode1
         {
            const char *value = "clampToEdge";
            wrapMode1.set(device, object, ANARI_STRING, value);
         }
         return;
      case 92: //wrapMode2
         {
            const char *value = "clampToEdge";
            wrapMode2.set(device, object, ANARI_STRING, value);
         }
         return;
      case 93: //wrapMode3
         {
            const char *value = "clampToEdge";
            wrapMode3.set(device, object, ANARI_STRING, value);
         }
         return;
      case 29: //inTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            inTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      case 50: //outTransform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            outTransform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& SamplerImage3D::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return image;
      case 2: return inAttribute;
      case 3: return filter;
      case 4: return wrapMode1;
      case 5: return wrapMode2;
      case 6: return wrapMode3;
      case 7: return inTransform;
      case 8: return outTransform;
      default: return empty;
   }
}
ParameterBase& SamplerImage3D::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 26: return image;
      case 28: return inAttribute;
      case 19: return filter;
      case 91: return wrapMode1;
      case 92: return wrapMode2;
      case 93: return wrapMode3;
      case 29: return inTransform;
      case 50: return outTransform;
      default: return empty;
   }
}
const char ** SamplerImage3D::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "image",
      "inAttribute",
      "filter",
      "wrapMode1",
      "wrapMode2",
      "wrapMode3",
      "inTransform",
      "outTransform",
      nullptr
   };
   return paramnames;
}
size_t SamplerImage3D::paramCount() const {
   return 9;
}

SamplerPrimitive::SamplerPrimitive(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      uint64_t value[] = {UINT64_C(0)};
      offset.set(device, object, ANARI_UINT64, value);
   }
}
bool SamplerPrimitive::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 4: //array
         return array.set(device, object, type, mem);
      case 45: //offset
         return offset.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void SamplerPrimitive::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 4: //array
         array.unset(device, object);
         return;
      case 45: //offset
         {
            uint64_t value[] = {UINT64_C(0)};
            offset.set(device, object, ANARI_UINT64, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& SamplerPrimitive::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return array;
      case 2: return offset;
      default: return empty;
   }
}
ParameterBase& SamplerPrimitive::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 4: return array;
      case 45: return offset;
      default: return empty;
   }
}
const char ** SamplerPrimitive::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "array",
      "offset",
      nullptr
   };
   return paramnames;
}
size_t SamplerPrimitive::paramCount() const {
   return 3;
}

SamplerTransform::SamplerTransform(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      const char *value = "attribute0";
      inAttribute.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
      transform.set(device, object, ANARI_FLOAT32_MAT4, value);
   }
}
bool SamplerTransform::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 28: //inAttribute
         return inAttribute.set(device, object, type, mem);
      case 75: //transform
         return transform.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void SamplerTransform::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 28: //inAttribute
         {
            const char *value = "attribute0";
            inAttribute.set(device, object, ANARI_STRING, value);
         }
         return;
      case 75: //transform
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            transform.set(device, object, ANARI_FLOAT32_MAT4, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& SamplerTransform::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return inAttribute;
      case 2: return transform;
      default: return empty;
   }
}
ParameterBase& SamplerTransform::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 28: return inAttribute;
      case 75: return transform;
      default: return empty;
   }
}
const char ** SamplerTransform::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "inAttribute",
      "transform",
      nullptr
   };
   return paramnames;
}
size_t SamplerTransform::paramCount() const {
   return 3;
}

Spatial_FieldStructuredRegular::Spatial_FieldStructuredRegular(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      origin.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      spacing.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      const char *value = "nearest";
      filter.set(device, object, ANARI_STRING, value);
   }
}
bool Spatial_FieldStructuredRegular::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 11: //data
         return data.set(device, object, type, mem);
      case 49: //origin
         return origin.set(device, object, type, mem);
      case 69: //spacing
         return spacing.set(device, object, type, mem);
      case 19: //filter
         return filter.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void Spatial_FieldStructuredRegular::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 11: //data
         data.unset(device, object);
         return;
      case 49: //origin
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            origin.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 69: //spacing
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            spacing.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 19: //filter
         {
            const char *value = "nearest";
            filter.set(device, object, ANARI_STRING, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& Spatial_FieldStructuredRegular::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return data;
      case 2: return origin;
      case 3: return spacing;
      case 4: return filter;
      default: return empty;
   }
}
ParameterBase& Spatial_FieldStructuredRegular::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 11: return data;
      case 49: return origin;
      case 69: return spacing;
      case 19: return filter;
      default: return empty;
   }
}
const char ** Spatial_FieldStructuredRegular::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "data",
      "origin",
      "spacing",
      "filter",
      nullptr
   };
   return paramnames;
}
size_t Spatial_FieldStructuredRegular::paramCount() const {
   return 5;
}

VolumeScivis::VolumeScivis(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {0.000000f, 1.000000f};
      valueRange.set(device, object, ANARI_FLOAT32_BOX1, value);
   }
   {
      float value[] = {1.000000f};
      densityScale.set(device, object, ANARI_FLOAT32, value);
   }
}
bool VolumeScivis::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 18: //field
         return field.set(device, object, type, mem);
      case 77: //valueRange
         return valueRange.set(device, object, type, mem);
      case 9: //color
         return color.set(device, object, type, mem);
      case 10: //color.position
         return color_position.set(device, object, type, mem);
      case 46: //opacity
         return opacity.set(device, object, type, mem);
      case 47: //opacity.position
         return opacity_position.set(device, object, type, mem);
      case 12: //densityScale
         return densityScale.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void VolumeScivis::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 18: //field
         field.unset(device, object);
         return;
      case 77: //valueRange
         {
            float value[] = {0.000000f, 1.000000f};
            valueRange.set(device, object, ANARI_FLOAT32_BOX1, value);
         }
         return;
      case 9: //color
         color.unset(device, object);
         return;
      case 10: //color.position
         color_position.unset(device, object);
         return;
      case 46: //opacity
         opacity.unset(device, object);
         return;
      case 47: //opacity.position
         opacity_position.unset(device, object);
         return;
      case 12: //densityScale
         {
            float value[] = {1.000000f};
            densityScale.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& VolumeScivis::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return field;
      case 2: return valueRange;
      case 3: return color;
      case 4: return color_position;
      case 5: return opacity;
      case 6: return opacity_position;
      case 7: return densityScale;
      default: return empty;
   }
}
ParameterBase& VolumeScivis::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 18: return field;
      case 77: return valueRange;
      case 9: return color;
      case 10: return color_position;
      case 46: return opacity;
      case 47: return opacity_position;
      case 12: return densityScale;
      default: return empty;
   }
}
const char ** VolumeScivis::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "field",
      "valueRange",
      "color",
      "color.position",
      "opacity",
      "opacity.position",
      "densityScale",
      nullptr
   };
   return paramnames;
}
size_t VolumeScivis::paramCount() const {
   return 8;
}

LightRing::LightRing(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, -1.000000f};
      direction.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {3.141593f};
      openingAngle.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.100000f};
      falloffAngle.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      intensity.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      power.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f};
      radius.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {0.000000f};
      innerRadius.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      radiance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f};
      c0.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      int32_t value[] = {INT32_C(1)};
      visible.set(device, object, ANARI_BOOL, value);
   }
}
bool LightRing::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 9: //color
         return color.set(device, object, type, mem);
      case 51: //position
         return position.set(device, object, type, mem);
      case 14: //direction
         return direction.set(device, object, type, mem);
      case 48: //openingAngle
         return openingAngle.set(device, object, type, mem);
      case 17: //falloffAngle
         return falloffAngle.set(device, object, type, mem);
      case 32: //intensity
         return intensity.set(device, object, type, mem);
      case 52: //power
         return power.set(device, object, type, mem);
      case 62: //radius
         return radius.set(device, object, type, mem);
      case 30: //innerRadius
         return innerRadius.set(device, object, type, mem);
      case 61: //radiance
         return radiance.set(device, object, type, mem);
      case 33: //intensityDistribution
         return intensityDistribution.set(device, object, type, mem);
      case 6: //c0
         return c0.set(device, object, type, mem);
      case 88: //visible
         return visible.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void LightRing::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 9: //color
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 51: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 14: //direction
         {
            float value[] = {0.000000f, 0.000000f, -1.000000f};
            direction.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 48: //openingAngle
         {
            float value[] = {3.141593f};
            openingAngle.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 17: //falloffAngle
         {
            float value[] = {0.100000f};
            falloffAngle.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 32: //intensity
         {
            float value[] = {1.000000f};
            intensity.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 52: //power
         {
            float value[] = {1.000000f};
            power.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 62: //radius
         {
            float value[] = {0.000000f};
            radius.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 30: //innerRadius
         {
            float value[] = {0.000000f};
            innerRadius.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 61: //radiance
         {
            float value[] = {1.000000f};
            radiance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 33: //intensityDistribution
         intensityDistribution.unset(device, object);
         return;
      case 6: //c0
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f};
            c0.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 88: //visible
         {
            int32_t value[] = {INT32_C(1)};
            visible.set(device, object, ANARI_BOOL, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& LightRing::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return position;
      case 3: return direction;
      case 4: return openingAngle;
      case 5: return falloffAngle;
      case 6: return intensity;
      case 7: return power;
      case 8: return radius;
      case 9: return innerRadius;
      case 10: return radiance;
      case 11: return intensityDistribution;
      case 12: return c0;
      case 13: return visible;
      default: return empty;
   }
}
ParameterBase& LightRing::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 9: return color;
      case 51: return position;
      case 14: return direction;
      case 48: return openingAngle;
      case 17: return falloffAngle;
      case 32: return intensity;
      case 52: return power;
      case 62: return radius;
      case 30: return innerRadius;
      case 61: return radiance;
      case 33: return intensityDistribution;
      case 6: return c0;
      case 88: return visible;
      default: return empty;
   }
}
const char ** LightRing::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "position",
      "direction",
      "openingAngle",
      "falloffAngle",
      "intensity",
      "power",
      "radius",
      "innerRadius",
      "radiance",
      "intensityDistribution",
      "c0",
      "visible",
      nullptr
   };
   return paramnames;
}
size_t LightRing::paramCount() const {
   return 14;
}

LightQuad::LightQuad(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 0.000000f};
      position.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f, 0.000000f, 0.000000f};
      edge1.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 1.000000f, 0.000000f};
      edge2.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {1.000000f};
      intensity.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      power.set(device, object, ANARI_FLOAT32, value);
   }
   {
      float value[] = {1.000000f};
      radiance.set(device, object, ANARI_FLOAT32, value);
   }
   {
      const char *value = "front";
      side.set(device, object, ANARI_STRING, value);
   }
   {
      int32_t value[] = {INT32_C(1)};
      visible.set(device, object, ANARI_BOOL, value);
   }
}
bool LightQuad::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 9: //color
         return color.set(device, object, type, mem);
      case 51: //position
         return position.set(device, object, type, mem);
      case 15: //edge1
         return edge1.set(device, object, type, mem);
      case 16: //edge2
         return edge2.set(device, object, type, mem);
      case 32: //intensity
         return intensity.set(device, object, type, mem);
      case 52: //power
         return power.set(device, object, type, mem);
      case 61: //radiance
         return radiance.set(device, object, type, mem);
      case 67: //side
         return side.set(device, object, type, mem);
      case 33: //intensityDistribution
         return intensityDistribution.set(device, object, type, mem);
      case 88: //visible
         return visible.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void LightQuad::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 9: //color
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 51: //position
         {
            float value[] = {0.000000f, 0.000000f, 0.000000f};
            position.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 15: //edge1
         {
            float value[] = {1.000000f, 0.000000f, 0.000000f};
            edge1.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 16: //edge2
         {
            float value[] = {0.000000f, 1.000000f, 0.000000f};
            edge2.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 32: //intensity
         {
            float value[] = {1.000000f};
            intensity.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 52: //power
         {
            float value[] = {1.000000f};
            power.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 61: //radiance
         {
            float value[] = {1.000000f};
            radiance.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 67: //side
         {
            const char *value = "front";
            side.set(device, object, ANARI_STRING, value);
         }
         return;
      case 33: //intensityDistribution
         intensityDistribution.unset(device, object);
         return;
      case 88: //visible
         {
            int32_t value[] = {INT32_C(1)};
            visible.set(device, object, ANARI_BOOL, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& LightQuad::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return position;
      case 3: return edge1;
      case 4: return edge2;
      case 5: return intensity;
      case 6: return power;
      case 7: return radiance;
      case 8: return side;
      case 9: return intensityDistribution;
      case 10: return visible;
      default: return empty;
   }
}
ParameterBase& LightQuad::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 9: return color;
      case 51: return position;
      case 15: return edge1;
      case 16: return edge2;
      case 32: return intensity;
      case 52: return power;
      case 61: return radiance;
      case 67: return side;
      case 33: return intensityDistribution;
      case 88: return visible;
      default: return empty;
   }
}
const char ** LightQuad::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "position",
      "edge1",
      "edge2",
      "intensity",
      "power",
      "radiance",
      "side",
      "intensityDistribution",
      "visible",
      nullptr
   };
   return paramnames;
}
size_t LightQuad::paramCount() const {
   return 11;
}

LightHdri::LightHdri(ANARIDevice device, ANARIObject o) : device(device), object(o) {
   {
      float value[] = {1.000000f, 1.000000f, 1.000000f};
      color.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      float value[] = {0.000000f, 0.000000f, 1.000000f};
      up.set(device, object, ANARI_FLOAT32_VEC3, value);
   }
   {
      const char *value = "equirectangular";
      layout.set(device, object, ANARI_STRING, value);
   }
   {
      float value[] = {1.000000f};
      scale.set(device, object, ANARI_FLOAT32, value);
   }
   {
      int32_t value[] = {INT32_C(1)};
      visible.set(device, object, ANARI_BOOL, value);
   }
}
bool LightHdri::set(const char *paramname, ANARIDataType type, const void *mem) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         return name.set(device, object, type, mem);
      case 9: //color
         return color.set(device, object, type, mem);
      case 76: //up
         return up.set(device, object, type, mem);
      case 61: //radiance
         return radiance.set(device, object, type, mem);
      case 36: //layout
         return layout.set(device, object, type, mem);
      case 65: //scale
         return scale.set(device, object, type, mem);
      case 88: //visible
         return visible.set(device, object, type, mem);
      default: // unknown param
         //unknown parameter
         return false;
   }
}
void LightHdri::unset(const char *paramname) {
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: //name
         name.unset(device, object);
         return;
      case 9: //color
         {
            float value[] = {1.000000f, 1.000000f, 1.000000f};
            color.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 76: //up
         {
            float value[] = {0.000000f, 0.000000f, 1.000000f};
            up.set(device, object, ANARI_FLOAT32_VEC3, value);
         }
         return;
      case 61: //radiance
         radiance.unset(device, object);
         return;
      case 36: //layout
         {
            const char *value = "equirectangular";
            layout.set(device, object, ANARI_STRING, value);
         }
         return;
      case 65: //scale
         {
            float value[] = {1.000000f};
            scale.set(device, object, ANARI_FLOAT32, value);
         }
         return;
      case 88: //visible
         {
            int32_t value[] = {INT32_C(1)};
            visible.set(device, object, ANARI_BOOL, value);
         }
         return;
      default: // unknown param
         //unknown parameter
         return;
   }
}
ParameterBase& LightHdri::operator[](size_t idx) {
   static EmptyParameter empty;
   switch(idx) {
      case 0: return name;
      case 1: return color;
      case 2: return up;
      case 3: return radiance;
      case 4: return layout;
      case 5: return scale;
      case 6: return visible;
      default: return empty;
   }
}
ParameterBase& LightHdri::operator[](const char *paramname) {
   static EmptyParameter empty;
   int idx = param_hash(paramname);
   switch(idx) {
      case 43: return name;
      case 9: return color;
      case 76: return up;
      case 61: return radiance;
      case 36: return layout;
      case 65: return scale;
      case 88: return visible;
      default: return empty;
   }
}
const char ** LightHdri::paramNames() const {
   static const char *paramnames[] = {
      "name",
      "color",
      "up",
      "radiance",
      "layout",
      "scale",
      "visible",
      nullptr
   };
   return paramnames;
}
size_t LightHdri::paramCount() const {
   return 7;
}

} //namespace anari_sdk
} //namespace tree
