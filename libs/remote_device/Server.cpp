// Copyright 2023 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

#include <anari/anari_cpp.hpp>
#include <functional>
#include <iostream>
#include <sstream>
#include "ArrayInfo.h"
#include "Compression.h"
#include "Logging.h"
#include "async/connection.h"
#include "async/connection_manager.h"
#include "async/work_queue.h"
#include "common.h"

using namespace std::placeholders;

namespace remote {

// Global variables
std::string g_libraryType = "environment";

ANARILibrary g_library = nullptr;
bool g_verbose = false;

void statusFunc(const void *userData,
    ANARIDevice device,
    ANARIObject source,
    ANARIDataType sourceType,
    ANARIStatusSeverity severity,
    ANARIStatusCode code,
    const char *message)
{
  bool verbose = *(const bool *)userData;
  if (severity == ANARI_SEVERITY_FATAL_ERROR) {
    fprintf(stderr, "[FATAL] %s\n", message);
  } else if (severity == ANARI_SEVERITY_ERROR) {
    fprintf(stderr, "[ERROR] %s\n", message);
  } else if (severity == ANARI_SEVERITY_WARNING) {
    fprintf(stderr, "[WARN ] %s\n", message);
  }

  if (!verbose)
    return;

  if (severity == ANARI_SEVERITY_PERFORMANCE_WARNING) {
    fprintf(stderr, "[PERF ] %s\n", message);
  } else if (severity == ANARI_SEVERITY_INFO) {
    fprintf(stderr, "[INFO ] %s\n", message);
  } else if (severity == ANARI_SEVERITY_DEBUG) {
    fprintf(stderr, "[DEBUG] %s\n", message);
  }
}

static ANARIObject newObject(
    ANARIDevice dev, ANARIDataType type, std::string subtype)
{
  if (type == ANARI_LIGHT) {
    return anariNewLight(dev, subtype.c_str());
  } else if (type == ANARI_CAMERA) {
    return anariNewCamera(dev, subtype.c_str());
  } else if (type == ANARI_GEOMETRY) {
    return anariNewGeometry(dev, subtype.c_str());
  } else if (type == ANARI_SPATIAL_FIELD) {
    return anariNewSpatialField(dev, subtype.c_str());
  } else if (type == ANARI_SURFACE) {
    return anariNewSurface(dev);
  } else if (type == ANARI_VOLUME) {
    return anariNewVolume(dev, subtype.c_str());
  } else if (type == ANARI_MATERIAL) {
    return anariNewMaterial(dev, subtype.c_str());
  } else if (type == ANARI_SAMPLER) {
    return anariNewSampler(dev, subtype.c_str());
  } else if (type == ANARI_GROUP) {
    return anariNewGroup(dev);
  } else if (type == ANARI_INSTANCE) {
    return anariNewInstance(dev);
  } else if (type == ANARI_WORLD) {
    return anariNewWorld(dev);
  } else if (type == ANARI_FRAME) {
    return anariNewFrame(dev);
  } else if (type == ANARI_RENDERER) {
    return anariNewRenderer(dev, subtype.c_str());
  }

  return nullptr;
}

static ANARIArray newArray(
    ANARIDevice dev, const ArrayInfo &info, const uint8_t *data)
{
  ANARIArray array = nullptr;
  if (info.type == ANARI_ARRAY1D) {
    array = anariNewArray1D(dev,
        nullptr,
        nullptr,
        nullptr,
        info.elementType,
        info.numItems1,
        info.byteStride1);
  } else if (info.type == ANARI_ARRAY2D) {
    array = anariNewArray2D(dev,
        nullptr,
        nullptr,
        nullptr,
        info.elementType,
        info.numItems1,
        info.numItems2,
        info.byteStride1,
        info.byteStride2);
  } else if (info.type == ANARI_ARRAY3D) {
    array = anariNewArray3D(dev,
        nullptr,
        nullptr,
        nullptr,
        info.elementType,
        info.numItems1,
        info.numItems2,
        info.numItems3,
        info.byteStride1,
        info.byteStride3,
        info.byteStride3);
  }

  if (array) {
    void *ptr = anariMapArray(dev, array);
    memcpy(ptr, data, info.getSizeInBytes());
    anariUnmapArray(dev, array);
  }

  return array;
}

struct ServerObject
{
  ANARIDevice device{nullptr};
  ANARIObject handle{nullptr};
  ANARIDataType type{ANARI_UNKNOWN};
};

struct ResourceManager
{
  // Device handles are generated by us and returned to the client
  Handle registerDevice(ANARIDevice dev)
  {
    Handle handle = nextDeviceHandle++;
    size_t newNumHandles = std::max(anariDevices.size(), (size_t)handle + 1);
    anariDevices.resize(newNumHandles);
    serverObjects.resize(newNumHandles);
    anariDevices[handle] = dev;
    return handle;
  }

  // Object handles are generated by the clients
  void registerObject(uint64_t deviceID,
      uint64_t objectID,
      ANARIObject anariObj,
      ANARIDataType type)
  {
    size_t newNumHandles =
        std::max(serverObjects[deviceID].size(), (size_t)objectID + 1);

    serverObjects[deviceID].resize(newNumHandles);
    serverObjects[deviceID][objectID] = {
        anariDevices[deviceID], anariObj, type};
  }

  ANARIDevice getDevice(uint64_t deviceID)
  {
    if (deviceID >= anariDevices.size())
      return nullptr;

    return anariDevices[deviceID];
  }

  ServerObject getServerObject(Handle deviceHandle, Handle objectHandle)
  {
    if (deviceHandle >= serverObjects.size()
        || objectHandle >= serverObjects[deviceHandle].size())
      return {};

    return serverObjects[deviceHandle][objectHandle];
  }

  Handle nextDeviceHandle = 1;

  std::vector<ANARIDevice> anariDevices;

  // vector of anari objects per device
  std::vector<std::vector<ServerObject>> serverObjects;
};

struct Server
{
  ResourceManager resourceManager;
  async::connection_manager_pointer manager;
  async::connection_pointer conn;
  async::work_queue queue;

  explicit Server(unsigned short port = 31050)
      : manager(async::make_connection_manager(port))
  {
    logging::Initialize();

    g_library = anariLoadLibrary(g_libraryType.c_str(), statusFunc, &g_verbose);
  }

  ~Server()
  {
    anariUnloadLibrary(g_library);
  }

  void accept()
  {
    LOG(logging::Level::Info) << "Server: accepting...";

    manager->accept(std::bind(&Server::handleNewConnection, this, _1, _2));
  }

  void run()
  {
    manager->run_in_thread();
    queue.run_in_thread();
  }

  void wait()
  {
    manager->wait();
  }

  void write(unsigned type, std::shared_ptr<Buffer> buf)
  {
    queue.post(std::bind(&Server::writeImpl, this, type, buf));
  }

  void writeImpl(unsigned type, std::shared_ptr<Buffer> buf)
  {
    conn->write(type, *buf);
  }

  bool handleNewConnection(
      async::connection_pointer new_conn, boost::system::error_code const &e)
  {
    if (e) {
      LOG(logging::Level::Error)
          << "Server: could not connect to client: " << e.message();
      manager->stop();
      return false;
    }

    LOG(logging::Level::Info) << "server: connected";

    // Accept and save this connection
    // and set the message handler of the connection
    conn = new_conn;
    conn->set_handler(std::bind(&Server::handleMessage, this, _1, _2, _3));

    // Accept new connections (TODO: the new connection
    // will overwrite the current one, so, store these
    // in a list of connections)
    accept();

    return true;
  }

  void handleMessage(async::connection::reason reason,
      async::message_pointer message,
      boost::system::error_code const &e)
  {
    if (e) {
      LOG(logging::Level::Error) << "Server: error: " << e.message();

      manager->stop();
      return;
    }

    if (reason == async::connection::Read) {
      if (message->type() == MessageType::NewDevice) {
        LOG(logging::Level::Info) << "Message: NewDevice, message size: "
                                  << prettyBytes(message->size());

        std::string deviceType(message->data(), message->size());
        ANARIDevice dev = anariNewDevice(g_library, deviceType.c_str());
        Handle deviceHandle = resourceManager.registerDevice(dev);

        // return device handle to client
        auto buf = std::make_shared<Buffer>();
        buf->write((char *)&deviceHandle, sizeof(deviceHandle));
        write(MessageType::DeviceHandle, buf);

        LOG(logging::Level::Info)
            << "Creating new device, type: " << deviceType
            << ", device ID: " << deviceHandle << ", ANARI handle: " << dev;
      } else if (message->type() == MessageType::NewObject) {
        LOG(logging::Level::Info) << "Message: NewObject, message size: "
                                  << prettyBytes(message->size());

        Buffer buf;
        buf.write(message->data(), message->size());
        buf.seek(0);

        ANARIDevice deviceHandle;
        buf.read((char *)&deviceHandle, sizeof(deviceHandle));

        ANARIDataType type;
        buf.read((char *)&type, sizeof(type));

        uint64_t len;
        buf.read((char *)&len, sizeof(len));
        std::vector<char> st(len);
        buf.read(st.data(), st.size());
        std::string subtype(st.data(), st.size());

        uint64_t objectID;
        buf.read((char *)&objectID, sizeof(objectID));

        ANARIDevice dev = resourceManager.getDevice((uint64_t)deviceHandle);
        if (!dev) {
          LOG(logging::Level::Error)
              << "Server: invalid device: " << deviceHandle;
          // manager->stop(); // legal?
          return;
        }
        ANARIObject anariObj = newObject(dev, type, subtype);
        resourceManager.registerObject(
            (uint64_t)deviceHandle, objectID, anariObj, type);

        LOG(logging::Level::Info)
            << "Creating new object, objectID: " << objectID
            << ", ANARI handle: " << anariObj;
      } else if (message->type() == MessageType::NewArray) {
        LOG(logging::Level::Info) << "Message: NewArray, message size: "
                                  << prettyBytes(message->size());

        ArrayInfo info;
        Buffer buf;
        buf.write(message->data(), message->size());
        buf.seek(0);

        ANARIDevice deviceHandle;
        buf.read((char *)&deviceHandle, sizeof(deviceHandle));

        buf.read((char *)&info.type, sizeof(info.type));

        uint64_t objectID;
        buf.read((char *)&objectID, sizeof(objectID));
        buf.read((char *)&info.elementType, sizeof(info.elementType));
        buf.read((char *)&info.numItems1, sizeof(info.numItems1));
        buf.read((char *)&info.numItems2, sizeof(info.numItems2));
        buf.read((char *)&info.numItems3, sizeof(info.numItems3));
        buf.read((char *)&info.byteStride1, sizeof(info.byteStride1));
        buf.read((char *)&info.byteStride2, sizeof(info.byteStride2));
        buf.read((char *)&info.byteStride3, sizeof(info.byteStride3));

        ANARIDevice dev = resourceManager.getDevice((uint64_t)deviceHandle);
        if (!dev) {
          LOG(logging::Level::Error)
              << "Server: invalid device: " << deviceHandle;
          // manager->stop(); // legal?
          return;
        }

        std::vector<uint8_t> arrayData;
        if (buf.pos < message->size()) {
          arrayData.resize(info.getSizeInBytes());
          buf.read((char *)arrayData.data(), arrayData.size());

          // Translate remote to device handles
          if (anari::isObject(info.elementType)) {
            const auto &serverObjects =
                resourceManager.serverObjects[(uint64_t)deviceHandle];

            assert(info.byteStride1 <= 1 && info.byteStride2 <= 1
                && info.byteStride3 <= 1);

            size_t numObjects = info.numItems1
                * std::max(uint64_t(1), info.numItems2)
                * std::max(uint64_t(1), info.numItems3);

            // This only works b/c sizeof(ANARIObject)==sizeof(uint64_t)!
            // TODO: can this cause issues with alignment on some platforms?!
            const uint64_t *handles = (const uint64_t *)arrayData.data();
            ANARIObject *objects = (ANARIObject *)arrayData.data();

            for (size_t i = 0; i < numObjects; ++i) {
              objects[i] = serverObjects[handles[i]].handle;
            }
          }
        }

        ANARIArray anariArr = newArray(dev, info, arrayData.data());
        resourceManager.registerObject(
            (uint64_t)deviceHandle, objectID, anariArr, info.type);

        LOG(logging::Level::Info)
            << "Creating new array, objectID: " << objectID
            << ", ANARI handle: " << anariArr;
      } else if (message->type() == MessageType::SetParam) {
        LOG(logging::Level::Info) << "Message: SetParam, message size: "
                                  << prettyBytes(message->size());

        Buffer buf;
        buf.write(message->data(), message->size());
        buf.seek(0);

        Handle deviceHandle, objectHandle;
        buf.read((char *)&deviceHandle, sizeof(deviceHandle));
        buf.read((char *)&objectHandle, sizeof(objectHandle));

        ANARIDevice dev = resourceManager.getDevice(deviceHandle);

        ServerObject serverObj =
            resourceManager.getServerObject(deviceHandle, objectHandle);

        if (!dev || !serverObj.handle) {
          LOG(logging::Level::Error)
              << "Error setting param on object. Handle: " << objectHandle;
          // manager->stop(); // legal?
          return;
        }

        uint64_t nameLen;
        buf.read((char *)&nameLen, sizeof(nameLen));

        std::vector<char> nameBuf(nameLen);
        buf.read(nameBuf.data(), nameBuf.size());

        ANARIDataType parmType;
        buf.read((char *)&parmType, sizeof(parmType));

        std::vector<char> parmValue;
        if (anari::isObject(parmType)) {
          parmValue.resize(sizeof(uint64_t));
          buf.read((char *)parmValue.data(), sizeof(uint64_t));
        } else {
          parmValue.resize(anari::sizeOf(parmType));
          buf.read((char *)parmValue.data(), anari::sizeOf(parmType));
        }

        std::string name(nameBuf.data(), nameBuf.size());

        if (anari::isObject(parmType)) {
          const auto &serverObjects =
              resourceManager.serverObjects[(uint64_t)deviceHandle];
          Handle hnd = *(Handle *)parmValue.data();
          anariSetParameter(dev,
              serverObj.handle,
              name.c_str(),
              parmType,
              &serverObjects[hnd].handle);

          LOG(logging::Level::Info)
              << "Set param \"" << name << "\" on object: " << objectHandle
              << ", param is an object. Handle: " << hnd
              << ", ANARI handle: " << serverObjects[hnd].handle;
        } else {
          anariSetParameter(
              dev, serverObj.handle, name.c_str(), parmType, parmValue.data());

          LOG(logging::Level::Info)
              << "Set param \"" << name << "\" on object: " << objectHandle;
        }
      } else if (message->type() == MessageType::UnsetParam) {
        LOG(logging::Level::Info) << "Message: UnsetParam, message size: "
                                  << prettyBytes(message->size());

        Buffer buf;
        buf.write(message->data(), message->size());
        buf.seek(0);

        Handle deviceHandle, objectHandle;
        buf.read((char *)&deviceHandle, sizeof(deviceHandle));
        buf.read((char *)&objectHandle, sizeof(objectHandle));

        ANARIDevice dev = resourceManager.getDevice(deviceHandle);

        ServerObject serverObj =
            resourceManager.getServerObject(deviceHandle, objectHandle);

        if (!dev || !serverObj.handle) {
          LOG(logging::Level::Error)
              << "Error setting param on object. Handle: " << objectHandle;
          // manager->stop(); // legal?
          return;
        }

        uint64_t nameLen;
        buf.read((char *)&nameLen, sizeof(nameLen));

        std::vector<char> nameBuf(nameLen);
        buf.read(nameBuf.data(), nameBuf.size());

        std::string name(nameBuf.data(), nameBuf.size());

        anariUnsetParameter(dev, serverObj.handle, name.c_str());
      } else if (message->type() == MessageType::CommitParams) {
        LOG(logging::Level::Info) << "Message: CommitParams, message size: "
                                  << prettyBytes(message->size());

        Buffer buf;
        buf.write(message->data(), message->size());
        buf.seek(0);

        if (message->size() == sizeof(Handle)) {
          // handle only => commit params of the device itself!
          ANARIDevice device;
          buf.read((char *)&device, sizeof(device));

          ANARIDevice dev = resourceManager.getDevice((uint64_t)device);

          if (!dev) {
            LOG(logging::Level::Error)
                << "Error committing devcie params: " << dev;
            // manager->stop(); // legal?
            return;
          }

          anariCommitParameters(dev, dev);
        } else {
          Handle deviceHandle, objectHandle;
          buf.read((char *)&deviceHandle, sizeof(deviceHandle));
          buf.read((char *)&objectHandle, sizeof(objectHandle));

          ANARIDevice dev = resourceManager.getDevice(deviceHandle);

          ServerObject serverObj =
              resourceManager.getServerObject(deviceHandle, objectHandle);

          if (!dev || !serverObj.handle) {
            LOG(logging::Level::Error)
                << "Error setting param on object. Handle: " << objectHandle;
            // manager->stop(); // legal?
            return;
          }

          anariCommitParameters(dev, serverObj.handle);

          LOG(logging::Level::Info)
              << "Committed object. Handle: " << objectHandle;
        }
      } else if (message->type() == MessageType::Release) {
        LOG(logging::Level::Info) << "Message: Release, message size: "
                                  << prettyBytes(message->size());

        Buffer buf;
        buf.write(message->data(), message->size());
        buf.seek(0);

        Handle deviceHandle, objectHandle;
        buf.read((char *)&deviceHandle, sizeof(deviceHandle));
        buf.read((char *)&objectHandle, sizeof(objectHandle));

        ANARIDevice dev = resourceManager.getDevice(deviceHandle);

        ServerObject serverObj =
            resourceManager.getServerObject(deviceHandle, objectHandle);

        if (!dev || !serverObj.handle) {
          LOG(logging::Level::Error)
              << "Error releasing object. Handle: " << objectHandle;
          // manager->stop(); // legal?
          return;
        }

        anariRelease(dev, serverObj.handle);

        LOG(logging::Level::Info)
            << "Released object. Handle: " << objectHandle;
      } else if (message->type() == MessageType::Retain) {
        LOG(logging::Level::Info) << "Message: Retain, message size: "
                                  << prettyBytes(message->size());

        Buffer buf;
        buf.write(message->data(), message->size());
        buf.seek(0);

        Handle deviceHandle, objectHandle;
        buf.read((char *)&deviceHandle, sizeof(deviceHandle));
        buf.read((char *)&objectHandle, sizeof(objectHandle));

        ANARIDevice dev = resourceManager.getDevice(deviceHandle);

        ServerObject serverObj =
            resourceManager.getServerObject(deviceHandle, objectHandle);

        if (!dev || !serverObj.handle) {
          LOG(logging::Level::Error)
              << "Error retaining object. Handle: " << objectHandle;
          // manager->stop(); // legal?
          return;
        }

        anariRetain(dev, serverObj.handle);

        LOG(logging::Level::Info)
            << "Retained object. Handle: " << objectHandle;
      } else if (message->type() == MessageType::RenderFrame) {
        LOG(logging::Level::Info) << "Message: RenderFrame, message size: "
                                  << prettyBytes(message->size());

        Buffer buf;
        buf.write(message->data(), message->size());
        buf.seek(0);

        Handle deviceHandle, objectHandle;
        buf.read((char *)&deviceHandle, sizeof(deviceHandle));
        buf.read((char *)&objectHandle, sizeof(objectHandle));

        ANARIDevice dev = resourceManager.getDevice(deviceHandle);

        if (!dev) {
          LOG(logging::Level::Error)
              << "Server: invalid device: " << deviceHandle;
          // manager->stop(); // legal?
          return;
        }

        ANARIFrame frame = (ANARIFrame)resourceManager
                               .getServerObject(deviceHandle, objectHandle)
                               .handle;
        anariRenderFrame(dev, frame);

        // Block and send image over the wire
        anariFrameReady(dev, frame, ANARI_WAIT);

        uint32_t width, height;
        ANARIDataType type;
        const char *color = (const char *)anariMapFrame(
            dev, frame, "channel.color", &width, &height, &type);
        size_t colorSize =
            type == ANARI_UNKNOWN ? 0 : width * height * anari::sizeOf(type);
        if (color != nullptr && colorSize != 0) {
          auto outbuf = std::make_shared<Buffer>();
          outbuf->write((const char *)&objectHandle, sizeof(objectHandle));
          outbuf->write((const char *)&width, sizeof(width));
          outbuf->write((const char *)&height, sizeof(height));
          outbuf->write((const char *)&type, sizeof(type));
          if (type == ANARI_UFIXED8_RGBA_SRGB) { // TODO: more formats..
            TurboJPEGOptions options;
            options.width = width;
            options.height = height;
            options.pixelFormat = TurboJPEGOptions::PixelFormat::RGBX;
            options.quality = 80;

            std::vector<uint8_t> compressed(
                getMaxCompressedBufferSizeTurboJPEG(options));

            if (compressed.size() != 0) {
              size_t compressedSize;
              if (compressTurboJPEG((const uint8_t *)color,
                      compressed.data(),
                      compressedSize,
                      options)) {
                uint32_t compressedSize32(compressedSize);
                outbuf->write(
                    (const char *)&compressedSize32, sizeof(compressedSize32));
                outbuf->write((const char *)compressed.data(), compressedSize);

                LOG(logging::Level::Info) << "turbojpeg compression size: "
                                          << prettyBytes(compressedSize);
              }
            }
          } else {
            outbuf->write(color, colorSize);
          }
          write(MessageType::ChannelColor, outbuf);
        }

        const char *depth = (const char *)anariMapFrame(
            dev, frame, "channel.depth", &width, &height, &type);
        size_t depthSize =
            type == ANARI_UNKNOWN ? 0 : width * height * anari::sizeOf(type);
        if (depth != nullptr && depthSize != 0) {
          auto outbuf = std::make_shared<Buffer>();
          outbuf->write((const char *)&objectHandle, sizeof(objectHandle));
          outbuf->write((const char *)&width, sizeof(width));
          outbuf->write((const char *)&height, sizeof(height));
          outbuf->write((const char *)&type, sizeof(type));
          if (type == ANARI_FLOAT32) {
            SNAPPYOptions options;
            options.inputSize = depthSize;

            std::vector<uint8_t> compressed(
                getMaxCompressedBufferSizeSNAPPY(options));

            size_t compressedSize = 0;

            compressSNAPPY((const uint8_t *)depth,
                compressed.data(),
                compressedSize,
                options);

            uint32_t compressedSize32(compressedSize);
            outbuf->write(
                (const char *)&compressedSize32, sizeof(compressedSize32));
            outbuf->write((const char *)compressed.data(), compressedSize);
          } else {
            outbuf->write(depth, depthSize);
          }
          write(MessageType::ChannelDepth, outbuf);
        }

        LOG(logging::Level::Info)
            << "Frame rendered. Object handle: " << objectHandle;
      } else if (message->type() == MessageType::FrameReady) {
        LOG(logging::Level::Info) << "Message: FrameReady, message size: "
                                  << prettyBytes(message->size());

        Buffer buf;
        buf.write(message->data(), message->size());
        buf.seek(0);

        Handle deviceHandle, objectHandle;
        buf.read((char *)&deviceHandle, sizeof(deviceHandle));
        buf.read((char *)&objectHandle, sizeof(objectHandle));

        ANARIDevice dev = resourceManager.getDevice(deviceHandle);

        if (!dev) {
          LOG(logging::Level::Error)
              << "Server: invalid device: " << deviceHandle;
          // manager->stop(); // legal?
          return;
        }

        ANARIWaitMask waitMask;
        buf.read((char *)&waitMask, sizeof(waitMask));

        ANARIFrame frame = (ANARIFrame)resourceManager
                               .getServerObject(deviceHandle, objectHandle)
                               .handle;
        anariFrameReady(dev, frame, waitMask);

        auto outbuf = std::make_shared<Buffer>();
        outbuf->write((const char *)&objectHandle, sizeof(objectHandle));
        write(MessageType::FrameIsReady, outbuf);

        LOG(logging::Level::Info) << "Signal frame is ready to client";
      } else if (message->type() == MessageType::GetProperty) {
        LOG(logging::Level::Info) << "Message: GetProperty, message size: "
                                  << prettyBytes(message->size());

        Buffer buf;
        buf.write(message->data(), message->size());
        buf.seek(0);

        Handle deviceHandle, objectHandle;
        buf.read((char *)&deviceHandle, sizeof(deviceHandle));
        buf.read((char *)&objectHandle, sizeof(objectHandle));

        ANARIDevice dev = resourceManager.getDevice(deviceHandle);

        if (!dev) {
          LOG(logging::Level::Error)
              << "Server: invalid device: " << deviceHandle;
          // manager->stop(); // legal?
          return;
        }

        ServerObject serverObj =
            resourceManager.getServerObject(deviceHandle, objectHandle);

        if (!serverObj.handle) { // then we're querying properties on the device
                                 // itself!
          serverObj.device = dev;
          serverObj.handle = dev;
          serverObj.type = ANARI_DEVICE;
        }

        uint64_t len;
        buf.read((char *)&len, sizeof(len));
        std::vector<char> name(len + 1);
        buf.read(name.data(), len);
        name[len] = '\0';

        ANARIDataType type;
        buf.read((char *)&type, sizeof(type));

        uint64_t size;
        buf.read((char *)&size, sizeof(size));

        ANARIWaitMask mask;
        buf.read((char *)&mask, sizeof(mask));

        auto outbuf = std::make_shared<Buffer>();

        if (type == ANARI_STRING_LIST) {
          const char *const *stringList = nullptr;
          int result = anariGetProperty(dev,
              serverObj.handle,
              name.data(),
              type,
              &stringList,
              size,
              mask);

          outbuf->write((const char *)&objectHandle, sizeof(objectHandle));
          outbuf->write((const char *)&len, sizeof(len));
          outbuf->write(name.data(), len);
          outbuf->write((const char *)&result, sizeof(result));

          uint64_t listSize = 0;
          auto sl = stringList;
          if (sl != nullptr) {
            while (const char *str = *sl++) {
              listSize++;
            }
          }

          outbuf->write((const char *)&listSize, sizeof(listSize));

          sl = stringList;
          if (sl != nullptr) {
            while (const char *str = *sl++) {
              uint64_t strLen = strlen(str);
              outbuf->write((const char *)&strLen, sizeof(strLen));
              outbuf->write(str, strLen);
            }
          }
        } else if (type == ANARI_DATA_TYPE_LIST) {
          throw std::runtime_error(
              "getProperty with ANARI_DATA_TYPE_LIST not implemented yet!");
        } else { // POD!
          std::vector<char> mem(size);

          int result = anariGetProperty(
              dev, serverObj.handle, name.data(), type, mem.data(), size, mask);

          outbuf->write((const char *)&objectHandle, sizeof(objectHandle));
          outbuf->write((const char *)&len, sizeof(len));
          outbuf->write(name.data(), len);
          outbuf->write((const char *)&result, sizeof(result));
          outbuf->write((const char *)mem.data(), size);
        }
        write(MessageType::Property, outbuf);
      } else {
        LOG(logging::Level::Warning)
            << "Unhandled message of size: " << message->size();
      }
    } else {
      // LOG(logging::Level::Info) << "written";
    }
  }
};

} // namespace remote

int main(int argc, char **argv)
{
  remote::Server srv;
  srv.accept();
  srv.run();
  srv.wait();
}
